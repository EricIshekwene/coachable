This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    release.yml
    test.yml
  FUNDING.yml
src/
  makeUpdates.ts
  ReactKonva.ts
  ReactKonvaCore.tsx
  ReactKonvaHostConfig.ts
test/
  mocking.js
  react-konva-test.tsx
  react-konva.test.tsx
.gitignore
.travis.yml
LICENSE
package.json
react-konva.d.ts
ReactKonvaCore.d.ts
README.md
replace-version.js
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/release.yml">
---
name: 'tagged-release'

on:
  push:
    tags:
      - '*'

jobs:
  tagged-release:
    name: 'Tagged Release'
    runs-on: 'ubuntu-latest'

    steps:
      # ...
      - name: 'Build & test'
        run: |
          echo "done!"

      - uses: 'marvinpinto/action-automatic-releases@latest'
        with:
          repo_token: '${{ secrets.GITHUB_TOKEN }}'
          prerelease: false
</file>

<file path=".github/workflows/test.yml">
name: Test Browser

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [24.x]

    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm install
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
      - run: npm run test
</file>

<file path=".github/FUNDING.yml">
# These are supported funding model platforms

github: [lavrton]
patreon: lavrton
open_collective: konva
ko_fi: # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
otechie: # Replace with a single Otechie username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']
</file>

<file path="src/makeUpdates.ts">
import { Konva } from 'konva/lib/Global.js';

const propsToSkip = {
  children: true,
  ref: true,
  key: true,
  style: true,
  forwardedRef: true,
  unstable_applyCache: true,
  unstable_applyDrawHitFromCache: true,
};

let zIndexWarningShowed = false;
let dragWarningShowed = false;

export const EVENTS_NAMESPACE = '.react-konva-event';

let useStrictMode = false;
export function toggleStrictMode(value) {
  useStrictMode = value;
}

const DRAGGABLE_WARNING = `ReactKonva: You have a Konva node with draggable = true and position defined but no onDragMove or onDragEnd events are handled.
Position of a node will be changed during drag&drop, so you should update state of the react app as well.
Consider to add onDragMove or onDragEnd events.
For more info see: https://github.com/konvajs/react-konva/issues/256
`;

const Z_INDEX_WARNING = `ReactKonva: You are using "zIndex" attribute for a Konva node.
react-konva may get confused with ordering. Just define correct order of elements in your render function of a component.
For more info see: https://github.com/konvajs/react-konva/issues/194
`;

const EMPTY_PROPS = {};

export function applyNodeProps(instance, props, oldProps = EMPTY_PROPS) {
  // don't use zIndex in react-konva
  if (!zIndexWarningShowed && 'zIndex' in props) {
    console.warn(Z_INDEX_WARNING);
    zIndexWarningShowed = true;
  }

  // check correct draggable usage
  if (!dragWarningShowed && props.draggable) {
    var hasPosition = props.x !== undefined || props.y !== undefined;
    var hasEvents = props.onDragEnd || props.onDragMove;
    if (hasPosition && !hasEvents) {
      console.warn(DRAGGABLE_WARNING);
      dragWarningShowed = true;
    }
  }

  // check old props
  // we need to unset properties that are not in new props
  // and remove all events
  for (var key in oldProps) {
    if (propsToSkip[key]) {
      continue;
    }
    var isEvent = key.slice(0, 2) === 'on';
    var propChanged = oldProps[key] !== props[key];

    // if that is a changed event, we need to remove it
    if (isEvent && propChanged) {
      var eventName = key.substr(2).toLowerCase();
      if (eventName.substr(0, 7) === 'content') {
        eventName =
          'content' +
          eventName.substr(7, 1).toUpperCase() +
          eventName.substr(8);
      }
      instance.off(eventName, oldProps[key]);
    }
    var toRemove = !props.hasOwnProperty(key);
    if (toRemove) {
      instance.setAttr(key, undefined);
    }
  }

  var strictUpdate = useStrictMode || props._useStrictMode;
  var updatedProps = {};
  var hasUpdates = false;

  const newEvents = {};

  for (var key in props) {
    if (propsToSkip[key]) {
      continue;
    }
    var isEvent = key.slice(0, 2) === 'on';
    var toAdd = oldProps[key] !== props[key];
    if (isEvent && toAdd) {
      var eventName = key.substr(2).toLowerCase();
      if (eventName.substr(0, 7) === 'content') {
        eventName =
          'content' +
          eventName.substr(7, 1).toUpperCase() +
          eventName.substr(8);
      }
      // check that event is not undefined
      if (props[key]) {
        newEvents[eventName] = props[key];
      }
    }
    if (
      !isEvent &&
      (props[key] !== oldProps[key] ||
        (strictUpdate && props[key] !== instance.getAttr(key)))
    ) {
      hasUpdates = true;
      updatedProps[key] = props[key];
    }
  }

  if (hasUpdates) {
    instance.setAttrs(updatedProps);
    updatePicture(instance);
  }

  // subscribe to events AFTER we set attrs
  // we need it to fix https://github.com/konvajs/react-konva/issues/471
  // settings attrs may add events. Like "draggable: true" will add "mousedown" listener
  for (var eventName in newEvents) {
    // first clear any existing listeners, it is required for strict mode
    instance.off(eventName + EVENTS_NAMESPACE);
    // then attach new one
    instance.on(eventName + EVENTS_NAMESPACE, newEvents[eventName]);
  }
}

export function updatePicture(node) {
  if (!Konva.autoDrawEnabled) {
    var drawingNode = node.getLayer() || node.getStage();
    drawingNode && drawingNode.batchDraw();
  }
}
</file>

<file path="src/ReactKonva.ts">
/**
 * Based on ReactArt.js
 * Copyright (c) 2017-present Lavrenov Anton.
 * All rights reserved.
 *
 * MIT
 */
'use strict';

import 'konva';
export * from './ReactKonvaCore.js';
</file>

<file path="src/ReactKonvaCore.tsx">
/**
 * Based on ReactArt.js
 * Copyright (c) 2017-present Lavrenov Anton.
 * All rights reserved.
 *
 * MIT
 */
'use strict';

import React from 'react';

if (React.version.indexOf('19') === -1) {
  throw new Error(
    'react-konva version 19 is only compatible with React 19. Make sure to have the last version of react-konva and react or downgrade react-konva to version 18.'
  );
}

import Konva from 'konva/lib/Core.js';
import type { Stage as KonvaStage } from 'konva/lib/Stage.js';
import ReactFiberReconciler, {
  RootTag,
  SuspenseHydrationCallbacks,
  TransitionTracingCallbacks,
} from 'react-reconciler';
import { ConcurrentRoot } from 'react-reconciler/constants.js';
import * as HostConfig from './ReactKonvaHostConfig.js';
import { applyNodeProps, toggleStrictMode } from './makeUpdates.js';
import { useContextBridge, FiberProvider } from 'its-fine';
import { Container } from 'konva/lib/Container.js';

/**
 * React 19 introduced a new `ReactFiberReconciler.createContainer` signature
 * with more error handling options [1]. The DefinitelyTyped types are also
 * out of date because of this [2].
 *
 * 1. https://github.com/facebook/react/commit/a0537160771bafae90c6fd3154eeead2f2c903e7
 * 2. https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react-reconciler/index.d.ts#L920
 */
type NewCreateContainer = (
  containerInfo: Container,
  tag: RootTag,
  hydrationCallbacks: null | SuspenseHydrationCallbacks<any>,
  isStrictMode: boolean,
  concurrentUpdatesByDefaultOverride: null | boolean,
  identifierPrefix: string,
  onUncaughtError: (error: Error) => void,
  onCaughtError: (error: Error) => void,
  onRecoverableError: (error: Error) => void,
  transitionCallbacks: null | TransitionTracingCallbacks
) => ReactFiberReconciler.FiberRoot;

function usePrevious(value) {
  const ref = React.useRef({});
  React.useLayoutEffect(() => {
    ref.current = value;
  });
  React.useLayoutEffect(() => {
    return () => {
      // when using suspense it is possible that stage is unmounted
      // but React still keep component ref
      // in that case we need to manually flush props
      // we have a special test for that
      ref.current = {};
    };
  }, []);
  return ref.current;
}

const useIsReactStrictMode = () => {
  const memoCount = React.useRef(0);
  // in strict mode, memo will be called twice
  React.useMemo(() => {
    memoCount.current++;
  }, []);
  return memoCount.current > 1;
};

const StageWrap = (props) => {
  const container = React.useRef(null);
  const stage = React.useRef<any>(null);
  const fiberRef = React.useRef(null);

  const oldProps = usePrevious(props);
  const Bridge = useContextBridge();
  const pendingDestroy = React.useRef<ReturnType<typeof setTimeout> | null>(
    null
  );

  const _setRef = (stage) => {
    const { forwardedRef } = props;
    if (!forwardedRef) {
      return;
    }
    if (typeof forwardedRef === 'function') {
      forwardedRef(stage);
    } else {
      forwardedRef.current = stage;
    }
  };

  const isStrictMode = useIsReactStrictMode();

  const destroyStage = () => {
    _setRef(null);
    KonvaRenderer.updateContainer(null, fiberRef.current, null);
    stage.current?.destroy();
    stage.current = null;
  };

  React.useLayoutEffect(() => {
    // Cancel any pending destruction (happens during re-ordering in strict mode)
    if (pendingDestroy.current) {
      clearTimeout(pendingDestroy.current);
      pendingDestroy.current = null;
    }

    // If stage already exists (re-ordering scenario), reuse it
    if (stage.current) {
      _setRef(stage.current);
    } else {
      stage.current = new Konva.Stage({
        width: props.width,
        height: props.height,
        container: container.current,
      });

      _setRef(stage.current);

      // @ts-ignore
      fiberRef.current = (KonvaRenderer.createContainer as NewCreateContainer)(
        stage.current,
        ConcurrentRoot,
        null,
        false,
        null,
        '',
        console.error,
        console.error,
        console.error,
        null
      );

      KonvaRenderer.updateContainer(
        React.createElement(Bridge, {}, props.children),
        fiberRef.current,
        null,
        () => {}
      );
    }

    return () => {
      if (isStrictMode) {
        // Delay destruction to allow cancellation on remount
        pendingDestroy.current = setTimeout(destroyStage, 0);
      } else {
        destroyStage();
      }
    };
  }, []);

  React.useLayoutEffect(() => {
    _setRef(stage.current);
    applyNodeProps(stage.current, props, oldProps);

    // =============================================================================
    // CRITICAL FIX - DO NOT REMOVE
    // =============================================================================
    // This flushSyncFromReconciler wrapper is CRITICAL for React 19 compatibility.
    //
    // THE BUG:
    // When using useSyncExternalStore (MobX, Zustand, etc.) with react-konva,
    // parent component's useLayoutEffect couldn't find newly added Konva nodes.
    // The nodes were added to the store, but not yet rendered to the canvas.
    //
    // ROOT CAUSE:
    // React 19's updateContainer can defer Konva reconciler work to a later
    // microtask. Combined with Bridge component (from its-fine) and Html components
    // that create secondary React roots, this caused child components to render
    // AFTER parent's useLayoutEffect completed.
    //
    // THE FIX:
    // flushSyncFromReconciler forces ALL scheduled Konva reconciler work to
    // complete synchronously within this useLayoutEffect, ensuring child
    // components render before any parent effects run.
    //
    // WARNING - NOT COVERED BY TESTS:
    // This bug CANNOT be reproduced in local test environments (Vitest/Playwright).
    // It only manifests in production builds with specific conditions:
    // - MobX/useSyncExternalStore for state management
    // - Html components with secondary React roots using Bridge
    // - Complex component hierarchies (multiple pages/stages)
    // The fix was verified in Polotno production app.
    // =============================================================================
    (KonvaRenderer as any).flushSyncFromReconciler(() => {
      KonvaRenderer.updateContainer(
        React.createElement(Bridge, {}, props.children),
        fiberRef.current,
        null
      );
    });
  });

  return React.createElement('div', {
    ref: container,
    id: props.id,
    accessKey: props.accessKey,
    className: props.className,
    role: props.role,
    style: props.style,
    tabIndex: props.tabIndex,
    title: props.title,
  });
};

export const Layer = 'Layer';
export const FastLayer = 'FastLayer';
export const Group = 'Group';
export const Label = 'Label';
export const Rect = 'Rect';
export const Circle = 'Circle';
export const Ellipse = 'Ellipse';
export const Wedge = 'Wedge';
export const Line = 'Line';
export const Sprite = 'Sprite';
export const Image = 'Image';
export const Text = 'Text';
export const TextPath = 'TextPath';
export const Star = 'Star';
export const Ring = 'Ring';
export const Arc = 'Arc';
export const Tag = 'Tag';
export const Path = 'Path';
export const RegularPolygon = 'RegularPolygon';
export const Arrow = 'Arrow';
export const Shape = 'Shape';
export const Transformer = 'Transformer';

export const version = '{VERSION}';

// @ts-ignore
export const KonvaRenderer = ReactFiberReconciler(HostConfig);

// we should inject into dev tools, but it is not working with React 19.2
// with error "Invalid argument not valid semver ('' received)"
// KonvaRenderer.injectIntoDevTools({
//   // @ts-ignore
//   findHostInstanceByFiber: () => null,
//   bundleType: 0,
//   version: React.version,
//   rendererPackageName: 'react-konva',
//   reconcilerVersion: '19.2.0',
// });

// Add this interface
interface StageProps extends React.RefAttributes<KonvaStage> {
  children?: React.ReactNode;
  width?: number;
  height?: number;
  name?: string;
  [key: string]: any;
}

// Update Stage component declaration
export const Stage: React.FC<StageProps> = React.forwardRef((props, ref) => {
  return React.createElement(
    FiberProvider,
    {},
    React.createElement(StageWrap, { ...props, forwardedRef: ref })
  );
});

export const useStrictMode = toggleStrictMode;

// export useContextBridge from its-fine for reuse in react-konva-utils
// so react-konva-utils don't use its own version of its-fine (it is possible on pnpm)
export { useContextBridge };
</file>

<file path="src/ReactKonvaHostConfig.ts">
import React from 'react';
import Konva from 'konva/lib/Core.js';
import {
  applyNodeProps,
  updatePicture,
  EVENTS_NAMESPACE,
} from './makeUpdates.js';

export {
  unstable_now as now,
  unstable_IdlePriority as idlePriority,
  unstable_runWithPriority as run,
} from 'scheduler';
import {
  // NoEventPriority,
  DefaultEventPriority,
  DiscreteEventPriority,
} from 'react-reconciler/constants.js';

const NO_CONTEXT = {};
const UPDATE_SIGNAL = {};

// for react-spring capability
(Konva.Node.prototype as any)._applyProps = applyNodeProps;

// let currentUpdatePriority: number = NoEventPriority;
let currentUpdatePriority: number = DefaultEventPriority;

export function appendInitialChild(parentInstance, child) {
  if (typeof child === 'string') {
    // Noop for string children of Text (eg <Text>foo</Text>)
    console.error(
      `Do not use plain text as child of Konva.Node. You are using text: ${child}`
    );
    return;
  }

  parentInstance.add(child);

  updatePicture(parentInstance);
}

export function createInstance(type, props, internalInstanceHandle) {
  let NodeClass = Konva[type];
  if (!NodeClass) {
    console.error(
      `Konva has no node with the type ${type}. Group will be used instead. If you use minimal version of react-konva, just import required nodes into Konva: "import "konva/lib/shapes/${type}"  If you want to render DOM elements as part of canvas tree take a look into this demo: https://konvajs.github.io/docs/react/DOM_Portal.html`
    );
    NodeClass = Konva.Group;
  }

  // we need to split props into events and non events
  // we we can pass non events into constructor directly
  // that way the performance should be better
  // we we apply change "applyNodeProps"
  // then it will trigger change events on first run
  // but we don't need them!
  const propsWithoutEvents = {};
  const propsWithOnlyEvents = {};

  for (var key in props) {
    // ignore ref
    if (key === 'ref') {
      continue;
    }
    var isEvent = key.slice(0, 2) === 'on';
    if (isEvent) {
      propsWithOnlyEvents[key] = props[key];
    } else {
      propsWithoutEvents[key] = props[key];
    }
  }

  const instance = new NodeClass(propsWithoutEvents);

  applyNodeProps(instance, propsWithOnlyEvents);

  return instance;
}

export function createTextInstance(
  text,
  rootContainerInstance,
  internalInstanceHandle
) {
  console.error(
    `Text components are not supported for now in ReactKonva. Your text is: "${text}"`
  );
}

export function finalizeInitialChildren(domElement, type, props) {
  return false;
}

export function getPublicInstance(instance) {
  return instance;
}

export function prepareForCommit() {
  return null;
}

export function preparePortalMount() {
  return null;
}

export function prepareUpdate(domElement, type, oldProps, newProps) {
  return UPDATE_SIGNAL;
}

export function resetAfterCommit() {
  // Noop
}

export function resetTextContent(domElement) {
  // Noop
}

export function shouldDeprioritizeSubtree(type, props) {
  return false;
}

export function getRootHostContext() {
  return NO_CONTEXT;
}

export function getChildHostContext() {
  return NO_CONTEXT;
}

export const scheduleTimeout = setTimeout;
export const cancelTimeout = clearTimeout;
export const supportsMicrotasks = true;
// Run microtasks synchronously for immediate updates
export const scheduleMicrotask = (fn) => {
  fn();
};
export const noTimeout = -1;
// export const schedulePassiveEffects = scheduleDeferredCallback;
// export const cancelPassiveEffects = cancelDeferredCallback;

export function shouldSetTextContent(type, props) {
  return false;
}

// The Konva renderer is secondary to the React DOM renderer.
export const isPrimaryRenderer = false;
export const warnsIfNotActing = false;
export const supportsMutation = true;
export const supportsPersistence = false;
export const supportsHydration = false;

export function appendChild(parentInstance, child) {
  if (child.parent === parentInstance) {
    child.moveToTop();
  } else {
    parentInstance.add(child);
  }

  updatePicture(parentInstance);
}

export function appendChildToContainer(parentInstance, child) {
  if (child.parent === parentInstance) {
    child.moveToTop();
  } else {
    parentInstance.add(child);
  }
  updatePicture(parentInstance);
}

export function insertBefore(parentInstance, child, beforeChild) {
  // child._remove() will not stop dragging
  // but child.remove() will stop it, but we don't need it
  // removing will reset zIndexes
  child._remove();
  parentInstance.add(child);
  child.setZIndex(beforeChild.getZIndex());
  updatePicture(parentInstance);
}

export function insertInContainerBefore(parentInstance, child, beforeChild) {
  insertBefore(parentInstance, child, beforeChild);
}

export function removeChild(parentInstance, child) {
  child.destroy();
  child.off(EVENTS_NAMESPACE);
  updatePicture(parentInstance);
}

export function removeChildFromContainer(parentInstance, child) {
  child.destroy();
  child.off(EVENTS_NAMESPACE);
  updatePicture(parentInstance);
}

export function commitTextUpdate(textInstance, oldText, newText) {
  console.error(
    `Text components are not yet supported in ReactKonva. You text is: "${newText}"`
  );
}

export function commitMount(instance, type, newProps) {
  // Noop
}

export function commitUpdate(instance, type, oldProps, newProps) {
  applyNodeProps(instance, newProps, oldProps);
}

export function hideInstance(instance) {
  instance.hide();
  updatePicture(instance);
}

export function hideTextInstance(textInstance) {
  // Noop
}

export function unhideInstance(instance, props) {
  if (props.visible == null || props.visible) {
    instance.show();
  }
}

export function unhideTextInstance(textInstance, text) {
  // Noop
}

export function clearContainer(container) {
  // Noop
}

export function detachDeletedInstance() {}

export function getInstanceFromNode() {
  return null;
}

export function beforeActiveInstanceBlur() {}

export function afterActiveInstanceBlur() {}

export function getCurrentEventPriority() {
  return DefaultEventPriority;
}

export function prepareScopeUpdate() {}

export function getInstanceFromScope() {
  return null;
}

export function setCurrentUpdatePriority(newPriority) {
  currentUpdatePriority = newPriority;
}

export function getCurrentUpdatePriority() {
  return currentUpdatePriority;
}

export function resolveUpdatePriority() {
  return DiscreteEventPriority;
}

export function shouldAttemptEagerTransition() {
  return false;
}

export function trackSchedulerEvent() {}

export function resolveEventType() {
  return null;
}

export function resolveEventTimeStamp() {
  return -1.1;
}

export function requestPostPaintCallback() {}

export function maySuspendCommit() {
  return false;
}

export function preloadInstance() {
  return true;
}

export function startSuspendingCommit() {}

export function suspendInstance() {}

export function waitForCommitToBeReady() {
  return null;
}

export const NotPendingTransition = null;

// React 19 transition context - create as React context that can be cast by reconciler
export const HostTransitionContext = /* @__PURE__ */ React.createContext(null);

export function resetFormInstance() {}
</file>

<file path="test/mocking.js">
import Konva from 'konva';

Konva.Stage.prototype.simulateMouseDown = function (pos) {
  var top = this.content.getBoundingClientRect().top;

  this._pointerdown({
    clientX: pos.x,
    clientY: pos.y + top,
    button: pos.button,
    type: 'mousedown',
  });
};

Konva.Stage.prototype.simulateMouseMove = function (pos) {
  var top = this.content.getBoundingClientRect().top;

  var evt = {
    clientX: pos.x,
    clientY: pos.y + top,
    button: pos.button,
    type: 'mousemove',
  };

  this._pointermove(evt);
  Konva.DD._drag(evt);
};

Konva.Stage.prototype.simulateMouseUp = function (pos) {
  'use strict';
  var top = this.content.getBoundingClientRect().top;

  var evt = {
    clientX: pos.x,
    clientY: pos.y + top,
    button: pos.button,
    type: 'mouseup',
  };

  Konva.DD._endDragBefore(evt);
  this._pointerup(evt);
  Konva.DD._endDragAfter(evt);
};
</file>

<file path="test/react-konva-test.tsx">
// @ts-nocheck
import React from 'react';
import { createRoot } from 'react-dom/client';
import { vi, expect } from 'vitest';
import Konva from 'konva';
import useImage from 'use-image';

import './mocking';
import {
  Stage,
  Rect,
  Layer,
  useStrictMode,
  Group,
  Text,
  Image,
  Circle,
  Transformer,
} from '../src/ReactKonva';

globalThis.IS_REACT_ACT_ENVIRONMENT = true;

// Suppress console warnings about act() for custom reconciler updates
const originalConsoleError = console.error;
const originalConsoleWarn = console.warn;

console.error = (...args) => {
  const message = args[0];
  if (
    typeof message === 'string' &&
    (message.includes('was not wrapped in act') ||
      message.includes('suspended resource finished loading'))
  ) {
    // Suppress act warnings for custom reconciler
    return;
  }
  originalConsoleError.apply(console, args);
};

const render = async (component) => {
  const node = document.createElement('div');
  document.body.appendChild(node);
  const root = createRoot(node);

  await React.act(() => {
    root.render(component);
  });

  return {
    stage: Konva.stages[Konva.stages.length - 1],
    rerender: async (component) => {
      await React.act(() => {
        root.render(component);
      });
    },
  };
};

describe('initial mounting and refs', () => {
  it('trigger effect hooks', async () => {
    const func = vi.fn();
    const App = () => {
      React.useEffect(() => {
        func();
      });
      const ref = React.useRef<Konva.Stage>(null);
      return <Stage ref={ref} />;
    };
    await render(React.createElement(App));
    expect(func).toHaveBeenCalledOnce();
  });

  it('can set reference to stage', async () => {
    const App = () => {
      React.useEffect(() => {
        expect(ref.current instanceof Konva.Stage).toBe(true);
      });
      const ref = React.useRef<Konva.Stage>(null);
      return <Stage ref={ref} />;
    };
    await render(React.createElement(App));
  });

  it('check all refs', async () => {
    let stageRef;
    let layerRef;
    let rectRef;

    const App = () => {
      stageRef = React.useRef<Konva.Stage>(null);
      layerRef = React.useRef<Konva.Layer>(null);
      rectRef = React.useRef<Konva.Rect>(null);

      React.useEffect(() => {
        expect(stageRef.current instanceof Konva.Stage).toBe(true);
      });

      return (
        <Stage ref={stageRef}>
          <Layer ref={layerRef}>
            <Rect ref={rectRef} />
          </Layer>
        </Stage>
      );
    };
    await render(React.createElement(App));
    expect(stageRef.current instanceof Konva.Stage).toBe(true);
    expect(layerRef.current instanceof Konva.Layer).toBe(true);
    expect(rectRef.current instanceof Konva.Rect).toBe(true);
    expect(rectRef.current.getAttr('ref')).toBeUndefined();
  });

  it('no fail on no ref', async () => {
    await render(<Stage />);
  });

  it('works with functional reference', async () => {
    const App = () => {
      return (
        <Stage
          ref={(node) => {
            if (node) {
              expect(node instanceof Konva.Stage).toBe(true);
            }
          }}
        />
      );
    };
    await render(React.createElement(App));
  });

  it('check initial props', async () => {
    const App = ({ width, height }) => {
      const ref = React.useRef<Konva.Stage>(null);
      React.useEffect(() => {
        expect(ref.current?.width()).toBe(100);
      });
      return <Stage ref={ref} width={width} height={height} />;
    };
    await render(<App width={100} height={100} />);
  });

  // this test doesn't work...
  // for unknow reason ref setting is triggered AFTER effect of App component
  // looks like it is because of cross-reconcilier case
  it('forward ref on Konva components', async () => {
    const MyRect = React.forwardRef((props, ref) => <Rect ref={ref} />);

    const App = () => {
      const ref = React.useRef<Konva.Rect>(null);
      const stageRef = React.useRef<Konva.Stage>(null);
      React.useEffect(() => {
        expect((ref.current as any) instanceof Konva.Rect).toBe(true);
      });
      return (
        <Stage ref={stageRef} name="hello">
          <Layer>
            <MyRect ref={ref} />
            <Rect />
          </Layer>
        </Stage>
      );
    };
    await render(<App />);
  });

  it.skip('sync rendder', async () => {
    const Inner = () => {
      const [position, setPosition] = React.useState({
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
      });

      return (
        <Layer>
          <Circle
            x={position.x}
            y={position.y}
            radius={70}
            fill="red"
            onDragEnd={(e) => {
              setPosition({
                x: e.target.x(),
                y: e.target.y(),
              });
            }}
          />
          <Circle
            x={position.x}
            y={position.y}
            radius={70}
            fill="yellow"
            draggable
            onDragMove={(e) => {
              setPosition({
                x: e.target.x(),
                y: e.target.y(),
              });
            }}
          />
        </Layer>
      );
    };

    const App = () => {
      return (
        <Stage width={window.innerWidth} height={window.innerHeight}>
          <Inner />
        </Stage>
      );
    };

    await render(<App />);
  });

  it('forward ref deep in Konva tree', async () => {
    let effectRun = false;
    const MyRect = React.forwardRef((props, ref) => <Rect ref={ref} />);

    const MyLayer = () => {
      const ref = React.useRef();
      React.useEffect(() => {
        effectRun = true;
        expect((ref.current as any) instanceof Konva.Rect).toBe(true);
      });
      return (
        <Layer>
          <MyRect ref={ref} />
        </Layer>
      );
    };

    const App = () => {
      return (
        <Stage>
          <MyLayer />
        </Stage>
      );
    };
    await render(<App />);
    expect(effectRun).toBe(true);
  });
});

describe('Test stage component', async function () {
  it('can attach stage events', async function () {
    let eventCount = 0;
    const handleEvent = () => {
      eventCount += 1;
    };

    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300} onMouseDown={handleEvent}>
            <Layer>
              <Rect width={100} height={100} />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    await React.act(() => {
      stage.simulateMouseDown({ x: 50, y: 50 });
    });
    expect(eventCount).toBe(1);
  });

  it('unmount stage should destroy it from Konva', async () => {
    class App extends React.Component {
      render() {
        if (this.props.skipStage) {
          return <div />;
        }
        return (
          <Stage width={300} height={300}>
            <Layer />
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    const stagesNumber = Konva.stages.length;
    await rerender(<App skipStage />);
    expect(Konva.stages.length).toBe(stagesNumber - 1);
  });

  it('test null event', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300} onMouseDown={null}>
            <Layer>
              <Rect width={100} height={100} />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    await React.act(() => {
      stage.simulateMouseDown({ x: 50, y: 50 });
    });
  });

  it('check div props', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300} id="hello">
            <Layer>
              <Rect width={100} height={100} />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    expect(stage.id()).toBe('hello');
    expect(stage.container().id).toBe('hello');
  });
});

describe('Test props setting', async function () {
  let stage, rerender;
  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          <Layer>
            <Rect {...this.props.rectProps} />
          </Layer>
        </Stage>
      );
    }
  }

  const setProps = async (props) => {
    await rerender(<App {...props} />);
  };

  beforeEach(async () => {
    const res = await render(<App />);
    stage = res.stage;
    rerender = res.rerender;
  });

  it('can update component props', async () => {
    const rect = stage.findOne('Rect');
    // set new props
    const props1 = {
      width: 100,
      height: 100,
    };

    await setProps({ rectProps: props1 });
    expect(rect.width()).toBe(100);

    const props2 = {
      width: 200,
      height: 100,
    };
    await setProps({ rectProps: props2 });
    expect(rect.width()).toBe(200);
  });
  it('can update component events', async () => {
    const rect = stage.findOne('Rect');
    // set new props
    const props1 = {
      onClick: () => {},
    };
    await setProps({ rectProps: props1 });
    expect(rect.eventListeners.click.length).toBe(1);
    expect(rect.eventListeners.click[0].handler).toBe(props1.onClick);

    const props2 = {
      onClick: () => {},
    };
    await setProps({ rectProps: props2 });
    expect(rect.eventListeners.click.length).toBe(1);
    expect(rect.eventListeners.click[0].handler).toBe(props2.onClick);
  });

  it('updating props should call layer redraw', async () => {
    const layer = stage.findOne('Layer');
    vi.spyOn(layer, 'batchDraw');
    await setProps({
      rectProps: {
        fill: 'green',
      },
    });
    await setProps({
      rectProps: {
        fill: 'red',
      },
    });
    expect(layer.batchDraw).toHaveBeenCalledTimes(2);
  });

  it('unset props', async () => {
    const rect = stage.findOne('Rect');
    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.fill()).toBe('red');

    await setProps({ rectProps: {} });
    expect(!!rect.fill()).toBe(false);
    expect(rect.x()).toBe(0);
  });

  it('do not overwrite properties if that changed manually', async () => {
    const rect = stage.findOne('Rect');
    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(10);

    // change position manually
    rect.x(20);

    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(20);
  });

  it('overwrite properties if that changed manually in strict-mode', async () => {
    useStrictMode(true);
    const rect = stage.findOne('Rect');
    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(10);

    // change position manually
    rect.x(20);

    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(10);
    useStrictMode(false);
  });

  it('overwrite properties if that passed _useStrictMode', async () => {
    const rect = stage.findOne('Rect');
    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(10);

    // change position manually
    rect.x(20);

    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
        _useStrictMode: true,
      },
    });
    expect(rect.x()).toBe(10);
  });
});

describe('test lifecycle methods', () => {
  class SubComponent extends React.Component<any> {
    // comment, as it will be removed
    // componentWillMount() {
    //   this.props.componentWillMount();
    // }
    componentDidMount() {
      this.props.componentDidMount();
    }
    // componentWillReceiveProps(newProps) {
    //   this.props.componentWillReceiveProps(newProps);
    // }
    shouldComponentUpdate() {
      this.props.shouldComponentUpdate(...arguments);
      return true;
    }
    // componentWillUpdate() {
    //   this.props.componentWillUpdate();
    // }
    componentDidUpdate() {
      this.props.componentDidUpdate();
    }
    componentWillUnmount() {
      this.props.componentWillUnmount();
    }
    render() {
      return <Rect />;
    }
  }
  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          <Layer>
            {this.props.dontDrawChildren ? null : (
              <SubComponent {...this.props} />
            )}
          </Layer>
        </Stage>
      );
    }
  }

  const setProps = async (rerender, props) => {
    await rerender(<App {...props} />);
  };

  // beforeEach(async () => {
  //   const res = await render(<App />);
  //   stage = res.stage;
  //   rerender = res.rerender;
  // });

  it('test mount', async () => {
    const props = {
      // componentWillMount: vi.fn(),
      componentDidMount: vi.fn(),
    };
    await render(<App {...props} />);

    // expect(props.componentWillMount).toHaveBeenCalled();
    expect(props.componentDidMount).toHaveBeenCalled();
  });

  it('test update', async () => {
    const props = {
      // componentWillMount: vi.fn(),
      componentDidMount: vi.fn(),
      // componentWillReceiveProps: vi.fn(),
      shouldComponentUpdate: vi.fn(),
      // componentWillUpdate: vi.fn(),
      componentDidUpdate: vi.fn(),
      componentWillUnmount: vi.fn(),
    };
    const { rerender } = await render(<App {...props} />);
    await setProps(rerender, props);

    // expect(props.componentWillMount).toHaveBeenCalled();
    expect(props.shouldComponentUpdate).toHaveBeenCalled();
    // expect(props.componentWillUpdate).toHaveBeenCalled();
    expect(props.componentDidUpdate).toHaveBeenCalled();
  });

  it('test remove', async () => {
    const props = {
      // componentWillMount: vi.fn(),
      componentDidMount: vi.fn(),
      // componentWillReceiveProps: vi.fn(),
      shouldComponentUpdate: vi.fn(),
      // componentWillUpdate: vi.fn(),
      componentDidUpdate: vi.fn(),
      componentWillUnmount: vi.fn(),
    };
    const { rerender, stage } = await render(<App {...props} />);
    expect(stage.findOne('Rect')).not.toEqual(undefined);

    props.dontDrawChildren = props;
    await setProps(rerender, props);
    expect(stage.findOne('Rect')).toEqual(undefined);
    // This line don't work... why????
    expect(props.componentWillUnmount).toHaveBeenCalled();
  });
});

describe('Test Events', async function () {
  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          {this.props.shouldDrawLayer && <Layer onClick={this.props.onClick} />}
        </Stage>
      );
    }
  }

  it('should remove events on unmount', async function () {
    const onClickRect = vi.fn();
    const onClickExternal = vi.fn();

    const { stage, rerender } = await render(
      <App onClick={onClickRect} shouldDrawLayer />
    );

    const setProps = async (props) => {
      await rerender(<App {...props} />);
    };

    const layer = stage.findOne('Layer');
    layer.on('click', onClickExternal);

    expect(onClickRect).toHaveBeenCalledTimes(0);
    expect(onClickExternal).toHaveBeenCalledTimes(0);

    layer._fire('click', {});
    expect(onClickRect).toHaveBeenCalledTimes(1);
    expect(onClickExternal).toHaveBeenCalledTimes(1);

    // remove layer
    await setProps({ shouldDrawLayer: false });

    expect(layer.getParent()).toEqual(null);

    layer._fire('click', {});

    expect(onClickRect).toHaveBeenCalledTimes(1);
    expect(onClickExternal).toHaveBeenCalledTimes(2);
  });
});

describe('Bad structure', () => {
  it('No dom inside Konva', async function () {
    const originalError = console.error;
    const error = vi.fn();
    console.error = error;
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>
              <div />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    expect(error).toHaveBeenCalledTimes(1);
    expect(error.mock.calls[0][0]).toContain(
      'Konva has no node with the type div'
    );
    console.error = originalError;
    // check check that this test is not failed
  });
});

describe('Check id saving', () => {
  it('Konva can loose ids?', async function () {
    class App extends React.Component {
      render() {
        const kids = [
          <Rect key="1" id="rect1" fill="red" />,
          <Rect key="2" id="rect2" fill="green" />,
        ];
        return (
          <Stage width={300} height={300}>
            <Layer>
              {this.props.drawAsGroup ? <Group>{kids}</Group> : kids}
            </Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    expect(stage.findOne('#rect1').fill()).toBe('red');
    expect(stage.findOne('#rect2').fill()).toBe('green');

    await rerender(<App drawAsGroup />);

    expect(stage.findOne('#rect1').fill()).toBe('red');
    expect(stage.findOne('#rect2').fill()).toBe('green');
  });
});

describe('Test drawing calls', () => {
  afterEach(() => {
    Konva.Layer.prototype.batchDraw.restore &&
      Konva.Layer.prototype.batchDraw.restore();
  });

  it('Draw layer on mount', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>
              <Rect fill="red" />
            </Layer>
          </Stage>
        );
      }
    }

    expect((Konva.Layer.prototype.batchDraw as any).mock).toBeUndefined();
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    const { stage } = await render(<App />);

    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalled();
    vi.restoreAllMocks();
  });

  it('Draw layer on node add', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>{this.props.showRect && <Rect fill="red" />}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(0);
    await rerender(<App showRect />);

    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(1);
    vi.restoreAllMocks();
  });

  it('Draw layer on node remove', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>{!this.props.hideRect && <Rect fill="red" />}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(0);
    await rerender(<App hideRect />);

    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(1);
    vi.restoreAllMocks();
  });
});

describe('test reconciler', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('add before', async function () {
    class App extends React.Component {
      render() {
        const kids = this.props.drawMany
          ? [<Rect key="1" name="rect1" />, <Rect key="2" name="rect2" />]
          : [<Rect key="2" name="rect2" />];
        return (
          <Stage width={300} height={300}>
            <Layer>{kids}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    await rerender(<App drawMany />);

    const layer = stage.children[0];
    expect(layer.children[0].name()).toEqual('rect1');
    expect(layer.children[1].name()).toEqual('rect2');
    expect(
      (Konva.Layer.prototype.batchDraw as any).mock.calls.length >= 1
    ).toBe(true);
  });

  it('add before (mane)', async function () {
    class App extends React.Component {
      render() {
        const kids = this.props.drawMany
          ? [
              <Rect key="1" name="rect1" />,
              <Rect key="2" name="rect2" />,
              <Rect key="3" name="rect3" />,
            ]
          : [<Rect key="1" name="rect1" />, <Rect key="3" name="rect3" />];
        return (
          <Stage width={300} height={300}>
            <Layer>{kids}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    await rerender(<App drawMany />);

    const layer = stage.children[0];
    expect(layer.children[0].name()).toBe('rect1');
    expect(layer.children[1].name()).toBe('rect2');
    expect(layer.children[2].name()).toBe('rect3');
  });

  it('add after', async function () {
    class App extends React.Component {
      render() {
        const kids = this.props.drawMany
          ? [<Rect key="1" name="rect1" />, <Rect key="2" name="rect2" />]
          : [<Rect key="1" name="rect1" />];
        return (
          <Stage width={300} height={300}>
            <Layer>{kids}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    await rerender(<App drawMany />);

    const layer = stage.children[0];
    expect(layer.children[0].name()).toEqual('rect1');
    expect(layer.children[1].name()).toEqual('rect2');
    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(1);
  });

  it('change order', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>{this.props.kids}</Layer>
          </Stage>
        );
      }
    }

    let kids = [
      <Rect key="1" name="rect1" />,
      <Rect key="2" name="rect2" />,
      <Rect key="3" name="rect3" />,
    ];
    const { stage, rerender } = await render(<App kids={kids} />);
    const layer = stage.children[0];

    expect(layer.children[0].name()).toBe('rect1');
    expect(layer.children[1].name()).toBe('rect2');
    expect(layer.children[2].name()).toBe('rect3');

    // last to first
    kids = [
      <Rect key="3" name="rect3" />,
      <Rect key="1" name="rect1" />,
      <Rect key="2" name="rect2" />,
    ];
    await rerender(<App kids={kids} />);
    expect(layer.children[0].name()).toBe('rect3');
    expect(layer.children[1].name()).toBe('rect1');
    expect(layer.children[2].name()).toBe('rect2');

    // second to first
    kids = [
      <Rect key="1" name="rect1" />,
      <Rect key="3" name="rect3" />,
      <Rect key="2" name="rect2" />,
    ];

    await rerender(<App kids={kids} />);

    expect(layer.children[0].name()).toBe('rect1');
    expect(layer.children[1].name()).toBe('rect3');
    expect(layer.children[2].name()).toBe('rect2');

    kids = [
      <Rect key="2" name="rect2" />,
      <Rect key="1" name="rect1" />,
      <Rect key="3" name="rect3" />,
    ];
    await rerender(<App kids={kids} />);

    expect(layer.children[0].name()).toBe('rect2');
    expect(layer.children[1].name()).toBe('rect1');
    expect(layer.children[2].name()).toBe('rect3');

    kids = [
      <Rect key="4" name="rect4" />,
      <Rect key="2" name="rect2" />,
      <Rect key="1" name="rect1" />,
      <Rect key="3" name="rect3" />,
    ];
    await rerender(<App kids={kids} />);

    expect(layer.children[0].name()).toBe('rect4');
    expect(layer.children[1].name()).toBe('rect2');
    expect(layer.children[2].name()).toBe('rect1');
    expect(layer.children[3].name()).toBe('rect3');
  });

  it('changing order should not stop dragging', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>{this.props.kids}</Layer>
          </Stage>
        );
      }
    }

    let kids = [
      <Rect key="1" name="rect1" />,
      <Rect key="2" name="rect2" />,
      <Rect key="3" name="rect3" />,
    ];
    const { stage, rerender } = await render(<App kids={kids} />);
    const layer = stage.children[0];

    const rect1 = layer.findOne('.rect1');

    await React.act(() => {
      layer.getStage().simulateMouseDown({ x: 5, y: 5 });
    });
    await React.act(() => {
      rect1.startDrag();
    });
    await React.act(() => {
      // move mouse
      layer.getStage().simulateMouseMove({ x: 10, y: 10 });
    });

    expect(rect1.isDragging()).toBe(true);

    kids = [
      <Rect key="3" name="rect3" />,
      <Rect key="1" name="rect1" />,
      <Rect key="2" name="rect2" />,
    ];
    await rerender(<App kids={kids} />);

    expect(rect1.isDragging()).toBe(true);
    rect1.stopDrag();
  });

  it('check events subscribe', async function () {
    const App = () => {
      const [fill, setColor] = React.useState('black');

      return (
        <Stage width={300} height={300}>
          <Layer>
            <Rect
              fill={fill}
              width={100}
              height={100}
              draggable
              onMouseDown={() => {
                setColor('red');
              }}
            />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    expect(stage.findOne('Rect').fill()).toBe('black');

    await React.act(() => {
      stage.simulateMouseDown({ x: 50, y: 50 });
    });
    await React.act(() => {
      stage.simulateMouseMove({ x: 55, y: 55 });
    });
    window.stage = stage;
    expect(stage.findOne('Rect').isDragging()).toBe(true);
    expect(stage.findOne('Rect').fill()).toBe('red');
  });
});

describe('Test context API', async function () {
  let instance;

  const { Consumer, Provider } = React.createContext({
    width: 100,
    height: 100,
  });
  class App extends React.Component {
    render() {
      return (
        <Provider value={{ width: 200, height: 100 }}>
          <Consumer>
            {({ width, height }) => (
              <Stage width={width} height={height}>
                <Layer />
              </Stage>
            )}
          </Consumer>
        </Provider>
      );
    }
  }

  it('test correct set', async function () {
    const { stage } = await render(<App />);
    expect(stage.width()).toBe(200);
    expect(stage.height()).toBe(100);
  });
});

// wait for react team response
describe('Test nested context API', async function () {
  const Context = React.createContext({
    color: 'red',
  });

  class Tools extends React.Component {
    static contextType = Context;
    render() {
      return (
        <Layer>
          <Rect width={50} height={50} fill={this.context.color} />
        </Layer>
      );
    }
  }

  class Canvas extends React.Component {
    static contextType = Context;
    render() {
      return (
        <Stage width={300} height={200}>
          <Tools />
        </Stage>
      );
    }
  }

  class App extends React.Component {
    render() {
      return (
        <Context.Provider value={{ color: 'black' }}>
          <Canvas />
        </Context.Provider>
      );
    }
  }

  it('test correct set', async function () {
    const { stage } = await render(<App />);
    expect(stage.findOne('Rect').fill()).toBe('black');
  });
});

// wait for react team response
describe('try lazy and suspense', async function () {
  it('can use lazy and suspense', async function () {
    let resolvePromise;
    const LazyRect = React.lazy(() => {
      return new Promise((resolve) => {
        resolvePromise = resolve;
      });
    });

    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>
              <React.Suspense fallback={<Text text="fallback" />}>
                <LazyRect />
              </React.Suspense>
            </Layer>
          </Stage>
        );
      }
    }
    const { stage } = await render(<App />);
    expect(stage.find('Text').length).toBe(1);
    expect(stage.find('Shape').length).toBe(1);

    await React.act(() => {
      resolvePromise({
        default: () => <Rect />,
      });
    });
    expect(stage.find('Text').length).toBe(0);
    expect(stage.find('Rect').length).toBe(1);
    expect(stage.find('Shape').length).toBe(1);
  });

  it('suspends whole stage', async () => {
    let promiseResolve;
    const LazyDiv = React.lazy(() => {
      return new Promise((resolve) => {
        promiseResolve = resolve;
      });
    });

    const Canvas = () => {
      return (
        <Stage width={300} height={300} draggable>
          <Layer>
            <Rect width={100} height={100} fill="red" />
          </Layer>
        </Stage>
      );
    };
    class App extends React.Component {
      render() {
        return (
          <div>
            <React.Suspense fallback={<div />}>
              {this.props.showLazy && <LazyDiv />}
              <Canvas />
            </React.Suspense>
          </div>
        );
      }
    }

    // render without lazy first
    const { stage, rerender } = await render(<App showLazy={false} />);
    expect(stage.draggable()).toBe(true);
    // then show lazy
    await rerender(<App showLazy={true} />);
    // wait till lazy component is loaded
    await React.act(() => {
      promiseResolve({ default: () => <div /> });
    });
    let lastStage = Konva.stages[Konva.stages.length - 1];
    // make sure all properties are set correctly
    expect(lastStage).to.not.equal(stage);
    expect(lastStage.draggable()).toBe(true);
  });
});

describe('Fragments', async function () {
  const Fragmented = () => (
    <React.Fragment>
      <Rect />
      <Rect />
    </React.Fragment>
  );

  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          <Layer>
            <Fragmented />
          </Layer>
        </Stage>
      );
    }
  }

  it('can use lazy and suspense', async function () {
    const { stage } = await render(<App />);
    expect(stage.find('Rect').length).toBe(2);
  });
});

describe('warnings', async function () {
  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          <Layer>
            <Rect draggable x={0} y={0} />
          </Layer>
        </Stage>
      );
    }
  }

  it('check draggable warning', async function () {
    const { stage } = await render(<App />);
  });
});

describe('Hooks', async function () {
  it('check setState hook', async function () {
    const App = () => {
      const [fill, setColor] = React.useState('black');

      return (
        <Stage width={300} height={300}>
          <Layer>
            <Rect
              fill={fill}
              width={100}
              height={100}
              onMouseDown={() => {
                setColor('red');
              }}
            />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    expect(stage.findOne('Rect').fill()).toBe('black');
    await React.act(() => {
      stage.simulateMouseDown({ x: 50, y: 50 });
    });
    expect(stage.findOne('Rect').fill()).toBe('red');
  });

  it('check useEffect hook', async function () {
    let callCount = 0;
    const App = () => {
      React.useEffect(() => {
        callCount += 1;
      });

      return (
        <Stage width={300} height={300}>
          <Layer />
        </Stage>
      );
    };
    const { stage, rerender } = await render(<App />);

    expect(callCount).toBe(1);

    rerender(<App randomProp={1} />);

    expect(callCount).toBe(2);
  });

  it('check useEffect hook 2', async function () {
    let callCount = 0;
    const MyRect = ({ name }) => {
      React.useEffect(() => {
        callCount += 1;
      });
      return <Rect name={name} />;
    };
    const App = () => {
      const [name, setName] = React.useState('');

      React.useEffect(() => {
        setName('rect name');
      }, []);

      return (
        <Stage width={300} height={300}>
          <Layer>
            <MyRect name={name} />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    const rect = stage.findOne('Rect');

    expect(rect.name()).toBe('rect name');
    expect(callCount).toBe(2);
  });

  it('check useImage hook', async function () {
    const url = 'https://konvajs.org//img/icon.png?token' + Math.random();

    const App = () => {
      const [image, status] = useImage(url);

      return (
        <Stage width={300} height={300}>
          <Layer>
            <Image image={image} />
            <Text text={status} />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    // not image while loading
    expect(stage.findOne('Image').image()).toBe(undefined);
    expect(stage.findOne('Text').text()).toBe('loading');

    const img = new window.Image();
    img.src = url;
    await new Promise((resolve) => {
      img.onload = () => {
        setTimeout(() => resolve(null), 50);
      };
    });
    expect(stage.findOne('Image').image() instanceof window.Image).toBe(true);
    expect(stage.findOne('Text').text()).toBe('loaded');
  });

  it('unsubscribe on unmount', async function () {
    const url = 'https://konvajs.org//img/icon.png';

    const App = () => {
      const [image, status] = useImage(url);

      return (
        <Stage width={300} height={300}>
          <Layer>
            <Image image={image} />
            <Text text={status} />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    // not image while loading
    expect(stage.findOne('Image').image()).toBe(undefined);
    expect(stage.findOne('Text').text()).toBe('loading');

    const img = new window.Image();
    img.src = url;
    await new Promise((resolve) => {
      img.onload = () => {
        setTimeout(() => resolve(null), 50);
      };
    });
  });
});

describe('external', () => {
  it('make sure node has _applyProps for react-spring integration', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>
              <Rect fill="red" />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    expect(typeof stage.findOne('Rect')._applyProps).toBe('function');
  });
});

describe('React StrictMode', () => {
  it('make sure effect is called AFTER we set refs of konva nodes', async function () {
    const App = () => {
      const stageRef = React.useRef<Konva.Stage>(null);
      const [count, setCount] = React.useState(0);
      const shapeRef = React.useRef<Konva.Rect>(null);
      const trRef = React.useRef<Konva.Transformer>(null);

      const isMounted = React.useRef(false);

      React.useEffect(() => {
        setCount(1);
        setTimeout(() => {
          setCount(2);
          setTimeout(() => {
            setCount(3);
          }, 10);
        }, 10);
      }, []);

      React.useEffect(() => {
        // we need to attach transformer manually
        trRef.current?.nodes([shapeRef.current]);
        trRef.current?.getLayer().batchDraw();
      }, [count]);

      return (
        <>
          {count !== 2 && (
            <Stage width={300} height={300} ref={stageRef}>
              <Layer>
                <Rect fill="red" ref={shapeRef} />
                <Transformer ref={trRef} />
              </Layer>
            </Stage>
          )}
        </>
      );
    };

    const { stage } = await render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
    await new Promise((resolve) => setTimeout(resolve, 100));
    const lastStage = Konva.stages[Konva.stages.length - 1];
    const lastTransformer = lastStage.findOne('Transformer');
    expect(lastTransformer.nodes().length).toBe(1);
    expect(lastTransformer.nodes()[0].fill()).toBe('red');
  });

  it('event listeners in strict mode', async function () {
    const App = () => {
      return (
        <Stage width={300} height={300} onMouseDown={() => {}}>
          <Layer></Layer>
        </Stage>
      );
    };

    const { stage } = await render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
    expect(stage.eventListeners.mousedown.length).toBe(1);
  });
});

// reference for the test: https://github.com/konvajs/react-konva/issues/748
// TODO: can we fix that?
describe.skip('update order', () => {
  const store = {
    listeners: [],
    state: {
      name: 'test',
    },
    getState() {
      return store.state;
    },
    subscribe(cb) {
      this.listeners.push(cb);
    },
    async dispatch() {
      await Promise.resolve();

      this.state = {
        name: 'test2',
      };
      this.listeners.forEach((cb) => cb());
    },
  };

  function useSelector(selector) {
    return React.useSyncExternalStore(
      (callback) => store.subscribe(callback),
      () => store.getState(),
      undefined,
      selector
    );
  }

  const App = () => {
    return (
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <ViewLayer />
      </Stage>
    );
  };

  const renderCallStack = [];
  function ViewLayer() {
    renderCallStack.push('ViewLayer');

    useSelector((state) => state.name);

    return (
      <Layer>
        <ViewText />
      </Layer>
    );
  }

  function ViewText() {
    renderCallStack.push('ViewText');

    const name = useSelector((state) => state.name);

    return <Text text={name} fontSize={15} />;
  }

  it('update order', async function () {
    const { stage } = await render(<App />);
    await store.dispatch();
    await new Promise((resolve) => setTimeout(resolve, 100));
    expect(renderCallStack).toEqual([
      'ViewLayer',
      'ViewText',
      'ViewLayer',
      'ViewText',
    ]);
  });
});
</file>

<file path="test/react-konva.test.tsx">
// @ts-nocheck
import React from 'react';
import { createRoot } from 'react-dom/client';
import { flushSync } from 'react-dom';
import { vi, expect } from 'vitest';
import Konva from 'konva';
import useImage from 'use-image';

import './mocking';
import {
  Stage,
  Rect,
  Layer,
  useStrictMode,
  Group,
  Text,
  Image,
  Circle,
  Transformer,
  useContextBridge,
} from '../src/ReactKonva';

window.IS_REACT_ACT_ENVIRONMENT = true;

// Suppress console warnings about act() for custom reconciler updates
const originalConsoleError = console.error;
const originalConsoleWarn = console.warn;

console.error = (...args) => {
  const message = args[0];
  if (
    typeof message === 'string' &&
    (message.includes('was not wrapped in act') ||
      message.includes('suspended resource finished loading'))
  ) {
    // Suppress act warnings for custom reconciler
    return;
  }
  originalConsoleError.apply(console, args);
};

const render = async (component) => {
  const node = document.createElement('div');
  document.body.appendChild(node);
  const root = createRoot(node);

  await React.act(() => {
    root.render(component);
  });

  return {
    stage: Konva.stages[Konva.stages.length - 1],
    rerender: async (component) => {
      await React.act(() => {
        root.render(component);
      });
    },
  };
};

describe('initial mounting and refs', () => {
  it('trigger effect hooks', async () => {
    const func = vi.fn();
    const App = () => {
      React.useEffect(() => {
        func();
      });
      const ref = React.useRef<Konva.Stage>(null);
      return <Stage ref={ref} />;
    };
    await render(React.createElement(App));
    expect(func).toHaveBeenCalledOnce();
  });

  it('can set reference to stage', async () => {
    const App = () => {
      React.useEffect(() => {
        expect(ref.current instanceof Konva.Stage).toBe(true);
      });
      const ref = React.useRef<Konva.Stage>(null);
      return <Stage ref={ref} />;
    };
    await render(React.createElement(App));
  });

  it('check all refs', async () => {
    let stageRef;
    let layerRef;
    let rectRef;

    const App = () => {
      stageRef = React.useRef<Konva.Stage>(null);
      layerRef = React.useRef<Konva.Layer>(null);
      rectRef = React.useRef<Konva.Rect>(null);

      React.useEffect(() => {
        expect(stageRef.current instanceof Konva.Stage).toBe(true);
      });

      return (
        <Stage ref={stageRef}>
          <Layer ref={layerRef}>
            <Rect ref={rectRef} />
          </Layer>
        </Stage>
      );
    };
    await render(React.createElement(App));
    expect(stageRef.current instanceof Konva.Stage).toBe(true);
    expect(layerRef.current instanceof Konva.Layer).toBe(true);
    expect(rectRef.current instanceof Konva.Rect).toBe(true);
    expect(rectRef.current.getAttr('ref')).toBeUndefined();
  });

  it('no fail on no ref', async () => {
    await render(<Stage />);
  });

  it('works with functional reference', async () => {
    const App = () => {
      return (
        <Stage
          ref={(node) => {
            if (node) {
              expect(node instanceof Konva.Stage).toBe(true);
            }
          }}
        />
      );
    };
    await render(React.createElement(App));
  });

  it('check initial props', async () => {
    const App = ({ width, height }) => {
      const ref = React.useRef<Konva.Stage>(null);
      React.useEffect(() => {
        expect(ref.current?.width()).toBe(100);
      });
      return <Stage ref={ref} width={width} height={height} />;
    };
    await render(<App width={100} height={100} />);
  });

  // this test doesn't work...
  // for unknow reason ref setting is triggered AFTER effect of App component
  // looks like it is because of cross-reconcilier case
  it('forward ref on Konva components', async () => {
    const MyRect = React.forwardRef((props, ref) => <Rect ref={ref} />);

    const App = () => {
      const ref = React.useRef<Konva.Rect>(null);
      const stageRef = React.useRef<Konva.Stage>(null);
      React.useEffect(() => {
        expect((ref.current as any) instanceof Konva.Rect).toBe(true);
      });
      return (
        <Stage ref={stageRef} name="hello">
          <Layer>
            <MyRect ref={ref} />
            <Rect />
          </Layer>
        </Stage>
      );
    };
    await render(<App />);
  });

  it.skip('sync rendder', async () => {
    const Inner = () => {
      const [position, setPosition] = React.useState({
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
      });

      return (
        <Layer>
          <Circle
            x={position.x}
            y={position.y}
            radius={70}
            fill="red"
            onDragEnd={(e) => {
              setPosition({
                x: e.target.x(),
                y: e.target.y(),
              });
            }}
          />
          <Circle
            x={position.x}
            y={position.y}
            radius={70}
            fill="yellow"
            draggable
            onDragMove={(e) => {
              setPosition({
                x: e.target.x(),
                y: e.target.y(),
              });
            }}
          />
        </Layer>
      );
    };

    const App = () => {
      return (
        <Stage width={window.innerWidth} height={window.innerHeight}>
          <Inner />
        </Stage>
      );
    };

    await render(<App />);
  });

  it('forward ref deep in Konva tree', async () => {
    let effectRun = false;
    const MyRect = React.forwardRef((props, ref) => <Rect ref={ref} />);

    const MyLayer = () => {
      const ref = React.useRef();
      React.useEffect(() => {
        effectRun = true;
        expect((ref.current as any) instanceof Konva.Rect).toBe(true);
      });
      return (
        <Layer>
          <MyRect ref={ref} />
        </Layer>
      );
    };

    const App = () => {
      return (
        <Stage>
          <MyLayer />
        </Stage>
      );
    };
    await render(<App />);
    expect(effectRun).toBe(true);
  });
});

describe('Test stage component', async function () {
  it('can attach stage events', async function () {
    let eventCount = 0;
    const handleEvent = () => {
      eventCount += 1;
    };

    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300} onMouseDown={handleEvent}>
            <Layer>
              <Rect width={100} height={100} />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    await React.act(() => {
      stage.simulateMouseDown({ x: 50, y: 50 });
    });
    expect(eventCount).toBe(1);
  });

  it('unmount stage should destroy it from Konva', async () => {
    class App extends React.Component {
      render() {
        if (this.props.skipStage) {
          return <div />;
        }
        return (
          <Stage width={300} height={300}>
            <Layer />
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    const stagesNumber = Konva.stages.length;
    await rerender(<App skipStage />);
    expect(Konva.stages.length).toBe(stagesNumber - 1);
  });

  it('test null event', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300} onMouseDown={null}>
            <Layer>
              <Rect width={100} height={100} />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    await React.act(() => {
      stage.simulateMouseDown({ x: 50, y: 50 });
    });
  });

  it('check div props', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300} id="hello">
            <Layer>
              <Rect width={100} height={100} />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    expect(stage.id()).toBe('hello');
    expect(stage.container().id).toBe('hello');
  });
});

describe('Test props setting', async function () {
  let stage, rerender;
  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          <Layer>
            <Rect {...this.props.rectProps} />
          </Layer>
        </Stage>
      );
    }
  }

  const setProps = async (props) => {
    await rerender(<App {...props} />);
  };

  beforeEach(async () => {
    const res = await render(<App />);
    stage = res.stage;
    rerender = res.rerender;
  });

  it('can update component props', async () => {
    const rect = stage.findOne('Rect');
    // set new props
    const props1 = {
      width: 100,
      height: 100,
    };

    await setProps({ rectProps: props1 });
    expect(rect.width()).toBe(100);

    const props2 = {
      width: 200,
      height: 100,
    };
    await setProps({ rectProps: props2 });
    expect(rect.width()).toBe(200);
  });
  it('can update component events', async () => {
    const rect = stage.findOne('Rect');
    // set new props
    const props1 = {
      onClick: () => {},
    };
    await setProps({ rectProps: props1 });
    expect(rect.eventListeners.click.length).toBe(1);
    expect(rect.eventListeners.click[0].handler).toBe(props1.onClick);

    const props2 = {
      onClick: () => {},
    };
    await setProps({ rectProps: props2 });
    expect(rect.eventListeners.click.length).toBe(1);
    expect(rect.eventListeners.click[0].handler).toBe(props2.onClick);
  });

  it('updating props should call layer redraw', async () => {
    const layer = stage.findOne('Layer');
    vi.spyOn(layer, 'batchDraw');
    await setProps({
      rectProps: {
        fill: 'green',
      },
    });
    await setProps({
      rectProps: {
        fill: 'red',
      },
    });
    expect(layer.batchDraw).toHaveBeenCalledTimes(2);
  });

  it('unset props', async () => {
    const rect = stage.findOne('Rect');
    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.fill()).toBe('red');

    await setProps({ rectProps: {} });
    expect(!!rect.fill()).toBe(false);
    expect(rect.x()).toBe(0);
  });

  it('do not overwrite properties if that changed manually', async () => {
    const rect = stage.findOne('Rect');
    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(10);

    // change position manually
    rect.x(20);

    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(20);
  });

  it('overwrite properties if that changed manually in strict-mode', async () => {
    useStrictMode(true);
    const rect = stage.findOne('Rect');
    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(10);

    // change position manually
    rect.x(20);

    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(10);
    useStrictMode(false);
  });

  it('overwrite properties if that passed _useStrictMode', async () => {
    const rect = stage.findOne('Rect');
    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
      },
    });
    expect(rect.x()).toBe(10);

    // change position manually
    rect.x(20);

    await setProps({
      rectProps: {
        fill: 'red',
        x: 10,
        _useStrictMode: true,
      },
    });
    expect(rect.x()).toBe(10);
  });
});

describe('test lifecycle methods', () => {
  class SubComponent extends React.Component<any> {
    // comment, as it will be removed
    // componentWillMount() {
    //   this.props.componentWillMount();
    // }
    componentDidMount() {
      this.props.componentDidMount();
    }
    // componentWillReceiveProps(newProps) {
    //   this.props.componentWillReceiveProps(newProps);
    // }
    shouldComponentUpdate() {
      this.props.shouldComponentUpdate(...arguments);
      return true;
    }
    // componentWillUpdate() {
    //   this.props.componentWillUpdate();
    // }
    componentDidUpdate() {
      this.props.componentDidUpdate();
    }
    componentWillUnmount() {
      this.props.componentWillUnmount();
    }
    render() {
      return <Rect />;
    }
  }
  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          <Layer>
            {this.props.dontDrawChildren ? null : (
              <SubComponent {...this.props} />
            )}
          </Layer>
        </Stage>
      );
    }
  }

  const setProps = async (rerender, props) => {
    await rerender(<App {...props} />);
  };

  // beforeEach(async () => {
  //   const res = await render(<App />);
  //   stage = res.stage;
  //   rerender = res.rerender;
  // });

  it('test mount', async () => {
    const props = {
      // componentWillMount: vi.fn(),
      componentDidMount: vi.fn(),
    };
    await render(<App {...props} />);

    // expect(props.componentWillMount).toHaveBeenCalled();
    expect(props.componentDidMount).toHaveBeenCalled();
  });

  it('test update', async () => {
    const props = {
      // componentWillMount: vi.fn(),
      componentDidMount: vi.fn(),
      // componentWillReceiveProps: vi.fn(),
      shouldComponentUpdate: vi.fn(),
      // componentWillUpdate: vi.fn(),
      componentDidUpdate: vi.fn(),
      componentWillUnmount: vi.fn(),
    };
    const { rerender } = await render(<App {...props} />);
    await setProps(rerender, props);

    // expect(props.componentWillMount).toHaveBeenCalled();
    expect(props.shouldComponentUpdate).toHaveBeenCalled();
    // expect(props.componentWillUpdate).toHaveBeenCalled();
    expect(props.componentDidUpdate).toHaveBeenCalled();
  });

  it('test remove', async () => {
    const props = {
      // componentWillMount: vi.fn(),
      componentDidMount: vi.fn(),
      // componentWillReceiveProps: vi.fn(),
      shouldComponentUpdate: vi.fn(),
      // componentWillUpdate: vi.fn(),
      componentDidUpdate: vi.fn(),
      componentWillUnmount: vi.fn(),
    };
    const { rerender, stage } = await render(<App {...props} />);
    expect(stage.findOne('Rect')).not.toEqual(undefined);

    props.dontDrawChildren = props;
    await setProps(rerender, props);
    expect(stage.findOne('Rect')).toEqual(undefined);
    // This line don't work... why????
    expect(props.componentWillUnmount).toHaveBeenCalled();
  });
});

describe('Test Events', async function () {
  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          {this.props.shouldDrawLayer && <Layer onClick={this.props.onClick} />}
        </Stage>
      );
    }
  }

  it('should remove events on unmount', async function () {
    const onClickRect = vi.fn();
    const onClickExternal = vi.fn();

    const { stage, rerender } = await render(
      <App onClick={onClickRect} shouldDrawLayer />
    );

    const setProps = async (props) => {
      await rerender(<App {...props} />);
    };

    const layer = stage.findOne('Layer');
    layer.on('click', onClickExternal);

    expect(onClickRect).toHaveBeenCalledTimes(0);
    expect(onClickExternal).toHaveBeenCalledTimes(0);

    layer._fire('click', {});
    expect(onClickRect).toHaveBeenCalledTimes(1);
    expect(onClickExternal).toHaveBeenCalledTimes(1);

    // remove layer
    await setProps({ shouldDrawLayer: false });

    expect(layer.getParent()).toEqual(null);

    layer._fire('click', {});

    expect(onClickRect).toHaveBeenCalledTimes(1);
    expect(onClickExternal).toHaveBeenCalledTimes(2);
  });
});

describe('Bad structure', () => {
  it('No dom inside Konva', async function () {
    const originalError = console.error;
    const error = vi.fn();
    console.error = error;
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>
              <div />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    // Error may be called multiple times due to flushSync in Stage's useLayoutEffect
    expect(error).toHaveBeenCalled();
    expect(error.mock.calls[0][0]).toContain(
      'Konva has no node with the type div'
    );
    console.error = originalError;
    // check check that this test is not failed
  });
});

describe('Check id saving', () => {
  it('Konva can loose ids?', async function () {
    class App extends React.Component {
      render() {
        const kids = [
          <Rect key="1" id="rect1" fill="red" />,
          <Rect key="2" id="rect2" fill="green" />,
        ];
        return (
          <Stage width={300} height={300}>
            <Layer>
              {this.props.drawAsGroup ? <Group>{kids}</Group> : kids}
            </Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    expect(stage.findOne('#rect1').fill()).toBe('red');
    expect(stage.findOne('#rect2').fill()).toBe('green');

    await rerender(<App drawAsGroup />);

    expect(stage.findOne('#rect1').fill()).toBe('red');
    expect(stage.findOne('#rect2').fill()).toBe('green');
  });
});

describe('Test drawing calls', () => {
  afterEach(() => {
    Konva.Layer.prototype.batchDraw.restore &&
      Konva.Layer.prototype.batchDraw.restore();
  });

  it('Draw layer on mount', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>
              <Rect fill="red" />
            </Layer>
          </Stage>
        );
      }
    }

    expect((Konva.Layer.prototype.batchDraw as any).mock).toBeUndefined();
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    const { stage } = await render(<App />);

    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalled();
    vi.restoreAllMocks();
  });

  it('Draw layer on node add', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>{this.props.showRect && <Rect fill="red" />}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(0);
    await rerender(<App showRect />);

    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(1);
    vi.restoreAllMocks();
  });

  it('Draw layer on node remove', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>{!this.props.hideRect && <Rect fill="red" />}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(0);
    await rerender(<App hideRect />);

    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(1);
    vi.restoreAllMocks();
  });
});

describe('test reconciler', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('add before', async function () {
    class App extends React.Component {
      render() {
        const kids = this.props.drawMany
          ? [<Rect key="1" name="rect1" />, <Rect key="2" name="rect2" />]
          : [<Rect key="2" name="rect2" />];
        return (
          <Stage width={300} height={300}>
            <Layer>{kids}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    await rerender(<App drawMany />);

    const layer = stage.children[0];
    expect(layer.children[0].name()).toEqual('rect1');
    expect(layer.children[1].name()).toEqual('rect2');
    expect(
      (Konva.Layer.prototype.batchDraw as any).mock.calls.length >= 1
    ).toBe(true);
  });

  it('add before (mane)', async function () {
    class App extends React.Component {
      render() {
        const kids = this.props.drawMany
          ? [
              <Rect key="1" name="rect1" />,
              <Rect key="2" name="rect2" />,
              <Rect key="3" name="rect3" />,
            ]
          : [<Rect key="1" name="rect1" />, <Rect key="3" name="rect3" />];
        return (
          <Stage width={300} height={300}>
            <Layer>{kids}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    await rerender(<App drawMany />);

    const layer = stage.children[0];
    expect(layer.children[0].name()).toBe('rect1');
    expect(layer.children[1].name()).toBe('rect2');
    expect(layer.children[2].name()).toBe('rect3');
  });

  it('add after', async function () {
    class App extends React.Component {
      render() {
        const kids = this.props.drawMany
          ? [<Rect key="1" name="rect1" />, <Rect key="2" name="rect2" />]
          : [<Rect key="1" name="rect1" />];
        return (
          <Stage width={300} height={300}>
            <Layer>{kids}</Layer>
          </Stage>
        );
      }
    }

    const { stage, rerender } = await render(<App />);
    vi.spyOn(Konva.Layer.prototype, 'batchDraw');
    await rerender(<App drawMany />);

    const layer = stage.children[0];
    expect(layer.children[0].name()).toEqual('rect1');
    expect(layer.children[1].name()).toEqual('rect2');
    expect(Konva.Layer.prototype.batchDraw).toHaveBeenCalledTimes(1);
  });

  it('change order', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>{this.props.kids}</Layer>
          </Stage>
        );
      }
    }

    let kids = [
      <Rect key="1" name="rect1" />,
      <Rect key="2" name="rect2" />,
      <Rect key="3" name="rect3" />,
    ];
    const { stage, rerender } = await render(<App kids={kids} />);
    const layer = stage.children[0];

    expect(layer.children[0].name()).toBe('rect1');
    expect(layer.children[1].name()).toBe('rect2');
    expect(layer.children[2].name()).toBe('rect3');

    // last to first
    kids = [
      <Rect key="3" name="rect3" />,
      <Rect key="1" name="rect1" />,
      <Rect key="2" name="rect2" />,
    ];
    await rerender(<App kids={kids} />);
    expect(layer.children[0].name()).toBe('rect3');
    expect(layer.children[1].name()).toBe('rect1');
    expect(layer.children[2].name()).toBe('rect2');

    // second to first
    kids = [
      <Rect key="1" name="rect1" />,
      <Rect key="3" name="rect3" />,
      <Rect key="2" name="rect2" />,
    ];

    await rerender(<App kids={kids} />);

    expect(layer.children[0].name()).toBe('rect1');
    expect(layer.children[1].name()).toBe('rect3');
    expect(layer.children[2].name()).toBe('rect2');

    kids = [
      <Rect key="2" name="rect2" />,
      <Rect key="1" name="rect1" />,
      <Rect key="3" name="rect3" />,
    ];
    await rerender(<App kids={kids} />);

    expect(layer.children[0].name()).toBe('rect2');
    expect(layer.children[1].name()).toBe('rect1');
    expect(layer.children[2].name()).toBe('rect3');

    kids = [
      <Rect key="4" name="rect4" />,
      <Rect key="2" name="rect2" />,
      <Rect key="1" name="rect1" />,
      <Rect key="3" name="rect3" />,
    ];
    await rerender(<App kids={kids} />);

    expect(layer.children[0].name()).toBe('rect4');
    expect(layer.children[1].name()).toBe('rect2');
    expect(layer.children[2].name()).toBe('rect1');
    expect(layer.children[3].name()).toBe('rect3');
  });

  it('changing order should not stop dragging', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>{this.props.kids}</Layer>
          </Stage>
        );
      }
    }

    let kids = [
      <Rect key="1" name="rect1" />,
      <Rect key="2" name="rect2" />,
      <Rect key="3" name="rect3" />,
    ];
    const { stage, rerender } = await render(<App kids={kids} />);
    const layer = stage.children[0];

    const rect1 = layer.findOne('.rect1');

    await React.act(() => {
      layer.getStage().simulateMouseDown({ x: 5, y: 5 });
    });
    await React.act(() => {
      rect1.startDrag();
    });
    await React.act(() => {
      // move mouse
      layer.getStage().simulateMouseMove({ x: 10, y: 10 });
    });

    expect(rect1.isDragging()).toBe(true);

    kids = [
      <Rect key="3" name="rect3" />,
      <Rect key="1" name="rect1" />,
      <Rect key="2" name="rect2" />,
    ];
    await rerender(<App kids={kids} />);

    expect(rect1.isDragging()).toBe(true);
    rect1.stopDrag();
  });

  it('check events subscribe', async function () {
    const App = () => {
      const [fill, setColor] = React.useState('black');

      return (
        <Stage width={300} height={300}>
          <Layer>
            <Rect
              fill={fill}
              width={100}
              height={100}
              draggable
              onMouseDown={() => {
                setColor('red');
              }}
            />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    expect(stage.findOne('Rect').fill()).toBe('black');

    await React.act(() => {
      stage.simulateMouseDown({ x: 50, y: 50 });
    });
    await React.act(() => {
      stage.simulateMouseMove({ x: 55, y: 55 });
    });
    window.stage = stage;
    expect(stage.findOne('Rect').isDragging()).toBe(true);
    expect(stage.findOne('Rect').fill()).toBe('red');
  });
});

describe('Test context API', async function () {
  let instance;

  const { Consumer, Provider } = React.createContext({
    width: 100,
    height: 100,
  });
  class App extends React.Component {
    render() {
      return (
        <Provider value={{ width: 200, height: 100 }}>
          <Consumer>
            {({ width, height }) => (
              <Stage width={width} height={height}>
                <Layer />
              </Stage>
            )}
          </Consumer>
        </Provider>
      );
    }
  }

  it('test correct set', async function () {
    const { stage } = await render(<App />);
    expect(stage.width()).toBe(200);
    expect(stage.height()).toBe(100);
  });
});

// wait for react team response
describe('Test nested context API', async function () {
  const Context = React.createContext({
    color: 'red',
  });

  class Tools extends React.Component {
    static contextType = Context;
    render() {
      return (
        <Layer>
          <Rect width={50} height={50} fill={this.context.color} />
        </Layer>
      );
    }
  }

  class Canvas extends React.Component {
    static contextType = Context;
    render() {
      return (
        <Stage width={300} height={200}>
          <Tools />
        </Stage>
      );
    }
  }

  class App extends React.Component {
    render() {
      return (
        <Context.Provider value={{ color: 'black' }}>
          <Canvas />
        </Context.Provider>
      );
    }
  }

  it('test correct set', async function () {
    const { stage } = await render(<App />);
    expect(stage.findOne('Rect').fill()).toBe('black');
  });
});

// wait for react team response
describe('try lazy and suspense', async function () {
  it('can use lazy and suspense', async function () {
    let resolvePromise;
    const LazyRect = React.lazy(() => {
      return new Promise((resolve) => {
        resolvePromise = resolve;
      });
    });

    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>
              <React.Suspense fallback={<Text text="fallback" />}>
                <LazyRect />
              </React.Suspense>
            </Layer>
          </Stage>
        );
      }
    }
    const { stage } = await render(<App />);
    expect(stage.find('Text').length).toBe(1);
    expect(stage.find('Shape').length).toBe(1);

    await React.act(() => {
      resolvePromise({
        default: () => <Rect />,
      });
    });
    expect(stage.find('Text').length).toBe(0);
    expect(stage.find('Rect').length).toBe(1);
    expect(stage.find('Shape').length).toBe(1);
  });

  it('suspends whole stage', async () => {
    let promiseResolve;
    const LazyDiv = React.lazy(() => {
      return new Promise((resolve) => {
        promiseResolve = resolve;
      });
    });

    const Canvas = () => {
      return (
        <Stage width={300} height={300} draggable>
          <Layer>
            <Rect width={100} height={100} fill="red" />
          </Layer>
        </Stage>
      );
    };
    class App extends React.Component {
      render() {
        return (
          <div>
            <React.Suspense fallback={<div />}>
              {this.props.showLazy && <LazyDiv />}
              <Canvas />
            </React.Suspense>
          </div>
        );
      }
    }

    // render without lazy first
    const { stage, rerender } = await render(<App showLazy={false} />);
    expect(stage.draggable()).toBe(true);
    // then show lazy
    await rerender(<App showLazy={true} />);
    // wait till lazy component is loaded
    await React.act(() => {
      promiseResolve({ default: () => <div /> });
    });
    let lastStage = Konva.stages[Konva.stages.length - 1];
    // make sure all properties are set correctly
    expect(lastStage).to.not.equal(stage);
    expect(lastStage.draggable()).toBe(true);
  });
});

describe('Fragments', async function () {
  const Fragmented = () => (
    <React.Fragment>
      <Rect />
      <Rect />
    </React.Fragment>
  );

  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          <Layer>
            <Fragmented />
          </Layer>
        </Stage>
      );
    }
  }

  it('can use lazy and suspense', async function () {
    const { stage } = await render(<App />);
    expect(stage.find('Rect').length).toBe(2);
  });
});

describe('warnings', async function () {
  class App extends React.Component {
    render() {
      return (
        <Stage width={300} height={300}>
          <Layer>
            <Rect draggable x={0} y={0} />
          </Layer>
        </Stage>
      );
    }
  }

  it('check draggable warning', async function () {
    const { stage } = await render(<App />);
  });
});

describe('Hooks', async function () {
  it('check setState hook', async function () {
    const App = () => {
      const [fill, setColor] = React.useState('black');

      return (
        <Stage width={300} height={300}>
          <Layer>
            <Rect
              fill={fill}
              width={100}
              height={100}
              onMouseDown={() => {
                setColor('red');
              }}
            />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    expect(stage.findOne('Rect').fill()).toBe('black');
    await React.act(() => {
      stage.simulateMouseDown({ x: 50, y: 50 });
    });
    expect(stage.findOne('Rect').fill()).toBe('red');
  });

  it('check useEffect hook', async function () {
    let callCount = 0;
    const App = () => {
      React.useEffect(() => {
        callCount += 1;
      });

      return (
        <Stage width={300} height={300}>
          <Layer />
        </Stage>
      );
    };
    const { stage, rerender } = await render(<App />);

    expect(callCount).toBe(1);

    rerender(<App randomProp={1} />);

    expect(callCount).toBe(2);
  });

  it('check useEffect hook 2', async function () {
    let callCount = 0;
    const MyRect = ({ name }) => {
      React.useEffect(() => {
        callCount += 1;
      });
      return <Rect name={name} />;
    };
    const App = () => {
      const [name, setName] = React.useState('');

      React.useEffect(() => {
        setName('rect name');
      }, []);

      return (
        <Stage width={300} height={300}>
          <Layer>
            <MyRect name={name} />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    const rect = stage.findOne('Rect');

    expect(rect.name()).toBe('rect name');
    expect(callCount).toBe(2);
  });

  it('check useImage hook', async function () {
    const url = 'https://konvajs.org//img/icon.png?token' + Math.random();

    const App = () => {
      const [image, status] = useImage(url);

      return (
        <Stage width={300} height={300}>
          <Layer>
            <Image image={image} />
            <Text text={status} />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    // not image while loading
    expect(stage.findOne('Image').image()).toBe(undefined);
    expect(stage.findOne('Text').text()).toBe('loading');

    const img = new window.Image();
    img.src = url;
    await new Promise((resolve) => {
      img.onload = () => {
        setTimeout(() => resolve(null), 50);
      };
    });
    expect(stage.findOne('Image').image() instanceof window.Image).toBe(true);
    expect(stage.findOne('Text').text()).toBe('loaded');
  });

  it('unsubscribe on unmount', async function () {
    const url = 'https://konvajs.org//img/icon.png';

    const App = () => {
      const [image, status] = useImage(url);

      return (
        <Stage width={300} height={300}>
          <Layer>
            <Image image={image} />
            <Text text={status} />
          </Layer>
        </Stage>
      );
    };
    const { stage } = await render(<App />);

    // not image while loading
    expect(stage.findOne('Image').image()).toBe(undefined);
    expect(stage.findOne('Text').text()).toBe('loading');

    const img = new window.Image();
    img.src = url;
    await new Promise((resolve) => {
      img.onload = () => {
        setTimeout(() => resolve(null), 50);
      };
    });
  });
});

describe('external', () => {
  it('make sure node has _applyProps for react-spring integration', async function () {
    class App extends React.Component {
      render() {
        return (
          <Stage width={300} height={300}>
            <Layer>
              <Rect fill="red" />
            </Layer>
          </Stage>
        );
      }
    }

    const { stage } = await render(<App />);
    expect(typeof stage.findOne('Rect')._applyProps).toBe('function');
  });
});

describe('React StrictMode', () => {
  it('refs should be correct when re-ordering stages', async function () {
    const stage1Ref = React.createRef<Konva.Stage>();
    const stage2Ref = React.createRef<Konva.Stage>();
    const layer1Ref = React.createRef<Konva.Layer>();
    const layer2Ref = React.createRef<Konva.Layer>();

    const App = ({ order }: { order: [string, string] }) => {
      const stages = {
        first: (
          <Stage key="first" width={100} height={100} ref={stage1Ref}>
            <Layer ref={layer1Ref}>
              <Rect fill="red" />
            </Layer>
          </Stage>
        ),
        second: (
          <Stage key="second" width={200} height={200} ref={stage2Ref}>
            <Layer ref={layer2Ref}>
              <Rect fill="blue" />
            </Layer>
          </Stage>
        ),
      };
      return (
        <>
          {stages[order[0]]}
          {stages[order[1]]}
        </>
      );
    };

    const { rerender } = await render(
      <React.StrictMode>
        <App order={['first', 'second']} />
      </React.StrictMode>
    );

    // Check initial refs
    expect(stage1Ref.current).toBeInstanceOf(Konva.Stage);
    expect(stage2Ref.current).toBeInstanceOf(Konva.Stage);
    expect(layer1Ref.current).toBeInstanceOf(Konva.Layer);
    expect(layer2Ref.current).toBeInstanceOf(Konva.Layer);
    expect(stage1Ref.current?.width()).toBe(100);
    expect(stage2Ref.current?.width()).toBe(200);

    // Store initial refs to compare after re-ordering
    const initialStage1 = stage1Ref.current;
    const initialStage2 = stage2Ref.current;
    const initialLayer1 = layer1Ref.current;
    const initialLayer2 = layer2Ref.current;

    // Re-order stages
    await rerender(
      <React.StrictMode>
        <App order={['second', 'first']} />
      </React.StrictMode>
    );

    // Check refs after re-ordering - must be exact same instances
    expect(stage1Ref.current).toBe(initialStage1);
    expect(stage2Ref.current).toBe(initialStage2);
    expect(layer1Ref.current).toBe(initialLayer1);
    expect(layer2Ref.current).toBe(initialLayer2);
  });

  it('make sure effect is called AFTER we set refs of konva nodes', async function () {
    const App = () => {
      const stageRef = React.useRef<Konva.Stage>(null);
      const [count, setCount] = React.useState(0);
      const shapeRef = React.useRef<Konva.Rect>(null);
      const trRef = React.useRef<Konva.Transformer>(null);

      const isMounted = React.useRef(false);

      React.useEffect(() => {
        setCount(1);
        setTimeout(() => {
          setCount(2);
          setTimeout(() => {
            setCount(3);
          }, 10);
        }, 10);
      }, []);

      React.useEffect(() => {
        // we need to attach transformer manually
        trRef.current?.nodes([shapeRef.current]);
        trRef.current?.getLayer().batchDraw();
      }, [count]);

      return (
        <>
          {count !== 2 && (
            <Stage width={300} height={300} ref={stageRef}>
              <Layer>
                <Rect fill="red" ref={shapeRef} />
                <Transformer ref={trRef} />
              </Layer>
            </Stage>
          )}
        </>
      );
    };

    const { stage } = await render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
    await new Promise((resolve) => setTimeout(resolve, 100));
    const lastStage = Konva.stages[Konva.stages.length - 1];
    const lastTransformer = lastStage.findOne('Transformer');
    expect(lastTransformer.nodes().length).toBe(1);
    expect(lastTransformer.nodes()[0].fill()).toBe('red');
  });

  it('event listeners in strict mode', async function () {
    const App = () => {
      return (
        <Stage width={300} height={300} onMouseDown={() => {}}>
          <Layer></Layer>
        </Stage>
      );
    };

    const { stage } = await render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
    expect(stage.eventListeners.mousedown.length).toBe(1);
  });

  // Simulates MobX timing: Page re-renders first, Elements re-renders later
  // Page's useLayoutEffect should still find shapes after Elements catches up
  it('useLayoutEffect finds shapes when sibling updates are batched', async function () {
    let elementsUpdateFn: () => void;
    let pageUpdateFn: () => void;

    // Elements component - has its own state (like MobX observer)
    const Elements = () => {
      const [elements, setElements] = React.useState(['existing']);
      elementsUpdateFn = () => setElements(['existing', 'newRect']);

      return (
        <>
          {elements.map((id) => (
            <Rect key={id} id={id} name={id} />
          ))}
        </>
      );
    };

    // Page component - has separate state that triggers useLayoutEffect
    const App = () => {
      const stageRef = React.useRef<Konva.Stage>(null);
      const [selectedId, setSelectedId] = React.useState<string | null>(null);
      pageUpdateFn = () => setSelectedId('newRect');

      React.useLayoutEffect(() => {
        if (selectedId) {
          const rect = stageRef.current?.findOne('#' + selectedId);
          // When we select 'newRect', it should be findable
          expect(rect).toBeTruthy();
        }
      }, [selectedId]);

      return (
        <Stage ref={stageRef} width={300} height={300}>
          <Layer>
            <Elements />
          </Layer>
        </Stage>
      );
    };

    await render(<App />);

    // Simulate MobX action: update both in the same act() batch
    // Both updates should be processed before layout effects run
    await React.act(async () => {
      elementsUpdateFn(); // Add 'newRect' to Elements
      pageUpdateFn(); // Select 'newRect' in Page
    });
  });
});

// Tests for useSyncExternalStore behavior (used by MobX, Zustand, etc.)
describe('useSyncExternalStore behavior', () => {
  // This test verifies that useSyncExternalStore works correctly with react-konva.
  // Note: The exact render order on updates is NOT guaranteed by React.
  // What matters is that all subscribed components eventually update consistently.
  it('all subscribed components update after store change', async function () {
    const store = {
      listeners: [] as (() => void)[],
      state: { name: 'initial' },
      getState() { return store.state; },
      subscribe(cb: () => void) {
        this.listeners.push(cb);
        return () => { this.listeners = this.listeners.filter(l => l !== cb); };
      },
      dispatch(newName: string) {
        this.state = { name: newName };
        this.listeners.forEach(cb => cb());
      },
    };

    function useSelector<T>(selector: (s: typeof store.state) => T): T {
      return React.useSyncExternalStore(
        cb => store.subscribe(cb),
        () => selector(store.getState())
      );
    }

    const parentValues: string[] = [];
    const childValues: string[] = [];

    function ChildText() {
      const name = useSelector(s => s.name);
      childValues.push(name);
      return <Text text={name} fontSize={15} />;
    }

    function ParentLayer() {
      const name = useSelector(s => s.name);
      parentValues.push(name);
      return (
        <Layer>
          <ChildText />
        </Layer>
      );
    }

    const App = () => (
      <Stage width={300} height={300}>
        <ParentLayer />
      </Stage>
    );

    await render(<App />);

    // Initial render: both should see 'initial'
    expect(parentValues).toContain('initial');
    expect(childValues).toContain('initial');

    // Trigger update
    await new Promise<void>(resolve => {
      setTimeout(() => { store.dispatch('updated'); resolve(); }, 10);
    });
    await new Promise(resolve => setTimeout(resolve, 50));

    // After update: both should see 'updated' (order doesn't matter)
    expect(parentValues).toContain('updated');
    expect(childValues).toContain('updated');
  });
});

// Test with Html component pattern (secondary React roots via Bridge)
// This simulates Polotno's structure where Html components create DOM elements
// inside the Stage container using a separate React root with Bridge.
//
// NOTE: These tests verify the pattern works correctly, but they CANNOT reproduce
// the actual production bug that required the flushSyncFromReconciler fix.
// The bug only manifests in production builds with specific timing conditions.
// See ReactKonvaCore.tsx for details about the fix.
describe('Html component pattern', () => {
  // Simplified Html component (like react-konva-utils Html)
  // Creates a secondary React root using Bridge for context bridging
  function Html({ children }: { children: React.ReactNode }) {
    const Bridge = useContextBridge();
    const groupRef = React.useRef<Konva.Group>(null);
    const [div] = React.useState(() => document.createElement('div'));
    const root = React.useMemo(() => createRoot(div), [div]);

    React.useLayoutEffect(() => {
      const group = groupRef.current;
      if (!group) return;
      const container = group.getStage()?.container();
      if (!container) return;
      container.appendChild(div);
      return () => { div.parentNode?.removeChild(div); };
    }, []);

    React.useLayoutEffect(() => {
      queueMicrotask(() => {
        flushSync(() => {
          root.render(<Bridge>{children}</Bridge>);
        });
      });
    });

    React.useLayoutEffect(() => {
      return () => { setTimeout(() => root.unmount()); };
    }, []);

    return <Group ref={groupRef} />;
  }

  // Multi-stage test: simulates Polotno's Workspace with multiple Pages
  // Each Page has a Stage with Elements and Html components
  it('multiple pages with Html components - useLayoutEffect finds shapes', async function () {
    const store = {
      listeners: [] as (() => void)[],
      state: {
        pages: [
          { id: 'page1', elements: [] as string[] },
          { id: 'page2', elements: [] as string[] },
          { id: 'page3', elements: [] as string[] },
        ],
      },
      subscribe(cb: () => void) {
        this.listeners.push(cb);
        return () => { this.listeners = this.listeners.filter(l => l !== cb); };
      },
      getState() { return this.state; },
      addElement(pageId: string, elementId: string) {
        const page = this.state.pages.find(p => p.id === pageId);
        if (page) page.elements = [...page.elements, elementId];
        this.listeners.forEach(cb => cb());
      },
    };

    function useSelector<T>(selector: (s: typeof store.state) => T): T {
      return React.useSyncExternalStore(
        cb => store.subscribe(cb),
        () => selector(store.getState())
      );
    }

    const effectLogs: { pageId: string; foundCount: number; expectedCount: number }[] = [];

    function Elements({ pageId }: { pageId: string }) {
      const elements = useSelector(s => s.pages.find(p => p.id === pageId)?.elements || []);
      return <>{elements.map(id => <Rect key={id} id={id} name={id} />)}</>;
    }

    function Page({ pageId }: { pageId: string }) {
      const stageRef = React.useRef<Konva.Stage>(null);
      const elements = useSelector(s => s.pages.find(p => p.id === pageId)?.elements || []);

      React.useLayoutEffect(() => {
        if (elements.length > 0 && stageRef.current) {
          const foundNodes = elements
            .map(id => stageRef.current?.findOne('#' + id))
            .filter(Boolean);
          effectLogs.push({ pageId, foundCount: foundNodes.length, expectedCount: elements.length });
        }
      }, [elements.join(',')]);

      return (
        <div>
          <Stage ref={stageRef} width={200} height={200}>
            <Layer>
              <Elements pageId={pageId} />
              <Html><div>Toolbar</div></Html>
              <Html><div>Selection</div></Html>
            </Layer>
          </Stage>
        </div>
      );
    }

    function Workspace() {
      const pages = useSelector(s => s.pages);
      return <div>{pages.map(page => <Page key={page.id} pageId={page.id} />)}</div>;
    }

    await render(<Workspace />);
    effectLogs.length = 0;

    // Add elements to different pages
    await new Promise<void>(resolve => setTimeout(() => { store.addElement('page1', 'rect1'); resolve(); }, 10));
    await new Promise(resolve => setTimeout(resolve, 50));
    await new Promise<void>(resolve => setTimeout(() => { store.addElement('page2', 'rect2'); resolve(); }, 10));
    await new Promise(resolve => setTimeout(resolve, 50));
    await new Promise<void>(resolve => setTimeout(() => { store.addElement('page3', 'rect3'); resolve(); }, 10));
    await new Promise(resolve => setTimeout(resolve, 50));

    // All pages should find their elements
    for (const log of effectLogs) {
      expect(log.foundCount).toBe(log.expectedCount);
    }
  });
});

// Regression test for React 19 timing issue with custom reconcilers
// 
// Bug: When using useSyncExternalStore (like MobX) with react-konva,
// parent component's useLayoutEffect couldn't find nodes rendered by
// child components after state updates. This happened because React 19's
// updateContainer could defer Konva reconciler work to a later microtask.
//
// Fix: Using flushSyncFromReconciler ensures synchronous reconciliation.
//
// Production conditions where bug manifested:
// - MobX/useSyncExternalStore for state management  
// - Html components that create secondary React roots with Bridge
// - Complex component hierarchies with multiple useSyncExternalStore subscribers
describe('React 19 reconciler timing fix', () => {
  it('parent useLayoutEffect finds shapes rendered by child with useSyncExternalStore', async function () {
    // Simple external store (like MobX uses internally via useSyncExternalStore)
    const store = {
      listeners: [] as (() => void)[],
      state: { elements: ['existing'], selectedId: null as string | null },
      subscribe(cb: () => void) {
        this.listeners.push(cb);
        return () => { this.listeners = this.listeners.filter(l => l !== cb); };
      },
      getState() { return this.state; },
      addAndSelect(id: string) {
        this.state = { elements: [...this.state.elements, id], selectedId: id };
        this.listeners.forEach(cb => cb());
      },
    };

    function useSelector<T>(selector: (s: typeof store.state) => T): T {
      return React.useSyncExternalStore(
        cb => store.subscribe(cb),
        () => selector(store.getState())
      );
    }

    const effectLog = vi.fn();

    // Child component: renders shapes based on store.elements
    // In production, this is wrapped with MobX observer
    function Elements() {
      const elements = useSelector(s => s.elements);
      return <>{elements.map(id => <Rect key={id} id={id} name={id} />)}</>;
    }

    // Parent component: observes selectedId and uses useLayoutEffect
    // The bug: useLayoutEffect runs before Elements renders the new shape
    function Page() {
      const stageRef = React.useRef<Konva.Stage>(null);
      const selectedId = useSelector(s => s.selectedId);

      React.useLayoutEffect(() => {
        if (selectedId && stageRef.current) {
          const node = stageRef.current.findOne('#' + selectedId);
          effectLog({ selectedId, foundNode: !!node });
        }
      }, [selectedId]);

      return (
        <Stage ref={stageRef} width={300} height={300}>
          <Layer>
            <Elements />
          </Layer>
        </Stage>
      );
    }

    await render(<Page />);
    effectLog.mockClear();

    // Trigger update outside React's batching (like real user interaction)
    await new Promise<void>(resolve => {
      setTimeout(() => { store.addAndSelect('newRect'); resolve(); }, 10);
    });
    await new Promise(resolve => setTimeout(resolve, 50));

    // Verify parent's useLayoutEffect found the node on FIRST call
    // Without flushSyncFromReconciler, this fails in production (foundNode=false)
    expect(effectLog.mock.calls.length).toBeGreaterThan(0);
    expect(effectLog.mock.calls[0][0].foundNode).toBe(true);
  });
});
</file>

<file path=".gitignore">
examples/*/bundle.js
node_modules
npm-debug.log
test/tests.bundle.js
.DS_Store
.idea
.lock
lib
es
test-build
.parcel-cache
dist
package-lock.json
.vscode
__screenshots__
</file>

<file path=".travis.yml">
language: node_js
node_js:
  - '6.11'
script:
  - npm run build && npm test
sudo: required
addons:
  chrome: stable
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2017 Anton Lavrenov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "license": "MIT",
  "name": "react-konva",
  "description": "React binding to canvas element via Konva framework",
  "version": "19.2.2",
  "keywords": [
    "react",
    "canvas",
    "jsx",
    "konva"
  ],
  "bugs": "https://github.com/konvajs/react-konva/issues",
  "main": "lib/ReactKonva.js",
  "module": "es/ReactKonva.js",
  "repository": {
    "type": "git",
    "url": "git@github.com:konvajs/react-konva.git"
  },
  "dependencies": {
    "@types/react-reconciler": "^0.33.0",
    "its-fine": "^2.0.0",
    "react-reconciler": "0.33.0",
    "scheduler": "0.27.0"
  },
  "targets": {
    "none": {}
  },
  "funding": [
    {
      "type": "patreon",
      "url": "https://www.patreon.com/lavrton"
    },
    {
      "type": "opencollective",
      "url": "https://opencollective.com/konva"
    },
    {
      "type": "github",
      "url": "https://github.com/sponsors/lavrton"
    }
  ],
  "peerDependencies": {
    "konva": "^8.0.1 || ^7.2.5 || ^9.0.0 || ^10.0.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@types/react": "19.2.10",
    "@vitest/browser": "^4.0.18",
    "@vitest/browser-playwright": "^4.0.18",
    "konva": "^10.2.0",
    "playwright": "^1.58.1",
    "react": "^19.2.4",
    "react-dom": "^19.2.4",
    "typescript": "^5.9.3",
    "use-image": "^1.1.4",
    "vitest": "^4.0.18"
  },
  "scripts": {
    "build": "tsc -outDir ./es &&  tsc -module commonjs -outDir ./lib && cp ./ReactKonvaCore.d.ts ./lib && cp ./ReactKonvaCore.d.ts ./es && node ./replace-version.js",
    "test:typings": "tsc --noEmit",
    "preversion": "npm test",
    "version": "npm run build",
    "postversion": "",
    "test": "vitest run && npm run test:typings",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:debug": "HEADLESS=false vitest"
  },
  "typings": "react-konva.d.ts",
  "files": [
    "README.md",
    "lib",
    "es",
    "react-konva.d.ts",
    "ReactKonvaCore.d.ts"
  ]
}
</file>

<file path="react-konva.d.ts">
export * from './ReactKonvaCore';
</file>

<file path="ReactKonvaCore.d.ts">
// special file for minimal import
import * as React from 'react';
import * as ReactReconciler from 'react-reconciler';
import Konva from 'konva';
import { useContextBridge } from 'its-fine';

export interface KonvaNodeEvents {
  onMouseOver?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onMouseMove?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onMouseOut?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onMouseEnter?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onMouseLeave?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onMouseDown?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onMouseUp?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onWheel?(evt: Konva.KonvaEventObject<WheelEvent>): void;
  onClick?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onDblClick?(evt: Konva.KonvaEventObject<MouseEvent>): void;
  onTouchStart?(evt: Konva.KonvaEventObject<TouchEvent>): void;
  onTouchMove?(evt: Konva.KonvaEventObject<TouchEvent>): void;
  onTouchEnd?(evt: Konva.KonvaEventObject<TouchEvent>): void;
  onTap?(evt: Konva.KonvaEventObject<TouchEvent>): void;
  onDblTap?(evt: Konva.KonvaEventObject<TouchEvent>): void;
  onDragStart?(evt: Konva.KonvaEventObject<DragEvent>): void;
  onDragMove?(evt: Konva.KonvaEventObject<DragEvent>): void;
  onDragEnd?(evt: Konva.KonvaEventObject<DragEvent>): void;
  onTransform?(evt: Konva.KonvaEventObject<Event>): void;
  onTransformStart?(evt: Konva.KonvaEventObject<Event>): void;
  onTransformEnd?(evt: Konva.KonvaEventObject<Event>): void;
  onContextMenu?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerDown?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerMove?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerUp?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerCancel?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerEnter?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerLeave?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerOver?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerOut?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerClick?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onPointerDblClick?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onGotPointerCapture?(evt: Konva.KonvaEventObject<PointerEvent>): void;
  onLostPointerCapture?(evt: Konva.KonvaEventObject<PointerEvent>): void;
}

export interface KonvaNodeComponent<
  Node extends Konva.Node,
  Props = Konva.NodeConfig
  // We use React.ClassAttributes to fake the 'ref' attribute. This will ensure
  // consumers get the proper 'Node' type in 'ref' instead of the wrapper
  // component type.
> extends React.FC<Props & KonvaNodeEvents & React.ClassAttributes<Node>> {
  getPublicInstance(): Node;
  getNativeNode(): Node;
  // putEventListener(type: string, listener: Function): void;
  // handleEvent(event: Event): void;
}

export interface StageProps
  extends Konva.NodeConfig,
    KonvaNodeEvents,
    Pick<
      React.HTMLAttributes<HTMLDivElement>,
      'className' | 'role' | 'style' | 'tabIndex' | 'title'
    > {}

// Stage is the only real class because the others are stubs that only know how
// to be rendered when they are under stage. Since there is no real backing
// class and are in reality are a string literal we don't want users to actually
// try and use them as a type. By defining them as a variable with an interface
// consumers will not be able to use the values as a type or constructor.
// The down side to this approach, is that typescript thinks the type is a
// function, but if the user tries to call it a runtime exception will occur.

export var Stage: KonvaNodeComponent<Konva.Stage, StageProps>;
export var Layer: KonvaNodeComponent<Konva.Layer, Konva.LayerConfig>;
export var FastLayer: KonvaNodeComponent<Konva.FastLayer, Konva.LayerConfig>;
export var Group: KonvaNodeComponent<Konva.Group, Konva.GroupConfig>;
export var Label: KonvaNodeComponent<Konva.Label, Konva.LabelConfig>;

/** Shapes */
export var Rect: KonvaNodeComponent<Konva.Rect, Konva.RectConfig>;
export var Circle: KonvaNodeComponent<Konva.Circle, Konva.CircleConfig>;
export var Ellipse: KonvaNodeComponent<Konva.Ellipse, Konva.EllipseConfig>;
export var Wedge: KonvaNodeComponent<Konva.Wedge, Konva.WedgeConfig>;
export var Transformer: KonvaNodeComponent<
  Konva.Transformer,
  Konva.TransformerConfig
>;
export var Line: KonvaNodeComponent<Konva.Line, Konva.LineConfig>;
export var Sprite: KonvaNodeComponent<Konva.Sprite, Konva.SpriteConfig>;
export var Image: KonvaNodeComponent<Konva.Image, Konva.ImageConfig>;
export var Text: KonvaNodeComponent<Konva.Text, Konva.TextConfig>;
export var TextPath: KonvaNodeComponent<Konva.TextPath, Konva.TextPathConfig>;
export var Star: KonvaNodeComponent<Konva.Star, Konva.StarConfig>;
export var Ring: KonvaNodeComponent<Konva.Ring, Konva.RingConfig>;
export var Arc: KonvaNodeComponent<Konva.Arc, Konva.ArcConfig>;
export var Tag: KonvaNodeComponent<Konva.Tag, Konva.TagConfig>;
export var Path: KonvaNodeComponent<Konva.Path, Konva.PathConfig>;
export var RegularPolygon: KonvaNodeComponent<
  Konva.RegularPolygon,
  Konva.RegularPolygonConfig
>;
export var Arrow: KonvaNodeComponent<Konva.Arrow, Konva.ArrowConfig>;
export var Shape: KonvaNodeComponent<Konva.Shape, Konva.ShapeConfig>;

export var useStrictMode: (useStrictMode: boolean) => void;
export var KonvaRenderer: ReactReconciler.Reconciler<
  any,
  any,
  any,
  any,
  any,
  any
>;

export var version: string;

export { useContextBridge };
</file>

<file path="README.md">
# React Konva

[![Financial Contributors on Open Collective](https://opencollective.com/konva/all/badge.svg?label=financial+contributors)](https://opencollective.com/konva)
[![npm version](https://badge.fury.io/js/react-konva.svg)](http://badge.fury.io/js/react-konva)
[![Build Status](https://github.com/konvajs/react-konva/actions/workflows/test.yml/badge.svg)](https://github.com/konvajs/react-konva/actions/workflows/test.ym)

![ReactKonva Logo](https://cloud.githubusercontent.com/assets/1443320/12193428/3bda2fcc-b623-11e5-8319-b1ccfc95eaec.png)

React Konva is a JavaScript library for drawing complex canvas graphics using
[React](http://facebook.github.io/react/).

It provides declarative and reactive bindings to the
[Konva Framework](http://konvajs.github.io/).

# [OPEN DEMO](https://codesandbox.io/s/5m3nwp787x)

An attempt to make [React](http://facebook.github.io/react/) work with the HTML5
canvas library. The goal is to have similar declarative markup as normal React
and to have similar data-flow model.

**At the current moment, `react-konva` is not supported in React Native environment.**

Currently you can use all `Konva` components as React components and all `Konva`
events are supported on them in same way as normal browser events are supported.

## Installation

```bash
npm install react-konva konva --save
```

## [Tutorials and Documentation](https://konvajs.github.io/docs/react/)

## Example

```javascript
import React, { useState } from 'react';
import { render } from 'react-dom';
import { Stage, Layer, Rect, Text } from 'react-konva';
import Konva from 'konva';

const ColoredRect = () => {
  const [color, setColor] = useState('green');

  const handleClick = () => {
    setColor(Konva.Util.getRandomColor());
  };

  return <Rect x={20} y={20} width={50} height={50} fill={color} shadowBlur={5} onClick={handleClick} />;
};

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text text="Try click on rect" />
        <ColoredRect />
      </Layer>
    </Stage>
  );
};

render(<App />, document.getElementById('root'));
```

To get more info about `Konva` you can read
[Konva Overview](http://konvajs.github.io/docs/overview.html).

**Actually you don't need to learn `react-konva`. Just learn `Konva` framework, you will understand how to use `react-konva`**

## Core API

`react-konva` supports all shapes, that `Konva` supports with the same names, and also it supports all the same events like `click`, `touchmove`, `dragend`, etc with "on" prefix like `onClick`, `onTouchMove`, `onDragEnd`.

### Getting reference to Konva objects

To get reference of `Konva` instance of a node you can use `ref` property.

```javascript
import React, { useEffect, useRef } from 'react';

const MyShape = () => {
  const circleRef = useRef();

  useEffect(() => {
    // log Konva.Circle instance
    console.log(circleRef.current);
  }, []);

  return <Circle ref={circleRef} radius={50} fill="black" />;
};
```

### Strict mode

By default `react-konva` works in "non-strict" mode. If you changed a property **manually** (or by user action like `drag&drop`) properties of the node will be not matched with properties from `render()`. `react-konva` updates ONLY properties changed in `render()`.

In strict mode `react-konva` will update all properties of the nodes to the values that you provided in `render()` function, no matter changed they or not.

You should decide what mode is better in your actual use case.

To enable strict mode globally you can do this:

```javascript
import { useStrictMode } from 'react-konva';

useStrictMode(true);
```

Or you can enable it only for some components:

```javascript
<Rect width={50} height={50} fill="black" _useStrictMode />
```

Take a look into this example:

```javascript
import { Circle } from 'react-konva';
import Konva from 'konva';

const Shape = () => {
  const [color, setColor] = React.useState();

  return (
    <Circle
      x={0}
      y={0}
      draggable
      radius={50}
      fill={color}
      onDragEnd={() => {
        setColor(Konva.Util.getRandomColor());
      }}
    />
  );
};
```

The circle is `draggable` and it changes its color on `dragend` event. In `strict` mode position of the node will be reset back to `{x: 0, y: 0}` (as we defined in render). But in `non-strict` mode the circle will keep its position, because `x` and `y` are not changed in render.

### Minimal bundle

By default `react-konva` imports full `Konva` version. With all the shapes and all filters. To minimize bundle size you can use minimal core version of `react-konva`:

```javascript
// load minimal version of 'react-konva`
import { Stage, Layer, Rect } from 'react-konva/lib/ReactKonvaCore';

// minimal version has NO support for core shapes and filters
// if you want import a shape into Konva namespace you can just do this:
import 'konva/lib/shapes/Rect';
```

Demo: [https://codesandbox.io/s/6l97wny44z](https://codesandbox.io/s/6l97wny44z)

## Usage with Next.js

**From `konva@10.0.0`, you don't need to do any extra steps. It will work out-of-the-box.**

If you use konva verion <= 9, continue reading.

Note: `react-konva` is designed to work in the client-side. On the server side, it will render just empty div. So it doesn't make much sense to use react-konva for server-side rendering. In Next.js you may have issue like

> Module not found: Can't resolve 'canvas'

Why do we see this error? `canvas` module is used for canvas rendering in Node.JS environment. `konva` library will use it there, but it doesn't have this dependency explicitly.

How to solve this issue? There are two approaches:

### Approach 1: manually install canvas module

You can install `canvas` module manually.

```bash
npm install canvas@next
```

The solution will solve the issue, but it will have unnecessary dependency on `canvas` module which may increase build time a little bit.

### Approach 2: Use dynamic import

Next.js docs: https://nextjs.org/docs/pages/building-your-application/optimizing/lazy-loading

With this approach your canvas component will be loaded on the client-side only. So you will not have any issues with server-side rendering. Also `next.js` will automatically understand that it doesn't need to load `canvas` module, because it is used for server-side rendering only.

#### Step 1 - Create canvas component

You need to define your canvas components somewhere in your `components` folder.

**It must be placed outside of `pages` or `app` folder (because they are used for server rendering).**

Your `components/canvas.js` file may look like this:

```js
import { Stage, Layer, Circle } from 'react-konva';

function Canvas(props) {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Circle x={200} y={100} radius={50} fill="green" />
      </Layer>
    </Stage>
  );
}

export default Canvas;
```

#### Step 2 - Use dynamic import

Then you can use it in your page. Notice, it is imported to have `'use client';`.

```js
'use client';
import dynamic from 'next/dynamic';

const Canvas = dynamic(() => import('../components/canvas'), {
  ssr: false,
});

export default function Page(props) {
  return <Canvas />;
}
```

#### Step 3 - Setup next.config.js

1. In some versions of next.js you may need to set up `next.config.js` to make it work:

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  webpack: (config) => {
    config.externals = [...config.externals, { canvas: 'canvas' }]; // required to make Konva & react-konva work
    return config;
  },
};

module.exports = nextConfig;
```

If you are using `turbopack` you may need to use this configuration:

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    turbo: {
      resolveAlias: {
        canvas: './empty.js',
      },
    },
  },
};

module.exports = nextConfig;
```

Also create empty file `empty.js` in the root of your project. That file will be used as replacement for `canvas` library. As we don't really need to use it, it will be just empty file.

### Usage with React Context

**Note: this section may be not relevant, because this issue was fixed in `react-konva@18.2.2`. So context should work by default.**

Due to a [known issue](https://github.com/facebook/react/issues/13336) with React, Contexts are not accessible by children of the react-konva `Stage` component. If you need to subscribe to a context from within the `Stage`, you need to "bridge" the context by creating a `Provider` as a child of the `Stage`. For more info, see [this discussion](https://github.com/konvajs/react-konva/issues/188#issuecomment-478302062) and this [react-redux demo](https://github.com/konvajs/react-konva/issues/311#issuecomment-454411007). Here is an example of bridging the context ([live demo](https://codesandbox.io/s/ykqw8r4r21)):

```js
import React, { Component } from 'react';
import Konva from 'konva';
import { render } from 'react-dom';
import { Stage, Layer, Rect } from 'react-konva';

const ThemeContext = React.createContext('red');

const ThemedRect = () => {
  const value = React.useContext(ThemeContext);
  return <Rect x={20} y={50} width={100} height={100} fill={value} shadowBlur={10} />;
};

const Canvas = () => {
  return (
    <ThemeContext.Consumer>
      {(value) => (
        <Stage width={window.innerWidth} height={window.innerHeight}>
          <ThemeContext.Provider value={value}>
            <Layer>
              <ThemedRect />
            </Layer>
          </ThemeContext.Provider>
        </Stage>
      )}
    </ThemeContext.Consumer>
  );
};

class App extends Component {
  render() {
    return (
      <ThemeContext.Provider value="blue">
        <Canvas />
      </ThemeContext.Provider>
    );
  }
}
```

## Comparisons

### react-konva vs react-canvas

[react-canvas](https://github.com/Flipboard/react-canvas) is a completely
different react plugin. It allows you to draw DOM-like objects (images, texts)
on canvas element in very performant way. It is NOT about drawing graphics, but
react-konva is exactly for drawing complex graphics on `<canvas>` element from
React.

### react-konva vs react-art

[react-art](https://github.com/reactjs/react-art) allows you to draw graphics on
a page. It also supports SVG for output. But it has no support of events of
shapes.

### react-konva vs vanilla canvas

Vanilla canvas is faster because when you use `react-konva` you have two layers of abstractions. Konva framework is on top of canvas and React is on top of Konva.
Depending on the use case this approach can be slow.
The purpose of `react-konva` is to reduce the complexity of the application and use well-known declarative way for drawing on canvas.

## [CHANGELOG](https://github.com/konvajs/react-konva/releases)

**Note: you can find a lot of demos and examples of using Konva there:
[http://konvajs.github.io/](http://konvajs.github.io/). Really, just go there and take a look what Konva can do for you. You will be able to do the same with `react-konva` too.**

```

```
</file>

<file path="replace-version.js">
const fs = require('fs');
const path = require('path');

const pkg = require('./package.json');
const version = pkg.version;

const targets = [
  path.join(__dirname, 'es', 'ReactKonvaCore.js'),
  path.join(__dirname, 'lib', 'ReactKonvaCore.js'),
];

targets.forEach((filePath) => {
  if (fs.existsSync(filePath)) {
    const src = fs.readFileSync(filePath, 'utf8');
    const replaced = src.replace(/\{VERSION\}/g, version);
    fs.writeFileSync(filePath, replaced, 'utf8');
    console.log(`Updated version in ${filePath}`);
  }
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "strict": false,
    "target": "ES2020",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "react",
    "skipLibCheck": false
  },
  "include": ["./src/**/*"],
  "files": [
    "react-konva.d.ts"
  ]
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import { playwright } from '@vitest/browser-playwright';

export default defineConfig({
  test: {
    browser: {
      enabled: true,
      provider: playwright(),
      headless: true,
      instances: [
        {
          browser: 'chromium',
        },
      ],
    },
    // Global test setup
    globals: true,
    // Coverage configuration
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'json', 'html'],
    },
  },
  resolve: {
    alias: {
      // Ensure test imports resolve correctly
      '@': '/src',
    },
  },
});
</file>

</files>
