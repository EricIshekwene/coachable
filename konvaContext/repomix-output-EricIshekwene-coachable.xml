<repomix><file_summary>This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in xml style, security check has been disabled.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)</notes></file_summary><directory_structure>public/
  Modern_mouse.png
  vite.svg
src/
  assets/
    fonts/
      DMSans-Regular.ttf
      DMSans-SemiBold.ttf
      Manrope-Regular.ttf
      Manrope-SemiBold.ttf
    keyframes/
      Selected Key Frame.png
      Unselected Key Frame.png
    objects/
      balls/
        white_ball.png
      Field Vectors/
        Rugby_Field.png
    players/
      Ellipse 8.png
    prefabIcons/
      Rugby KickOff.png
      Rugby Lineout.png
      Rugby Scrum.png
  canvas/
    BoardViewport.jsx
    canvas.md
    CanvasRoot.jsx
    DraggableItem.jsx
    FieldLayer.jsx
    ItemsLayer.jsx
    ItemVisual.jsx
    PanHandler.jsx
    WorldLayer.jsx
  components/
    advancedSettings/
      AnimationSettingsSection.jsx
      ExportVideoSettingsSection.jsx
      LoggerSettingsSection.jsx
      PitchSettingsSection.jsx
      PlayerSettingsSection.jsx
      README.md
    controlPill/
      ControlPill.jsx
      DropdownMenu.jsx
      KeyframeDisplay.jsx
      KeyframeManager.jsx
      PlaybackControls.jsx
      README.md
      SpeedSlider.jsx
      TimePill.jsx
    MessagePopup/
      MessagePopup.jsx
      README.md
    rightPanel/
      AdvancedSettingsButton.jsx
      AllPlayersSection.jsx
      ExportActions.jsx
      FieldSettingsSection.jsx
      PlayerEditPanel.jsx
      PlayerRow.jsx
      PlayersSection.jsx
      PlayNameEditor.jsx
      README.md
      SavePrefabButton.jsx
      SelectedPlayersSection.jsx
    sidebar/
      AddPlayerSection.jsx
      EraserToolSection.jsx
      HistoryActionsSection.jsx
      PenToolSection.jsx
      PlayerColorSection.jsx
      PrefabsSection.jsx
      README.md
      SelectToolSection.jsx
      SidebarRoot.jsx
    subcomponents/
      controlPill/
        DropdownMenu.jsx
        KeyframeDisplay.jsx
        KeyframeManager.jsx
        PlaybackControls.jsx
        README.md
        SpeedSlider.jsx
        TimePill.jsx
      Buttons.jsx
      ColorPickerPopover.jsx
      Popovers.jsx
      PrefabsPopover.jsx
    wideSidebar/
      README.md
      WideSidebarRoot.jsx
    AdvancedSettings.jsx
    DragCanvas.jsx
    RightPanel.jsx
    Sidebar.jsx
    WideSidebar.jsx
  utils/
    exportPlay.js
  App.jsx
  index.css
  main.jsx
.gitignore
CONTROL_PILL_STATE_ANALYSIS.md
dependencies
DOWNLOAD.md
eslint.config.js
index.html
KEYFRAME_DIAGNOSIS.md
NOTE_FOR_CHATGPT_CODEX_PROMPT.md
package.json
README.md
SIDEBAR_BREAKDOWN_PLAN.md
SIDEBAR_STATE_ANALYSIS.md
todo.md
vite.config.js</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="public/vite.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; aria-hidden=&quot;true&quot; role=&quot;img&quot; class=&quot;iconify iconify--logos&quot; width=&quot;31.88&quot; height=&quot;32&quot; preserveAspectRatio=&quot;xMidYMid meet&quot; viewBox=&quot;0 0 256 257&quot;&gt;&lt;defs&gt;&lt;linearGradient id=&quot;IconifyId1813088fe1fbc01fb466&quot; x1=&quot;-.828%&quot; x2=&quot;57.636%&quot; y1=&quot;7.652%&quot; y2=&quot;78.411%&quot;&gt;&lt;stop offset=&quot;0%&quot; stop-color=&quot;#41D1FF&quot;&gt;&lt;/stop&gt;&lt;stop offset=&quot;100%&quot; stop-color=&quot;#BD34FE&quot;&gt;&lt;/stop&gt;&lt;/linearGradient&gt;&lt;linearGradient id=&quot;IconifyId1813088fe1fbc01fb467&quot; x1=&quot;43.376%&quot; x2=&quot;50.316%&quot; y1=&quot;2.242%&quot; y2=&quot;89.03%&quot;&gt;&lt;stop offset=&quot;0%&quot; stop-color=&quot;#FFEA83&quot;&gt;&lt;/stop&gt;&lt;stop offset=&quot;8.333%&quot; stop-color=&quot;#FFDD35&quot;&gt;&lt;/stop&gt;&lt;stop offset=&quot;100%&quot; stop-color=&quot;#FFA800&quot;&gt;&lt;/stop&gt;&lt;/linearGradient&gt;&lt;/defs&gt;&lt;path fill=&quot;url(#IconifyId1813088fe1fbc01fb466)&quot; d=&quot;M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z&quot;&gt;&lt;/path&gt;&lt;path fill=&quot;url(#IconifyId1813088fe1fbc01fb467)&quot; d=&quot;M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;</file><file path="src/canvas/BoardViewport.jsx">import React, { forwardRef } from &quot;react&quot;;

// BoardViewport: Defines the visible screen area.
// - Relative positioning, overflow-hidden, no drag logic.
// - Owns the export ref for future image export.
const BoardViewport = forwardRef(function BoardViewport({ className = &quot;&quot;, style, children }, ref) {
  return (
    &lt;div
      ref={ref}
      className={`relative overflow-hidden touch-none select-none ${className}`}
      style={{ width: &quot;100%&quot;, height: &quot;100%&quot;, ...style }}
    &gt;
      {children}
    &lt;/div&gt;
  );
});

export default BoardViewport;</file><file path="src/canvas/canvas.md"># Canvas System Overview

This folder implements a layered canvas architecture for building interactive sports plays (field + players + camera).  
The goal is to keep behavior predictable, scalable, and readable as complexity grows.

The canvas follows a **viewport → camera → world → items** mental model, similar to tools like Figma or Miro.

---

## Mental Model

There are three coordinate spaces:

1. **Viewport space**
   - What the user can see.
   - Clipped to screen bounds.
   - Used for export.

2. **World space**
   - The infinite field where objects live.
   - Players, balls, and markings use world coordinates.
   - The field image is anchored here.

3. **Camera**
   - Controls how the world is viewed.
   - Panning moves the camera, not the field or items directly.
   - Zoom scales the world uniformly.

Dragging behavior depends on the active tool:
- **Hand tool** → pans the camera.
- **Select tool** → drags individual items.

---

## Folder Structure

src/canvas/
├── CanvasRoot.jsx
├── BoardViewport.jsx
├── PanHandler.jsx
├── WorldLayer.jsx
├── FieldLayer.jsx
├── DraggableItem.jsx
├── ItemsLayer.jsx
└── renderers/
└── ItemVisual.jsx


Each file has a single responsibility.

---

## Component Responsibilities

### CanvasRoot

**Role**
- Top-level coordinator for the canvas.
- Owns shared state.

**Owns**
- `tool` (&quot;hand&quot; | &quot;select&quot;)
- `camera` `{ x, y, zoom }`
- `items` array `{ id, type, x, y, ... }`

**Does NOT**
- Render visuals directly.
- Handle pointer math itself.

---

### BoardViewport

**Role**
- Defines the visible screen area.

**Owns**
- `ref` used for export.
- Clipping via `overflow-hidden`.
- Background color.

**Key properties**
- `position: relative`
- `overflow: hidden`

Everything outside this component is invisible.

---

### PanHandler

**Role**
- Handles camera panning via pointer input.

**Behavior**
- Only active when `tool === &quot;hand&quot;`.
- Only responds to dragging empty space.
- Updates `camera.x` and `camera.y`.

**Important rule**
- If a draggable item is clicked, it calls `stopPropagation()`, preventing pan.

---

### WorldLayer

**Role**
- Applies camera transform to the world.

**Behavior**
- Wraps all world content.
- Applies:
  - `transform: translate(camera.x, camera.y) scale(camera.zoom)`
  - `transform-origin: 50% 50%` (zoom around center)


**Result**
- Field and all items move together during pan and zoom.
- Zooming focuses on the visual center (no left/top drift).

---

### FieldLayer

**Role**
- Renders the pitch graphic.

**Positioning**
- Centered by default using CSS percentages:
- `left: 50%`
- `top: 50%`
- `transform: translate(-50%, -50%)`

**Rules**
- No React state.
- No dragging logic.
- `pointer-events: none`
- `draggable={false}`

The field can extend beyond the viewport and will be clipped.

---

### DraggableItem

**Role**
- Generic draggable wrapper for a single object.

**Used for**
- Players
- Balls
- Cones, arrows, text (future)

**Behavior**
- Active only when `tool === &quot;select&quot;`.
- Uses pointer delta math to update `{ x, y }` in world space.
- Calls `e.stopPropagation()` on pointer down.

**Does NOT**
- Pan the camera.
- Know about other items.
- Handle visuals.

---

### ItemsLayer

**Role**
- Renders all draggable items.

**Behavior**
- Wraps items in a center-origin container so world coordinates are measured from the visual center.
- Maps `items` array → `DraggableItem`.
- Delegates appearance to `ItemVisual`.

Keeps rendering logic separate from interaction logic.

---

### ItemVisual

**Role**
- Pure visual rendering.

**Examples**
- Player → colored circle
- Ball → image asset

**Rules**
- No pointer logic.
- No state.
- No position math.

---

## Default Positioning Rules

- The field is always centered by CSS (50%/50% with translate).
- The camera defaults to `{ x: 0, y: 0, zoom: 1 }`.
- World coordinates are centered: `{ x: 0, y: 0 }` is the middle of the viewport/field.
- Items placed at `{ x: 0, y: 0 }` appear at midfield; positive `x` is right, positive `y` is down.
- Avoid hardcoded top-left–based pixel assumptions like `{ x: 300, y: 300 }` unless intentional.

### Zoom Behavior
- `WorldLayer` uses `transform-origin: 50% 50%` so zoom pivots around the center.
- To zoom toward the pointer, compute camera deltas against pointer-to-center vector (not yet implemented here).

### Adding New Items (Players/Ball)
- Create items in world coordinates relative to center. Example: `{ x: 0, y: 0 }` spawns at the visual center.
- If you want to spawn at the current screen center regardless of panning, you can use the current camera to compute a world position from a screen point and set the item `{ x, y }` accordingly.

---

## Why This Architecture

This structure prevents common issues:
- No nested draggable conflicts.
- No magic numbers tied to screen size.
- Clean separation of input, layout, and visuals.
- Easy export (capture only `BoardViewport`).

It also makes future features easier:
- Zoom
- Snap-to-grid
- Multi-select
- Keyframe animation
- Different sports fields

---

## Summary

- **Viewport** defines what is visible.
- **Camera** defines where you are looking.
- **World** contains everything.
- **Items** move independently unless the camera moves.

If something moves unexpectedly, check:
1. Which layer owns the movement?
2. Whether propagation was stopped.
3. Whether the transform is applied at the correct level.

## Debug Checklist

Use this list when something moves incorrectly, drags unexpectedly, or disappears.

### 1. Field is not centered
- Confirm `FieldLayer` uses:
  - `left: 50%`
  - `top: 50%`
  - `transform: translate(-50%, -50%)`
- Ensure there is **no field position stored in React state**.
- Verify the camera default is `{ x: 0, y: 0, zoom: 1 }`.

### 1b. Zoom drifts left/top
- Confirm `WorldLayer` style includes `transform-origin: 50% 50%`.
- If zoom is pointer-centered, ensure camera adjusts during wheel (not included by default).

---

### 2. Field or items disappear while panning
- Check `BoardViewport` has:
  - `position: relative`
  - `overflow: hidden`
- Confirm the field image has `max-w-none`.
- Verify `WorldLayer` is not constrained by width/height.

---

### 3. Dragging a player also pans the camera
- Ensure `DraggableItem` calls:
  ```js
  e.stopPropagation();</file><file path="src/canvas/CanvasRoot.jsx">import React, { useRef } from &quot;react&quot;;
import BoardViewport from &quot;./BoardViewport&quot;;
import PanHandler from &quot;./PanHandler&quot;;
import WorldLayer from &quot;./WorldLayer&quot;;
import FieldLayer from &quot;./FieldLayer&quot;;
import ItemsLayer from &quot;./ItemsLayer&quot;;

// CanvasRoot: Composes the layered canvas system and centralizes state
export default function CanvasRoot({
  tool = &quot;hand&quot;,
  camera,
  setCamera,
  items,
  fieldRotation = 0,
  onPanStart,
  onItemChange,
  onItemDragStart,
  onItemDragEnd,
  onCanvasAddPlayer,
  onMarqueeSelect,
  selectedPlayerIds,
  selectedItemIds,
  onSelectItem,
  allPlayersDisplay,
  advancedSettings,
}) {
  const viewportRef = useRef(null); // reserved for future export usage

  const pitch = advancedSettings?.pitch ?? {};
  const players = advancedSettings?.players ?? {};

  const pitchColor = pitch.pitchColor ?? undefined;
  const showMarkings = pitch.showMarkings ?? true;
  const playerBaseSizePx = players.baseSizePx ?? 30;

  return (
    &lt;BoardViewport ref={viewportRef} className=&quot;bg-BrandGreen&quot; style={pitchColor ? { backgroundColor: pitchColor } : undefined}&gt;
      &lt;PanHandler
        tool={tool}
        camera={camera}
        setCamera={setCamera}
        onCanvasAddPlayer={onCanvasAddPlayer}
        items={items}
        onMarqueeSelect={onMarqueeSelect}
        onPanStart={onPanStart}
      &gt;
        &lt;WorldLayer camera={camera}&gt;
          &lt;FieldLayer showMarkings={showMarkings} rotationDeg={fieldRotation} /&gt;
          &lt;ItemsLayer
            items={items}
            tool={tool}
            camera={camera}
            onItemChange={onItemChange}
            onItemDragStart={onItemDragStart}
            onItemDragEnd={onItemDragEnd}
            selectedPlayerIds={selectedPlayerIds}
            selectedItemIds={selectedItemIds}
            onSelectItem={onSelectItem}
            allPlayersDisplay={allPlayersDisplay}
            playerBaseSizePx={playerBaseSizePx}
          /&gt;
        &lt;/WorldLayer&gt;
      &lt;/PanHandler&gt;
    &lt;/BoardViewport&gt;
  );
}</file><file path="src/canvas/DraggableItem.jsx">import React, { useRef, useState } from &quot;react&quot;;

// DraggableItem: Generic draggable for items in WORLD coordinates.
// - Only draggable when tool === &quot;select&quot; and draggable === true
// - Stops propagation on pointer down so PanHandler won&apos;t start
// - Uses pointer delta with camera.zoom to update world {x,y}
export default function DraggableItem({
  item,
  tool,
  camera,
  draggable = true,
  onChange,
  onDragStart,
  onDragEnd,
  onSelect,
  children,
}) {
  const draggingRef = useRef(false);
  const pointerIdRef = useRef(null);
  const lastScreenPtRef = useRef({ x: 0, y: 0 });
  const startScreenPtRef = useRef({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const DRAG_THRESHOLD_PX = 3;

  const onPointerDown = (e) =&gt; {
    // Prevent PanHandler from engaging
    e.stopPropagation();
    if (tool !== &quot;select&quot; || !draggable) return;

    draggingRef.current = true;
    pointerIdRef.current = e.pointerId;
    setIsDragging(false);
    lastScreenPtRef.current = { x: e.clientX, y: e.clientY };
    startScreenPtRef.current = { x: e.clientX, y: e.clientY };
    e.currentTarget.setPointerCapture?.(e.pointerId);
  };

  const onPointerMove = (e) =&gt; {
    if (!draggingRef.current) return;
    if (pointerIdRef.current !== e.pointerId) return;
    const dxScreen = e.clientX - lastScreenPtRef.current.x;
    const dyScreen = e.clientY - lastScreenPtRef.current.y;
    lastScreenPtRef.current = { x: e.clientX, y: e.clientY };

    if (!isDragging) {
      const totalDx = e.clientX - startScreenPtRef.current.x;
      const totalDy = e.clientY - startScreenPtRef.current.y;
      if (Math.hypot(totalDx, totalDy) &gt;= DRAG_THRESHOLD_PX) {
        setIsDragging(true);
        onDragStart?.(item.id);
      } else {
        return;
      }
    }

    const scale = camera.zoom || 1;
    const dxWorld = dxScreen / scale;
    const dyWorld = dyScreen / scale;

    onChange?.(item.id, { x: item.x + dxWorld, y: item.y + dyWorld }, { delta: { x: dxWorld, y: dyWorld } });
  };

  const endDrag = (e) =&gt; {
    if (!draggingRef.current) return;
    if (pointerIdRef.current !== e.pointerId) return;
    draggingRef.current = false;
    pointerIdRef.current = null;
    if (isDragging) {
      setIsDragging(false);
      onDragEnd?.(item.id);
    } else {
      onSelect?.(item.id, { toggle: true });
    }
    try {
      e.currentTarget.releasePointerCapture?.(e.pointerId);
    } catch {}
  };

  return (
    &lt;div
      onPointerDown={onPointerDown}
      onPointerMove={onPointerMove}
      onPointerUp={endDrag}
      onPointerCancel={endDrag}
      className=&quot;absolute&quot;
      style={{
        left: item.x,
        top: item.y,
        cursor: tool === &quot;select&quot; &amp;&amp; draggable ? (isDragging ? &quot;grabbing&quot; : &quot;grab&quot;) : &quot;default&quot;,
        touchAction: &quot;none&quot;,
      }}
    &gt;
      {children}
    &lt;/div&gt;
  );
}</file><file path="src/canvas/FieldLayer.jsx">import React from &quot;react&quot;;
import RugbyField from &quot;../assets/objects/Field Vectors/Rugby_Field.png&quot;;

// FieldLayer: Renders the rugby field image.
// - Pointer events disabled.
// - Centered via CSS percentages, not pixels.
// - max-w-none so it can exceed viewport and be clipped.
export default function FieldLayer({ showMarkings = true, rotationDeg = 0 }) {
  if (!showMarkings) return null;

  return (
    &lt;img
      src={RugbyField}
      alt=&quot;rugby field&quot;
      className=&quot;pointer-events-none select-none max-w-none&quot;
      draggable={false}
      onDragStart={(e) =&gt; e.preventDefault()}
      style={{
        position: &quot;absolute&quot;,
        left: &quot;50%&quot;,
        top: &quot;50%&quot;,
        transform: `translate(-50%, -50%) rotate(${rotationDeg}deg)`,
      }}
    /&gt;
  );
}</file><file path="src/canvas/ItemsLayer.jsx">import React from &quot;react&quot;;
import DraggableItem from &quot;./DraggableItem&quot;;
import ItemVisual from &quot;./ItemVisual&quot;;

// ItemsLayer: Maps items to DraggableItem wrappers and renders visuals.
export default function ItemsLayer({
  items,
  tool,
  camera,
  onItemChange,
  onItemDragStart,
  onItemDragEnd,
  selectedPlayerIds,
  selectedItemIds,
  onSelectItem,
  allPlayersDisplay,
  playerBaseSizePx,
}) {
  return (
    &lt;div className=&quot;absolute inset-0&quot;&gt;
      {/* Center-origin container so world coords (0,0) are screen center */}
      &lt;div
        className=&quot;absolute&quot;
        style={{ left: &quot;50%&quot;, top: &quot;50%&quot;, transform: &quot;translate(-50%, -50%)&quot; }}
      &gt;
        {items.map((item) =&gt; (
          &lt;DraggableItem
            key={item.id}
            item={item}
            tool={tool}
            camera={camera}
            draggable={item.draggable !== false}
            onChange={(id, next, meta) =&gt; onItemChange?.(id, next, meta)}
            onDragStart={onItemDragStart}
            onDragEnd={onItemDragEnd}
            onSelect={(id, meta) =&gt; onSelectItem?.(id, item.type, meta)}
          &gt;
            &lt;ItemVisual
              item={item}
              allPlayersDisplay={allPlayersDisplay}
              playerBaseSizePx={playerBaseSizePx}
              isSelected={
                item.type === &quot;player&quot;
                  ? selectedPlayerIds?.includes(item.id)
                  : selectedItemIds?.includes(item.id)
              }
            /&gt;
          &lt;/DraggableItem&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/canvas/ItemVisual.jsx">import React, { useState } from &quot;react&quot;;
import whiteBall from &quot;../assets/objects/balls/white_ball.png&quot;;

export default function ItemVisual({ item, allPlayersDisplay, playerBaseSizePx, isSelected = false }) {
  const [ballImageError, setBallImageError] = useState(false);
  switch (item.type) {
    case &quot;player&quot;:
      {
        const sizePercent = allPlayersDisplay?.sizePercent ?? 100;
        // Default to showing player numbers unless explicitly turned off.
        const showNumber = allPlayersDisplay?.showNumber ?? true;
        const showName = allPlayersDisplay?.showName ?? false;
        const color = item.color || allPlayersDisplay?.color || &quot;#ef4444&quot;;

        const basePx = Math.max(6, Number(playerBaseSizePx) || 30);
        const sizePx = Math.max(6, Math.round((basePx * sizePercent) / 100));

        const numberText = item.number ?? &quot;&quot;;
        const nameText = item.name ?? &quot;&quot;;

        return (
          &lt;div className=&quot;z-30 flex flex-col items-center select-none&quot; style={{ pointerEvents: &quot;none&quot; }}&gt;
            &lt;div
              className=&quot;rounded-full border-[2px] border-BrandBlack flex items-center justify-center text-BrandBlack font-DmSans&quot;
              style={{
                width: `${sizePx}px`,
                height: `${sizePx}px`,
                backgroundColor: color,
                fontSize: `${Math.max(10, Math.round(sizePx * 0.45))}px`,
                lineHeight: 1,
                boxShadow: isSelected ? &quot;0 0 0 2px #FF7A18&quot; : &quot;none&quot;,
              }}
            &gt;
              {showNumber &amp;&amp; numberText !== &quot;&quot; &amp;&amp; &lt;span className=&quot;font-bold&quot;&gt;{numberText}&lt;/span&gt;}
            &lt;/div&gt;

            {showName &amp;&amp; nameText !== &quot;&quot; &amp;&amp; (
              &lt;div className=&quot;mt-1 text-BrandBlack font-DmSans font-semibold&quot; style={{ fontSize: `${Math.max(9, Math.round(sizePx * 0.32))}px` }}&gt;
                {nameText}
              &lt;/div&gt;
            )}
          &lt;/div&gt;
        );
      }
    case &quot;ball&quot;:
      {
        const ballSizePx = 22;
        return (
          &lt;div
            className=&quot;z-40 flex items-center justify-center select-none&quot;
            style={{
              width: ballSizePx,
              height: ballSizePx,
              pointerEvents: &quot;none&quot;,
              boxShadow: isSelected ? &quot;0 0 0 2px #FF7A18&quot; : &quot;none&quot;,
              borderRadius: &quot;9999px&quot;,
            }}
          &gt;
            {ballImageError ? (
              &lt;div
                className=&quot;rounded-full border-2 border-BrandBlack bg-BrandWhite&quot;
                style={{ width: ballSizePx, height: ballSizePx }}
                title=&quot;ball&quot;
              /&gt;
            ) : (
              &lt;img
                src={whiteBall}
                alt=&quot;ball&quot;
                draggable={false}
                onDragStart={(e) =&gt; e.preventDefault()}
                onError={() =&gt; setBallImageError(true)}
                style={{
                  width: ballSizePx,
                  height: ballSizePx,
                  objectFit: &quot;contain&quot;,
                  filter: &quot;drop-shadow(0 1px 1.5px rgba(0,0,0,0.2)) drop-shadow(0 0 0.5px rgba(0,0,0,0.4))&quot;,
                }}
              /&gt;
            )}
          &lt;/div&gt;
        );
      }
    default:
      return null;
  }
}</file><file path="src/canvas/PanHandler.jsx">import React, { useRef, useState } from &quot;react&quot;;

// PanHandler: Handles camera panning based on tool mode.
// - Only pans on empty space (DraggableItem stops propagation).
// - Updates camera {x,y,zoom}. No item logic.
export default function PanHandler({
  tool,
  camera,
  setCamera,
  onCanvasAddPlayer,
  items = [],
  onMarqueeSelect,
  onPanStart,
  children,
}) {
  const draggingRef = useRef(false);
  const pointerIdRef = useRef(null);
  const lastPtRef = useRef({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const selectingRef = useRef(false);
  const marqueeActiveRef = useRef(false);
  const marqueeStartRef = useRef({ x: 0, y: 0 });
  const marqueeEndRef = useRef({ x: 0, y: 0 });
  const [marquee, setMarquee] = useState(null);
  const DRAG_THRESHOLD_PX = 4;

  const onPointerDown = (e) =&gt; {
    const isMiddleMouse = e.button === 1;
    const isAddTool = tool === &quot;addPlayer&quot; || tool === &quot;color&quot;;
    if (isAddTool &amp;&amp; !isMiddleMouse) {
      if (e.button !== 0) return;
      const rect = e.currentTarget.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const cx = rect.width / 2;
      const cy = rect.height / 2;
      const scale = camera.zoom || 1;
      const worldX = (sx - cx - camera.x) / scale;
      const worldY = (sy - cy - camera.y) / scale;
      onCanvasAddPlayer?.({ x: worldX, y: worldY, source: tool });
      return;
    }
    if (tool === &quot;select&quot; &amp;&amp; !isMiddleMouse) {
      if (e.button !== 0) return;
      selectingRef.current = true;
      marqueeActiveRef.current = false;
      pointerIdRef.current = e.pointerId;
      const rect = e.currentTarget.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      marqueeStartRef.current = { x: sx, y: sy };
      marqueeEndRef.current = { x: sx, y: sy };
      e.currentTarget.setPointerCapture?.(e.pointerId);
      return;
    }
    if (!isMiddleMouse &amp;&amp; tool !== &quot;hand&quot;) return;
    draggingRef.current = true;
    pointerIdRef.current = e.pointerId;
    lastPtRef.current = { x: e.clientX, y: e.clientY };
    setIsPanning(true);
    e.currentTarget.setPointerCapture?.(e.pointerId);
    onPanStart?.();
    if (isMiddleMouse) {
      e.preventDefault();
    }
  };

  const onPointerMove = (e) =&gt; {
    if (selectingRef.current) {
      if (pointerIdRef.current !== e.pointerId) return;
      const rect = e.currentTarget.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      marqueeEndRef.current = { x: sx, y: sy };
      const totalDx = sx - marqueeStartRef.current.x;
      const totalDy = sy - marqueeStartRef.current.y;
      if (!marqueeActiveRef.current) {
        if (Math.hypot(totalDx, totalDy) &lt; DRAG_THRESHOLD_PX) return;
        marqueeActiveRef.current = true;
      }
      const x1 = Math.min(marqueeStartRef.current.x, sx);
      const y1 = Math.min(marqueeStartRef.current.y, sy);
      const x2 = Math.max(marqueeStartRef.current.x, sx);
      const y2 = Math.max(marqueeStartRef.current.y, sy);
      setMarquee({ x: x1, y: y1, w: x2 - x1, h: y2 - y1 });
      return;
    }
    if (!draggingRef.current) return;
    if (pointerIdRef.current !== e.pointerId) return;
    const dx = e.clientX - lastPtRef.current.x;
    const dy = e.clientY - lastPtRef.current.y;
    lastPtRef.current = { x: e.clientX, y: e.clientY };

    setCamera((prev) =&gt; ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
  };

  const endPan = (e) =&gt; {
    if (selectingRef.current) {
      if (pointerIdRef.current !== e.pointerId) return;
      const start = marqueeStartRef.current;
      const end = marqueeEndRef.current;
      selectingRef.current = false;
      const wasMarquee = marqueeActiveRef.current;
      marqueeActiveRef.current = false;
      pointerIdRef.current = null;
      setMarquee(null);
      if (wasMarquee) {
        const rect = e.currentTarget.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        const scale = camera.zoom || 1;
        const x1 = Math.min(start.x, end.x);
        const y1 = Math.min(start.y, end.y);
        const x2 = Math.max(start.x, end.x);
        const y2 = Math.max(start.y, end.y);
        const selectedIds = [];
        items.forEach((item) =&gt; {
          if (!item) return;
          const sx = cx + camera.x + item.x * scale;
          const sy = cy + camera.y + item.y * scale;
          if (sx &gt;= x1 &amp;&amp; sx &lt;= x2 &amp;&amp; sy &gt;= y1 &amp;&amp; sy &lt;= y2) {
            selectedIds.push(item.id);
          }
        });
        onMarqueeSelect?.(selectedIds);
      } else {
        onMarqueeSelect?.([]);
      }
      try {
        e.currentTarget.releasePointerCapture?.(e.pointerId);
      } catch {}
      return;
    }
    if (!draggingRef.current) return;
    if (pointerIdRef.current !== e.pointerId) return;
    draggingRef.current = false;
    pointerIdRef.current = null;
    setIsPanning(false);
    try {
      e.currentTarget.releasePointerCapture?.(e.pointerId);
    } catch {}
  };

  return (
    &lt;div
      onPointerDown={onPointerDown}
      onPointerMove={onPointerMove}
      onPointerUp={endPan}
      onPointerCancel={endPan}
      className=&quot;absolute inset-0&quot;
      style={{
        cursor:
          tool === &quot;hand&quot;
            ? isPanning
              ? &quot;grabbing&quot;
              : &quot;grab&quot;
            : tool === &quot;select&quot; &amp;&amp; isPanning
              ? &quot;grabbing&quot;
              : tool === &quot;addPlayer&quot; || tool === &quot;color&quot;
                ? &quot;copy&quot;
                : &quot;default&quot;,
      }}
    &gt;
      {children}
      {marquee &amp;&amp; (
        &lt;div
          className=&quot;absolute border border-BrandOrange bg-BrandOrange/10 pointer-events-none&quot;
          style={{
            left: marquee.x,
            top: marquee.y,
            width: marquee.w,
            height: marquee.h,
          }}
        /&gt;
      )}
    &lt;/div&gt;
  );
}</file><file path="src/canvas/WorldLayer.jsx">import React from &quot;react&quot;;

// WorldLayer: Applies camera transform to all children.
// - No pointer logic.
export default function WorldLayer({ camera, children }) {
  const { x, y, zoom } = camera;
  const transform = `translate(${x}px, ${y}px) scale(${zoom})`;
  return (
    &lt;div
      className=&quot;absolute inset-0&quot;
      style={{
        transform,
        transformOrigin: &quot;50% 50%&quot;,
        willChange: &quot;transform&quot;,
      }}
    &gt;
      {children}
    &lt;/div&gt;
  );
}</file><file path="src/components/advancedSettings/AnimationSettingsSection.jsx">import React from &apos;react&apos;;

export default function AnimationSettingsSection({ value = {}, onChange }) {
    const playOnLoad = value.playOnLoad ?? true;

    const update = (patch) =&gt; onChange?.({ ...value, ...patch });

    return (
        &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4 items-start justify-center gap-1 sm:gap-2&quot;&gt;
            &lt;div className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;
                Animation Settings
            &lt;/div&gt;

            {/*Start on Load Switch*/}
            &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5&quot;&gt;
                &lt;div className=&quot;flex items-center justify-between w-full gap-2&quot;&gt;
                    &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;Start on Load&lt;/p&gt;
                    &lt;button
                        onClick={(e) =&gt; {
                            e.stopPropagation();
                            update({ playOnLoad: !playOnLoad });
                        }}
                        className={`relative w-[32px] h-[16px] rounded-full transition-colors duration-200 cursor-pointer focus:outline-none ${playOnLoad ? &apos;bg-BrandOrange&apos; : &apos;bg-BrandGray&apos;
                            }`}
                        aria-label=&quot;Toggle play on load&quot;
                    &gt;
                        &lt;span
                            className={`absolute top-1/2 left-0 transform -translate-y-1/2 transition-transform duration-200 w-[12px] h-[12px] bg-BrandBlack rounded-full shadow-sm ${playOnLoad ? &apos;translate-x-[18px]&apos; : &apos;translate-x-[3px]&apos;
                                }`}
                        /&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/advancedSettings/ExportVideoSettingsSection.jsx">import React, { useState, useRef, useEffect } from &apos;react&apos;;
import { FaChevronDown } from &quot;react-icons/fa&quot;;
import { FaCrown } from &quot;react-icons/fa6&quot;;

const VIDEO_QUALITY_OPTIONS = [&quot;360p&quot;, &quot;480p&quot;, &quot;720p&quot;, &quot;1080p&quot;, &quot;1440p&quot;, &quot;2160p (4K)&quot;];

export default function ExportVideoSettingsSection({ value = {}, onChange }) {
    const videoQuality = value.videoQuality ?? &quot;1080p&quot;;
    const watermark = value.watermark ?? true;
    const includeMetadata = value.includeMetadata ?? true;

    const [openVideoQualityDropdown, setOpenVideoQualityDropdown] = useState(false);
    const videoQualityRef = useRef(null);

    const update = (patch) =&gt; onChange?.({ ...value, ...patch });

    // Close video quality dropdown when clicking outside
    useEffect(() =&gt; {
        if (!openVideoQualityDropdown) return;

        const handleClickOutside = (e) =&gt; {
            if (videoQualityRef.current &amp;&amp; !videoQualityRef.current.contains(e.target)) {
                setOpenVideoQualityDropdown(false);
            }
        };

        document.addEventListener(&apos;mousedown&apos;, handleClickOutside);
        return () =&gt; {
            document.removeEventListener(&apos;mousedown&apos;, handleClickOutside);
        };
    }, [openVideoQualityDropdown]);

    return (
        &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4 items-start justify-center gap-1 sm:gap-2&quot;&gt;
            &lt;div className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;
                Export Video Settings
            &lt;/div&gt;

            {/* Video Quality Dropdown */}
            &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5 relative&quot;&gt;
                &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;Video Quality&lt;/p&gt;
                &lt;div
                    ref={videoQualityRef}
                    className=&quot;relative w-full&quot;
                &gt;
                    &lt;div
                        onClick={() =&gt; setOpenVideoQualityDropdown(!openVideoQualityDropdown)}
                        className=&quot;bg-BrandBlack2 h-5 sm:h-6 w-full flex flex-row items-center justify-between px-2 rounded-md cursor-pointer&quot;
                    &gt;
                        &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;{videoQuality}&lt;/p&gt;
                        &lt;FaChevronDown className={`text-BrandOrange text-xs transition-transform ${openVideoQualityDropdown ? &apos;rotate-180&apos; : &apos;&apos;}`} /&gt;
                    &lt;/div&gt;
                    {openVideoQualityDropdown &amp;&amp; (
                        &lt;div className=&quot;absolute left-0 top-full w-full bg-BrandBlack2 border border-BrandGray rounded-md mt-1 max-h-40 overflow-y-auto z-10 shadow-lg&quot;&gt;
                            {VIDEO_QUALITY_OPTIONS.map((quality, idx) =&gt; (
                                &lt;div
                                    key={idx}
                                    onClick={() =&gt; {
                                        update({ videoQuality: quality });
                                        setOpenVideoQualityDropdown(false);
                                    }}
                                    className={`px-2 py-1 text-xs sm:text-sm font-DmSans cursor-pointer transition-colors ${videoQuality === quality
                                        ? &apos;bg-BrandOrange text-BrandBlack&apos;
                                        : &apos;text-BrandWhite hover:bg-BrandBlack&apos;
                                        }`}
                                &gt;
                                    {quality}
                                &lt;/div&gt;
                            ))}
                        &lt;/div&gt;
                    )}
                &lt;/div&gt;
            &lt;/div&gt;

            {/* Watermark Switch */}
            &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5&quot;&gt;
                &lt;div className=&quot;flex items-center justify-between w-full gap-2&quot;&gt;
                    &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;Watermark&lt;/p&gt;
                    &lt;button
                        onClick={(e) =&gt; {
                            e.stopPropagation();
                            update({ watermark: !watermark });
                        }}
                        className={`relative w-[32px] h-[16px] rounded-full transition-colors duration-200 cursor-pointer focus:outline-none ${watermark ? &apos;bg-BrandOrange&apos; : &apos;bg-BrandGray&apos;
                            }`}
                        aria-label=&quot;Toggle watermark&quot;
                    &gt;
                        &lt;FaCrown
                            className={`absolute top-1/2 left-0 transform -translate-y-1/2 transition-transform duration-200 text-BrandBlack ${watermark ? &apos;translate-x-[18px]&apos; : &apos;translate-x-[3px]&apos;
                                } text-[10px] sm:text-[12px]`}
                        /&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            {/* Include Metadata Switch */}
            &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5&quot;&gt;
                &lt;div className=&quot;flex items-center justify-between w-full gap-2&quot;&gt;
                    &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;Include Metadata&lt;/p&gt;
                    &lt;button
                        onClick={(e) =&gt; {
                            e.stopPropagation();
                            update({ includeMetadata: !includeMetadata });
                        }}
                        className={`relative w-[32px] h-[16px] rounded-full transition-colors duration-200 cursor-pointer focus:outline-none ${includeMetadata ? &apos;bg-BrandOrange&apos; : &apos;bg-BrandGray&apos;
                            }`}
                        aria-label=&quot;Toggle include metadata&quot;
                    &gt;
                        &lt;span
                            className={`absolute top-1/2 left-0 transform -translate-y-1/2 transition-transform duration-200 w-[12px] h-[12px] bg-BrandBlack rounded-full shadow-sm ${includeMetadata ? &apos;translate-x-[18px]&apos; : &apos;translate-x-[3px]&apos;
                                }`}
                        /&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/advancedSettings/LoggerSettingsSection.jsx">import React from &quot;react&quot;;

export default function LoggerSettingsSection({ value = {}, onChange }) {
  const slate = value.slate ?? false;
  const controlPill = value.controlPill ?? false;
  const canvas = value.canvas ?? false;
  const sidebar = value.sidebar ?? false;

  const update = (patch) =&gt; onChange?.({ ...value, ...patch });

  const ToggleRow = ({ label, enabled, onToggle }) =&gt; (
    &lt;div className=&quot;flex items-center justify-between w-full gap-2&quot;&gt;
      &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;{label}&lt;/p&gt;
      &lt;button
        onClick={(e) =&gt; {
          e.stopPropagation();
          onToggle(!enabled);
        }}
        className={`relative w-[32px] h-[16px] rounded-full transition-colors duration-200 cursor-pointer focus:outline-none ${
          enabled ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandGray&quot;
        }`}
        aria-label={`Toggle ${label} logger`}
      &gt;
        &lt;span
          className={`absolute top-1/2 left-0 transform -translate-y-1/2 transition-transform duration-200 w-[12px] h-[12px] bg-BrandBlack rounded-full shadow-sm ${
            enabled ? &quot;translate-x-[18px]&quot; : &quot;translate-x-[3px]&quot;
          }`}
        /&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  );

  return (
    &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4 items-start justify-center gap-1 sm:gap-2&quot;&gt;
      &lt;div className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;
        Logging
      &lt;/div&gt;
      &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5&quot;&gt;
        &lt;ToggleRow label=&quot;Slate&quot; enabled={slate} onToggle={(v) =&gt; update({ slate: v })} /&gt;
        &lt;ToggleRow
          label=&quot;Control Pill&quot;
          enabled={controlPill}
          onToggle={(v) =&gt; update({ controlPill: v })}
        /&gt;
        &lt;ToggleRow label=&quot;Canvas&quot; enabled={canvas} onToggle={(v) =&gt; update({ canvas: v })} /&gt;
        &lt;ToggleRow label=&quot;Sidebar&quot; enabled={sidebar} onToggle={(v) =&gt; update({ sidebar: v })} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/advancedSettings/PitchSettingsSection.jsx">import React, { useState, useRef, useEffect } from &apos;react&apos;;
import { FaChevronDown } from &quot;react-icons/fa&quot;;

const PITCH_SIZE_OPTIONS = [&quot;Full Field&quot;, &quot;Half Pitch&quot;, &quot;Goal&quot;, &quot;Quarter Field&quot;];

const PITCH_COLOR_OPTIONS = [
    { name: &quot;Fresh Turf Green&quot;, hex: &quot;#4FA85D&quot; },
    { name: &quot;Practice Grass&quot;, hex: &quot;#CDE7D3&quot; },
    { name: &quot;Natural Grass&quot;, hex: &quot;#9FCC9F&quot; },
    { name: &quot;Stadium Grass&quot;, hex: &quot;#6FAF7B&quot; },
    { name: &quot;Pro Turf Green&quot;, hex: &quot;#3E8E5B&quot; },
    { name: &quot;Deep Field Green&quot;, hex: &quot;#1F5F3F&quot; },
    { name: &quot;Sand Beige&quot;, hex: &quot;#EFE6D8&quot; },
    { name: &quot;Clay Field&quot;, hex: &quot;#D8C3A5&quot; },
    { name: &quot;Chalk Line Blue&quot;, hex: &quot;#AFC9E8&quot; },
    { name: &quot;Tactical Blue&quot;, hex: &quot;#4A78A8&quot; },
];

export default function PitchSettingsSection({ value = {}, onChange }) {
    const showMarkings = value.showMarkings ?? true;
    const pitchSize = value.pitchSize ?? &quot;Full Field&quot;;
    const pitchColor = value.pitchColor ?? &quot;#4FA85D&quot;;

    const [openPitchColorDropdown, setOpenPitchColorDropdown] = useState(false);
    const [openPitchSizeDropdown, setOpenPitchSizeDropdown] = useState(false);
    const pitchColorRef = useRef(null);
    const pitchSizeRef = useRef(null);

    const selectedPitchColorName =
        PITCH_COLOR_OPTIONS.find((c) =&gt; c.hex.toLowerCase() === String(pitchColor).toLowerCase())?.name ?? &quot;Custom&quot;;

    const update = (patch) =&gt; onChange?.({ ...value, ...patch });

    // Close pitch color dropdown when clicking outside
    useEffect(() =&gt; {
        if (!openPitchColorDropdown) return;

        const handleClickOutside = (e) =&gt; {
            if (pitchColorRef.current &amp;&amp; !pitchColorRef.current.contains(e.target)) {
                setOpenPitchColorDropdown(false);
            }
        };

        document.addEventListener(&apos;mousedown&apos;, handleClickOutside);
        return () =&gt; {
            document.removeEventListener(&apos;mousedown&apos;, handleClickOutside);
        };
    }, [openPitchColorDropdown]);

    // Close pitch size dropdown when clicking outside
    useEffect(() =&gt; {
        if (!openPitchSizeDropdown) return;

        const handleClickOutside = (e) =&gt; {
            if (pitchSizeRef.current &amp;&amp; !pitchSizeRef.current.contains(e.target)) {
                setOpenPitchSizeDropdown(false);
            }
        };

        document.addEventListener(&apos;mousedown&apos;, handleClickOutside);
        return () =&gt; {
            document.removeEventListener(&apos;mousedown&apos;, handleClickOutside);
        };
    }, [openPitchSizeDropdown]);

    return (
        &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4 items-start justify-center gap-1 sm:gap-2&quot;&gt;
            &lt;div className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;
                Pitch Settings
            &lt;/div&gt;

            {/* Show Markings Switch */}
            &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5&quot;&gt;
                &lt;div className=&quot;flex items-center justify-between w-full gap-2&quot;&gt;
                    &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;Show Markings&lt;/p&gt;
                    &lt;button
                        onClick={(e) =&gt; {
                            e.stopPropagation();
                            update({ showMarkings: !showMarkings });
                        }}
                        className={`relative w-[32px] h-[16px] rounded-full transition-colors duration-200 cursor-pointer focus:outline-none ${showMarkings ? &apos;bg-BrandOrange&apos; : &apos;bg-BrandGray&apos;
                            }`}
                        aria-label=&quot;Toggle show markings&quot;
                    &gt;
                        &lt;span
                            className={`absolute top-1/2 left-0 transform -translate-y-1/2 transition-transform duration-200 w-[12px] h-[12px] bg-BrandBlack rounded-full shadow-sm ${showMarkings ? &apos;translate-x-[18px]&apos; : &apos;translate-x-[3px]&apos;
                                }`}
                        /&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            {/* Pitch Size */}
            &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5 relative&quot;&gt;
                &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;Pitch Size&lt;/p&gt;
                &lt;div
                    ref={pitchSizeRef}
                    className=&quot;relative w-full&quot;
                &gt;
                    &lt;div
                        onClick={() =&gt; setOpenPitchSizeDropdown(!openPitchSizeDropdown)}
                        className=&quot;bg-BrandBlack2 h-5 sm:h-6 w-full flex flex-row items-center justify-between px-2 rounded-md cursor-pointer&quot;
                    &gt;
                        &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;{pitchSize}&lt;/p&gt;
                        &lt;FaChevronDown className={`text-BrandOrange text-xs transition-transform ${openPitchSizeDropdown ? &apos;rotate-180&apos; : &apos;&apos;}`} /&gt;
                    &lt;/div&gt;
                    {openPitchSizeDropdown &amp;&amp; (
                        &lt;div className=&quot;absolute left-0 top-full w-full bg-BrandBlack2 border border-BrandGray rounded-md mt-1 max-h-40 overflow-y-auto z-10 shadow-lg&quot;&gt;
                            {PITCH_SIZE_OPTIONS.map((size, idx) =&gt; (
                                &lt;div
                                    key={idx}
                                    onClick={() =&gt; {
                                        update({ pitchSize: size });
                                        setOpenPitchSizeDropdown(false);
                                    }}
                                    className={`px-2 py-1 text-xs sm:text-sm font-DmSans cursor-pointer transition-colors ${pitchSize === size
                                        ? &apos;bg-BrandOrange text-BrandBlack&apos;
                                        : &apos;text-BrandWhite hover:bg-BrandBlack&apos;
                                        }`}
                                &gt;
                                    {size}
                                &lt;/div&gt;
                            ))}
                        &lt;/div&gt;
                    )}
                &lt;/div&gt;
            &lt;/div&gt;

            {/* Pitch Color */}
            &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5 relative&quot;&gt;
                &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;Pitch Color&lt;/p&gt;
                &lt;div
                    ref={pitchColorRef}
                    className=&quot;relative w-full&quot;
                &gt;
                    &lt;div
                        onClick={() =&gt; setOpenPitchColorDropdown(!openPitchColorDropdown)}
                        className=&quot;bg-BrandBlack2 h-5 sm:h-6 w-full flex flex-row items-center justify-between px-2 rounded-md cursor-pointer&quot;
                    &gt;
                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                            &lt;div
                                className=&quot;w-3 h-3 sm:w-4 sm:h-4 rounded border border-BrandGray shrink-0&quot;
                                style={{ backgroundColor: pitchColor }}
                            /&gt;
                            &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans truncate&quot;&gt;{selectedPitchColorName}&lt;/p&gt;
                        &lt;/div&gt;
                        &lt;FaChevronDown className={`text-BrandOrange text-xs transition-transform shrink-0 ${openPitchColorDropdown ? &apos;rotate-180&apos; : &apos;&apos;}`} /&gt;
                    &lt;/div&gt;
                    {openPitchColorDropdown &amp;&amp; (
                        &lt;div className=&quot;absolute left-0 top-full w-full bg-BrandBlack2 border border-BrandGray rounded-md mt-1 max-h-60 overflow-y-auto z-10 shadow-lg&quot;&gt;
                            {PITCH_COLOR_OPTIONS.map((color, idx) =&gt; (
                                &lt;div
                                    key={idx}
                                    onClick={() =&gt; {
                                        update({ pitchColor: color.hex });
                                        setOpenPitchColorDropdown(false);
                                    }}
                                    className={`px-2 py-1.5 text-xs sm:text-sm font-DmSans cursor-pointer transition-colors flex items-center gap-2 ${pitchColor === color.hex
                                        ? &apos;bg-BrandOrange text-BrandBlack&apos;
                                        : &apos;text-BrandWhite hover:bg-BrandBlack&apos;
                                        }`}
                                &gt;
                                    &lt;div
                                        className=&quot;w-3 h-3 sm:w-4 sm:h-4 rounded border border-BrandGray shrink-0&quot;
                                        style={{ backgroundColor: color.hex }}
                                    /&gt;
                                    &lt;div className=&quot;flex flex-col flex-1 min-w-0&quot;&gt;
                                        &lt;span className=&quot;truncate&quot;&gt;{color.name}&lt;/span&gt;
                                        &lt;span className={`text-[10px] ${pitchColor === color.hex ? &apos;text-BrandBlack/70&apos; : &apos;text-BrandGray&apos;}`}&gt;{color.hex}&lt;/span&gt;
                                    &lt;/div&gt;
                                &lt;/div&gt;
                            ))}
                        &lt;/div&gt;
                    )}
                &lt;/div&gt;

                {/* Input below pitch color */}
                &lt;input
                    type=&quot;text&quot;
                    value={pitchColor}
                    onChange={(e) =&gt; {
                        update({ pitchColor: e.target.value });
                    }}
                    className=&quot;w-full h-6 sm:h-7 bg-BrandBlack2 border-[0.5px] border-BrandGray text-BrandWhite rounded-md px-2 text-xs sm:text-sm focus:outline-none focus:border-BrandOrange transition-colors&quot;
                    placeholder=&quot;#4FA85D&quot;
                /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/advancedSettings/PlayerSettingsSection.jsx">import React from &apos;react&apos;;
import { Slider } from &apos;@mui/material&apos;;

export default function PlayerSettingsSection({ value = {}, onChange }) {
    const playerBaseSizePx = value.baseSizePx ?? 30;

    const update = (patch) =&gt; onChange?.({ ...value, ...patch });

    return (
        &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4 items-start justify-center gap-1 sm:gap-2&quot;&gt;
            &lt;div className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;
                Player Settings
            &lt;/div&gt;

            {/* Default Player Size */}
            &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-1 sm:gap-1.5&quot;&gt;
                &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;Default Player Size (px)&lt;/p&gt;
                &lt;div className=&quot;w-full px-1 flex flex-row gap-1 px-1 justify-between&quot;&gt;
                    &lt;Slider
                        min={10}
                        max={50}
                        step={1}
                        value={playerBaseSizePx}
                        onChange={(_, newValue) =&gt; update({ baseSizePx: Array.isArray(newValue) ? newValue[0] : newValue })}
                        className=&quot;flex-1&quot;
                        sx={{
                            color: &apos;#FF7A18&apos;,
                            height: &apos;4px&apos;,
                            &apos;&amp; .MuiSlider-thumb&apos;: {
                                width: &apos;10px&apos;,
                                height: &apos;10px&apos;,
                                backgroundColor: &apos;#FF7A18&apos;,
                                boxShadow: &apos;0 2px 4px rgba(0, 0, 0, 0.2)&apos;,
                                &apos;&amp;:hover&apos;: {
                                    boxShadow: &apos;0 4px 8px rgba(0, 0, 0, 0.3)&apos;,
                                },
                                &apos;&amp;:focus, &amp;:active, &amp;.Mui-focusVisible&apos;: {
                                    outline: &apos;none&apos;,
                                    boxShadow: &apos;0 2px 4px rgba(0, 0, 0, 0.2)&apos;,
                                },
                            },
                            &apos;&amp; .MuiSlider-track&apos;: {
                                backgroundColor: &apos;#FF7A18&apos;,
                                height: &apos;4px&apos;,
                                border: &apos;none&apos;,
                            },
                            &apos;&amp; .MuiSlider-rail&apos;: {
                                backgroundColor: &apos;#75492a&apos;,
                                height: &apos;4px&apos;,
                                opacity: 1,
                            },
                        }}
                    /&gt;
                    &lt;div className=&quot;flex flex-row bg-BrandBlack2 h-5 sm:h-6 w-14 items-center justify-center px-2 rounded-md&quot;&gt;
                        &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-DmSans&quot;&gt;{playerBaseSizePx}px&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/advancedSettings/README.md"># Advanced Settings (`src/components/advancedSettings/`)

This folder contains the **Advanced Settings panel** and its section components. The Advanced Settings panel is a full-height sidebar that appears on the right side of the screen when opened, providing access to pitch, player, export video, and animation configuration options.

## High-level behavior

- **Fixed-width, full-height panel**: `AdvancedSettings.jsx` renders an absolute positioned panel that is `h-screen` and uses flex column layout.
- **Scrollable content + pinned footer**:
- The **main content** (pitch settings, player settings, export video settings, animation settings, save prefab button) lives inside a **scroll container**.
  - The **Reset to Default** button lives in a **non-scrolling footer** at the bottom.
- **Close button**: A close button is positioned to the left of the panel.

This is implemented by splitting the panel into:

- **Scrollable area**: `flex-1 shrink-0 overflow-y-auto`
- **Footer**: `shrink-0` (so it never gets pushed off-screen)

You can see this in `AdvancedSettings.jsx`.

## Data flow (where state comes from)

`AdvancedSettings.jsx` itself is a **layout/composition** component. State is owned by `src/App.jsx` and passed down as props:

- **Settings object**: `value` (object with `pitch`, `players`, `exportVideo`, `animation` sections)
- **Update callback**: `onChange(nextSettings)` - called when any section updates
- **Reset callback**: `onReset()` - resets all settings to defaults
- **Close callback**: `onClose()` - closes the panel

Each section component receives only its relevant slice of the settings object and an `onChange` callback that updates that specific section.

## Settings structure

The settings object has the following structure:

```javascript
{
  pitch: {
    showMarkings: boolean,      // Toggle field markings visibility
    pitchSize: string,          // &quot;Full Field&quot; | &quot;Half Pitch&quot; | &quot;Goal&quot; | &quot;Quarter Field&quot;
    pitchColor: string,         // Hex color code (e.g., &quot;#4FA85D&quot;)
  },
  players: {
    baseSizePx: number,         // Default player size in pixels (10-50)
  },
  exportVideo: {
    videoQuality: string,       // &quot;360p&quot; | &quot;480p&quot; | &quot;720p&quot; | &quot;1080p&quot; | &quot;1440p&quot; | &quot;2160p (4K)&quot;
    watermark: boolean,         // Toggle watermark on exported videos
    includeMetadata: boolean,   // Toggle metadata inclusion in exports
  },
  animation: {
    playOnLoad: boolean,         // Auto-play animation on load
  },
}
```

## Section-by-section

### `PitchSettingsSection.jsx`

Controls for the rugby field appearance:

- **Show Markings**: Toggle switch to show/hide the field markings image
- **Pitch Size**: Dropdown to select field scale (&quot;Full Field&quot;, &quot;Half Pitch&quot;, &quot;Goal&quot;, &quot;Quarter Field&quot;)
- **Pitch Color**: 
  - Dropdown with predefined color options (shows color swatch + name)
  - Hex input field for custom colors
  - Automatically detects if the current color matches a predefined option

**Props:**
- `value` (object): `{ showMarkings, pitchSize, pitchColor }`
- `onChange(nextValue)`: Updates the pitch settings

**Constants:**
- `PITCH_SIZE_OPTIONS`: Array of available pitch size options
- `PITCH_COLOR_OPTIONS`: Array of `{ name, hex }` objects for predefined colors

### `PlayerSettingsSection.jsx`

Controls for default player appearance:

- **Default Player Size (px)**: 
  - Slider (10-50px range) + number input
  - This is the &quot;base&quot; size that the Right Panel&apos;s size percentage scales from

**Props:**
- `value` (object): `{ baseSizePx }`
- `onChange(nextValue)`: Updates the player settings

**Note:** The Right Panel&apos;s &quot;All Players&quot; section controls `sizePercent` (which scales from this base), `color`, `showNumber`, and `showName`. Those controls are intentionally kept in the Right Panel, not Advanced Settings.

### `ExportVideoSettingsSection.jsx`

Controls for video export configuration (settings are stored but not yet implemented):

- **Video Quality**: Dropdown to select export resolution
- **Watermark**: Toggle switch (uses crown icon when enabled)
- **Include Metadata**: Toggle switch

**Props:**
- `value` (object): `{ videoQuality, watermark, includeMetadata }`
- `onChange(nextValue)`: Updates the export video settings

**Constants:**
- `VIDEO_QUALITY_OPTIONS`: Array of available quality options

### `AnimationSettingsSection.jsx`

Controls for animation behavior (settings are stored but not yet fully implemented):

- **Start on Load**: Toggle switch to auto-play animation when loaded

**Props:**
- `value` (object): `{ playOnLoad }`
- `onChange(nextValue)`: Updates the animation settings

### `SavePrefabButton.jsx`

- Presentational button: “Save Current Frame as Prefab”.
- Lives in the Advanced Settings scroll area and is intentionally not wired yet.

## How settings affect the canvas

### Pitch Settings

- **Pitch Color**: Applied as the canvas background color via `BoardViewport` style prop
- **Show Markings**: Controls visibility of `FieldLayer` (returns `null` when false)
- **Pitch Size**: Scales the field image via CSS transform (different scale factors for each size option)

These are wired in:
- `src/canvas/CanvasRoot.jsx` - extracts pitch settings and passes to `BoardViewport` and `FieldLayer`
- `src/canvas/BoardViewport.jsx` - accepts `style` prop for background color
- `src/canvas/FieldLayer.jsx` - accepts `showMarkings` and `pitchSize` props

### Player Settings

- **Base Size (px)**: Used as the base pixel size in `ItemVisual.jsx` when calculating player render size
  - Formula: `sizePx = Math.max(6, Math.round((basePx * sizePercent) / 100))`
  - The Right Panel&apos;s `sizePercent` (from `allPlayersDisplay`) scales from this base

This is wired in:
- `src/canvas/CanvasRoot.jsx` - extracts `playerBaseSizePx` and passes to `ItemsLayer`
- `src/canvas/ItemsLayer.jsx` - passes `playerBaseSizePx` to `ItemVisual`
- `src/canvas/ItemVisual.jsx` - uses `playerBaseSizePx` instead of hardcoded `30`

### Export Video &amp; Animation Settings

These settings are stored in App state but **not yet implemented** in the actual export/animation logic. They are ready for future implementation.

## Common patterns

### Dropdown menus

Both `PitchSettingsSection` and `ExportVideoSettingsSection` use dropdown menus with click-outside-to-close behavior:

1. Use `useRef` to track the dropdown container
2. Use `useState` to track open/closed state
3. Use `useEffect` to add/remove click-outside listener when open
4. Dropdowns are absolutely positioned below the trigger button

### Toggle switches

All sections use consistent toggle switch styling:
- 32px width, 16px height
- Orange when on, gray when off
- Smooth transition animations
- Accessible with `aria-label`

### Sliders

`PlayerSettingsSection` uses MUI `Slider` with:
- Consistent styling (orange theme matching ControlPill)
- Number input alongside for direct value entry
- Min/max validation

## Default values

Default settings are defined in `src/App.jsx` as `DEFAULT_ADVANCED_SETTINGS`:

```javascript
{
  pitch: {
    showMarkings: true,
    pitchSize: &quot;Full Field&quot;,
    pitchColor: &quot;#4FA85D&quot;, // Stadium Grass
  },
  players: {
    baseSizePx: 30,
  },
  exportVideo: {
    videoQuality: &quot;1080p&quot;,
    watermark: true,
    includeMetadata: true,
  },
  animation: {
    playOnLoad: true,
  },
}
```

The &quot;Reset to Default&quot; button calls `onReset()` which sets the entire settings object back to these defaults.</file><file path="src/components/controlPill/ControlPill.jsx">import React, { useState, useEffect, useRef } from &apos;react&apos;;
import TimePill from &apos;./TimePill&apos;;
import SpeedSlider from &apos;./SpeedSlider&apos;;
import PlaybackControls from &apos;./PlaybackControls&apos;;
import KeyframeManager from &apos;./KeyframeManager&apos;;
import DropdownMenu from &apos;./DropdownMenu&apos;;

const MAX_KEYFRAMES = 30;
const MIN_KEYFRAME_DISTANCE = 2;

/**
 * ControlPill - Main timeline control component
 * Manages timeline state, playback, keyframes, and exposes state via callbacks
 */
export default function ControlPill({
  // Callbacks for state changes (exposed to parent)
  onTimePercentChange,
  onKeyframesChange,
  onSpeedChange,
  onPlayStateChange,
  onSelectedKeyframeChange,
  onAutoplayChange,
  onKeyframeAddAttempt,
  // Optional: External control
  externalTimePercent,
  externalIsPlaying,
  externalSpeed,
  externalSelectedKeyframe,
  externalAutoplayEnabled,
  // Optional: external signal to add a keyframe at current time
  addKeyframeSignal,
  onRequestAddKeyframe,
}) {
  // Core state
  const [keyframes, setKeyframes] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [autoplayEnabled, setAutoplayEnabled] = useState(true);

  // Undo/Redo state
  const [actionHistory, setActionHistory] = useState([]);
  const [redoHistory, setRedoHistory] = useState([]);

  const timePercent = externalTimePercent ?? 0;
  const isPlaying = externalIsPlaying ?? false;
  const speedMultiplier = externalSpeed ?? 50;
  const selectedKeyframe = externalSelectedKeyframe ?? null;
  const isAutoplayEnabled = externalAutoplayEnabled ?? autoplayEnabled;

  const lastKeyframeSignal = useRef(addKeyframeSignal);
  const latestTimePercentRef = useRef(externalTimePercent ?? 0);

  useEffect(() =&gt; {
    latestTimePercentRef.current = externalTimePercent ?? timePercent;
  }, [externalTimePercent, timePercent]);

  // Notify parent of keyframes changes
  useEffect(() =&gt; {
    onKeyframesChange?.(keyframes);
  }, [keyframes, onKeyframesChange]);


  // Handle time change
  const handleTimeChange = (newPercent) =&gt; {
    onSelectedKeyframeChange?.(null);
    onPlayStateChange?.(false);
    onTimePercentChange?.(newPercent);
  };

  // Handle drag start
  const handleDragStart = () =&gt; {
    setIsDragging(true);
    onPlayStateChange?.(false); // Pause when dragging
  };

  // Handle drag end
  const handleDragEnd = () =&gt; {
    setIsDragging(false);
  };

  // Handle speed change
  const handleSpeedChange = (newSpeed) =&gt; {
    onSpeedChange?.(newSpeed);
  };

  // Handle play toggle
  const handlePlayToggle = () =&gt; {
    if (!isPlaying &amp;&amp; timePercent &gt;= 100) {
      onTimePercentChange?.(0);
    }
    onPlayStateChange?.(!isPlaying);
  };

  const jumpToTime = (nextTime) =&gt; {
    if (keyframes.includes(nextTime)) {
      onSelectedKeyframeChange?.(nextTime);
      onTimePercentChange?.(nextTime);
      return;
    }
    onSelectedKeyframeChange?.(null);
    onTimePercentChange?.(nextTime);
  };

  const getSortedKeyframes = () =&gt; [...keyframes].sort((a, b) =&gt; a - b);

  // Handle skip back (previous keyframe or start)
  const handleSkipBack = () =&gt; {
    const sorted = getSortedKeyframes();
    if (sorted.length === 0) {
      jumpToTime(0);
      return;
    }
    const EPS = 0.001;
    const previous = [...sorted].reverse().find((kf) =&gt; kf &lt; timePercent - EPS);
    if (previous !== undefined) {
      jumpToTime(previous);
      return;
    }
    jumpToTime(0);
  };

  // Handle skip forward (next keyframe or end)
  const handleSkipForward = () =&gt; {
    const sorted = getSortedKeyframes();
    if (sorted.length === 0) {
      jumpToTime(100);
      return;
    }
    const EPS = 0.001;
    const next = sorted.find((kf) =&gt; kf &gt; timePercent + EPS);
    if (next !== undefined) {
      jumpToTime(next);
      return;
    }
    jumpToTime(100);
  };

  // Handle adding a keyframe at current time position
  const addKeyframeAtTime = (timePercentValue) =&gt; {
    // Limit maximum keyframes
    if (keyframes.length &gt;= MAX_KEYFRAMES) {
      onKeyframeAddAttempt?.({
        added: false,
        reason: &quot;max&quot;,
        timePercent: timePercentValue,
        keyframes: [...keyframes],
        maxKeyframes: MAX_KEYFRAMES,
      });
      return;
    }

    // Check if keyframe already exists at this position (within tolerance)
    const existingKeyframe = keyframes.find(
      (kf) =&gt; Math.abs(kf - timePercentValue) &lt; MIN_KEYFRAME_DISTANCE
    );

    if (!existingKeyframe) {
      // Clear redo history when making new changes
      setRedoHistory([]);
      // Add keyframe
      const newKeyframes = [...keyframes, timePercentValue].sort((a, b) =&gt; a - b);
      setKeyframes(newKeyframes);
      // Record the action for undo
      setActionHistory([...actionHistory, { type: &quot;add&quot;, keyframe: timePercentValue }]);
      onKeyframeAddAttempt?.({
        added: true,
        reason: &quot;added&quot;,
        timePercent: timePercentValue,
        keyframes: newKeyframes,
      });
      return;
    }
    onSelectedKeyframeChange?.(existingKeyframe);
    onTimePercentChange?.(existingKeyframe);
    onKeyframeAddAttempt?.({
      added: false,
      reason: &quot;too-close&quot;,
      timePercent: timePercentValue,
      keyframes: [...keyframes],
      minDistance: MIN_KEYFRAME_DISTANCE,
      selectedKeyframe: existingKeyframe,
    });
  };

  const handleAddKeyframe = (e) =&gt; {
    e.stopPropagation(); // Prevent triggering pill click
    if (onRequestAddKeyframe) {
      onRequestAddKeyframe();
      return;
    }
    const currentTime = externalTimePercent ?? timePercent;
    addKeyframeAtTime(currentTime);
  };

  // Handle clicking on a keyframe
  const handleKeyframeClick = (e, timePercentValue) =&gt; {
    e.stopPropagation(); // Prevent triggering pill click
    if (selectedKeyframe === timePercentValue) {
      onSelectedKeyframeChange?.(null); // Deselect if already selected
    } else {
      onSelectedKeyframeChange?.(timePercentValue); // Select this keyframe
      onTimePercentChange?.(timePercentValue);
    }
  };

  // Handle deleting selected keyframe
  const handleDeleteKeyframe = (e) =&gt; {
    e.stopPropagation(); // Prevent triggering pill click
    if (selectedKeyframe !== null) {
      const deletedKeyframe = selectedKeyframe;
      // Clear redo history when making new changes
      setRedoHistory([]);
      // Remove keyframe
      setKeyframes(keyframes.filter(kf =&gt; kf !== deletedKeyframe));
      onSelectedKeyframeChange?.(null);
      // Record the action for undo
      setActionHistory([...actionHistory, { type: &apos;delete&apos;, keyframe: deletedKeyframe }]);
    }
  };

  // Handle trash button - remove all keyframes
  const handleTrash = (e) =&gt; {
    e.stopPropagation();
    if (keyframes.length &gt; 0) {
      // Clear redo history when making new changes
      setRedoHistory([]);
      // Record all deletions as a single clear action
      const allKeyframes = [...keyframes];
      setKeyframes([]);
      onSelectedKeyframeChange?.(null);
      // Record the clear action for undo
      setActionHistory([...actionHistory, { type: &apos;clear&apos;, keyframes: allKeyframes }]);
    }
  };

  // Handle undo - reverse the last action
  const handleUndo = (e) =&gt; {
    e.stopPropagation();
    if (actionHistory.length &gt; 0) {
      const lastAction = actionHistory[actionHistory.length - 1];
      const newActionHistory = actionHistory.slice(0, -1);

      // Reverse the action
      if (lastAction.type === &apos;add&apos;) {
        // Undo add: remove the keyframe
        const newKeyframes = keyframes.filter(kf =&gt; kf !== lastAction.keyframe);
        setKeyframes(newKeyframes);
        if (selectedKeyframe === lastAction.keyframe) {
          onSelectedKeyframeChange?.(null);
        }
        // Add reversed action to redo history
        setRedoHistory([...redoHistory, { type: &apos;delete&apos;, keyframe: lastAction.keyframe }]);
      } else if (lastAction.type === &apos;delete&apos;) {
        // Undo delete: add the keyframe back
        const newKeyframes = [...keyframes, lastAction.keyframe].sort((a, b) =&gt; a - b);
        setKeyframes(newKeyframes);
        // Add reversed action to redo history
        setRedoHistory([...redoHistory, { type: &apos;add&apos;, keyframe: lastAction.keyframe }]);
      } else if (lastAction.type === &apos;clear&apos;) {
        // Undo clear: restore all keyframes
        setRedoHistory([...redoHistory, { type: &apos;clear&apos;, keyframes: lastAction.keyframes }]);
        setKeyframes(lastAction.keyframes);
      }

      setActionHistory(newActionHistory);
    }
  };

  // Handle redo - re-apply the last undone action
  const handleRedo = (e) =&gt; {
    e.stopPropagation();
    if (redoHistory.length &gt; 0) {
      const lastRedoAction = redoHistory[redoHistory.length - 1];
      const newRedoHistory = redoHistory.slice(0, -1);

      // Re-apply the action
      if (lastRedoAction.type === &apos;add&apos;) {
        // Redo add: add the keyframe
        const newKeyframes = [...keyframes, lastRedoAction.keyframe].sort((a, b) =&gt; a - b);
        setKeyframes(newKeyframes);
        // Add action back to undo history
        setActionHistory([...actionHistory, { type: &apos;add&apos;, keyframe: lastRedoAction.keyframe }]);
      } else if (lastRedoAction.type === &apos;delete&apos;) {
        // Redo delete: remove the keyframe
        const newKeyframes = keyframes.filter(kf =&gt; kf !== lastRedoAction.keyframe);
        setKeyframes(newKeyframes);
        if (selectedKeyframe === lastRedoAction.keyframe) {
          onSelectedKeyframeChange?.(null);
        }
        // Add action back to undo history
        setActionHistory([...actionHistory, { type: &apos;delete&apos;, keyframe: lastRedoAction.keyframe }]);
      } else if (lastRedoAction.type === &apos;clear&apos;) {
        // Redo clear: save current state, then clear
        const currentKeyframes = [...keyframes];
        setKeyframes([]);
        onSelectedKeyframeChange?.(null);
        // Add action back to undo history with the keyframes that were cleared
        setActionHistory([...actionHistory, { type: &apos;clear&apos;, keyframes: currentKeyframes }]);
      }

      setRedoHistory(newRedoHistory);
    }
  };

  // Handle autoplay toggle
  const handleAutoplayToggle = () =&gt; {
    const newAutoplayState = !isAutoplayEnabled;
    if (externalAutoplayEnabled === undefined) {
      setAutoplayEnabled(newAutoplayState);
    }
    onAutoplayChange?.(newAutoplayState);
    // When autoplay is turned off, return to start
    if (!newAutoplayState) {
      onTimePercentChange?.(0);
      onPlayStateChange?.(false);
    }
  };

  // Add a keyframe when the parent explicitly requests it
  useEffect(() =&gt; {
    if (addKeyframeSignal === undefined) return;
    if (addKeyframeSignal === lastKeyframeSignal.current) return;
    lastKeyframeSignal.current = addKeyframeSignal;
    addKeyframeAtTime(latestTimePercentRef.current);
  }, [addKeyframeSignal]);

  return (
    &lt;&gt;
      {/* Slate Time controller and keyframes */}
      &lt;div className={`aspect-[641/124] h-[62.5px] sm:h-[75px] md:h-[100px] lg:h-[125px]
                        flex flex-col items-center justify-between gap-[3.125px] sm:gap-[6.25px] 
                        bg-BrandBlack
                         py-[3.125px] sm:py-[6.25px] px-[12.5px] sm:px-[15.625px] md:px-[18.75px]
                        rounded-[25px] sm:rounded-[28.125px] md:rounded-[31.25px] 
                        select-none z-50
                        absolute left-1/2 transform -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ${isDropdownOpen ? &apos;top-[84%]&apos; : &apos;top-[87%]   &apos;
        }`}&gt;
        {/* Time pill */}
        &lt;TimePill
          timePercent={timePercent}
          onTimeChange={handleTimeChange}
          keyframes={keyframes}
          selectedKeyframe={selectedKeyframe}
          onKeyframeClick={handleKeyframeClick}
          onDragStart={handleDragStart}
          onDragEnd={handleDragEnd}
          isDragging={isDragging}
        /&gt;

        {/* Time slide with time display, play buttons and keyframe button */}
        &lt;div className=&quot;flex flex-1 w-full items-center justify-between gap-[3.125px] sm:gap-[6.25px]&quot;&gt;
          {/* Speed slider */}
          &lt;SpeedSlider
            speedMultiplier={speedMultiplier}
            onSpeedChange={handleSpeedChange}
          /&gt;

          {/* Playback controls */}
          &lt;PlaybackControls
            isPlaying={isPlaying}
            onPlayToggle={handlePlayToggle}
            onSkipBack={handleSkipBack}
            onSkipForward={handleSkipForward}
          /&gt;

          {/* Keyframe manager */}
          &lt;KeyframeManager
            selectedKeyframe={selectedKeyframe}
            onAddKeyframe={handleAddKeyframe}
            onDeleteKeyframe={handleDeleteKeyframe}
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Dropdown menu */}
      &lt;DropdownMenu
        isOpen={isDropdownOpen}
        onToggle={() =&gt; setIsDropdownOpen(!isDropdownOpen)}
        onTrash={handleTrash}
        onUndo={handleUndo}
        onRedo={handleRedo}
        autoplayEnabled={isAutoplayEnabled}
        onAutoplayToggle={handleAutoplayToggle}
        canUndo={actionHistory.length &gt; 0}
        canRedo={redoHistory.length &gt; 0}
      /&gt;
    &lt;/&gt;
  );
}</file><file path="src/components/controlPill/DropdownMenu.jsx">import React from &apos;react&apos;;
import { FaChevronDown, FaTimes } from &quot;react-icons/fa&quot;;
import { BiUndo } from &quot;react-icons/bi&quot;;
import { BiRedo } from &quot;react-icons/bi&quot;;
import { FaRegTrashCan } from &quot;react-icons/fa6&quot;;

/**
 * DropdownMenu - Settings dropdown with trash, undo, redo, and autoplay controls
 */
export default function DropdownMenu({
  isOpen,
  onToggle,
  onTrash,
  onUndo,
  onRedo,
  autoplayEnabled,
  onAutoplayToggle,
  canUndo,
  canRedo,
}) {
  if (!isOpen) {
    return (
      &lt;div
        onClick={onToggle}
        className=&quot;absolute top-[97.5%] select-none left-1/2 transform -translate-x-1/2 -translate-y-1/2 h-[25px] w-[25px] bg-BrandBlack rounded-full border-[0.625px] border-BrandGray flex items-center justify-center cursor-pointer hover:bg-BrandBlack2 transition-colors&quot;
      &gt;
        &lt;FaChevronDown className=&quot;text-BrandOrange text-[12.5px] sm:text-[12.5px] md:text-[12.5px] font-DmSans&quot; /&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;absolute top-[96.5%] left-1/2 select-none transform -translate-x-1/2 -translate-y-1/2 h-[40px] bg-BrandBlack rounded-full border-[0.625px] border-BrandGray flex items-center gap-[12px] px-[12px]&quot;&gt;
      {/* Trash icon */}
      &lt;FaRegTrashCan
        onClick={onTrash}
        className=&quot;text-BrandOrange text-[12.5px] sm:text-[12.5px] md:text-[18px] font-DmSans cursor-pointer hover:opacity-80 transition-opacity&quot;
      /&gt;

      {/* Undo icon */}
      &lt;BiUndo
        onClick={onUndo}
        className={`text-BrandOrange text-[12.5px] sm:text-[12.5px] md:text-[18px] font-DmSans cursor-pointer hover:opacity-80 transition-opacity ${!canUndo ? &apos;opacity-50 cursor-not-allowed&apos; : &apos;&apos;}`}
      /&gt;

      {/* Redo icon */}
      &lt;BiRedo
        onClick={onRedo}
        className={`text-BrandOrange text-[12.5px] sm:text-[12.5px] md:text-[18px] font-DmSans cursor-pointer hover:opacity-80 transition-opacity ${!canRedo ? &apos;opacity-50 cursor-not-allowed&apos; : &apos;&apos;}`}
      /&gt;

      {/* Autoplay pill switch */}
      &lt;div className=&quot;flex items-center gap-[8px]&quot;&gt;
        &lt;span className=&quot;text-BrandGray text-[10px] sm:text-[12px] md:text-[14px] font-DmSans whitespace-nowrap&quot;&gt;Autoplay&lt;/span&gt;
        &lt;button
          onClick={(e) =&gt; {
            e.stopPropagation();
            onAutoplayToggle();
          }}
          className={`relative w-[40px] h-[20px] rounded-full transition-colors duration-200 cursor-pointer focus:outline-none ${autoplayEnabled ? &apos;bg-BrandOrange&apos; : &apos;bg-BrandGray&apos;
            }`}
          aria-label=&quot;Toggle autoplay&quot;
        &gt;
          &lt;span
            className={`absolute top-1/2 left-0 transform -translate-y-1/2 transition-transform duration-200 w-[16px] h-[16px] bg-BrandBlack rounded-full shadow-sm ${autoplayEnabled ? &apos;translate-x-[22px]&apos; : &apos;translate-x-[4px]&apos;
              }`}
          /&gt;
        &lt;/button&gt;
      &lt;/div&gt;

      {/* Close button (X) */}
      &lt;FaTimes
        onClick={onToggle}
        className=&quot;text-BrandOrange text-[14px] sm:text-[14px] md:text-[18px] font-DmSans cursor-pointer hover:opacity-80 transition-opacity ml-[4px]&quot;
      /&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/controlPill/KeyframeDisplay.jsx">import React from &apos;react&apos;;
import SelectedKeyframeIcon from &quot;../../assets/keyframes/Selected Key Frame.png&quot;;
import UnselectedKeyframeIcon from &quot;../../assets/keyframes/Unselected Key Frame.png&quot;;

/**
 * KeyframeDisplay - Displays keyframe icons on the timeline
 */
export default function KeyframeDisplay({
  keyframes = [],
  selectedKeyframe = null,
  onKeyframeClick,
}) {
  // Convert timePercent (0-100) to visual position percentage (3-97%)
  const timePercentToVisualPosition = (timePercent) =&gt; {
    return 3 + (timePercent / 100) * 94;
  };

  return (
    &lt;&gt;
      {keyframes.map((kfTimePercent, idx) =&gt; {
        const visualPos = timePercentToVisualPosition(kfTimePercent);
        const isSelected = selectedKeyframe === kfTimePercent;
        return (
          &lt;img
            key={`kf-${kfTimePercent}-${idx}`}
            src={isSelected ? SelectedKeyframeIcon : UnselectedKeyframeIcon}
            alt=&quot;keyframe&quot;
            draggable={false}
            onClick={(e) =&gt; onKeyframeClick(e, kfTimePercent)}
            className=&quot;absolute z-30 cursor-pointer&quot;
            style={{
              left: `${visualPos}%`,
              top: &quot;50%&quot;,
              transform: &quot;translate(-50%, -50%)&quot;,
              width: &quot;25px&quot;,
              height: &quot;25px&quot;,
              objectFit: &quot;contain&quot;,
              pointerEvents: &quot;auto&quot;,
            }}
          /&gt;
        );
      })}
    &lt;/&gt;
  );
}</file><file path="src/components/controlPill/KeyframeManager.jsx">import React from &apos;react&apos;;

/**
 * KeyframeManager - Button to add or delete keyframes
 */
export default function KeyframeManager({
  selectedKeyframe,
  onAddKeyframe,
  onDeleteKeyframe,
}) {
  return (
    &lt;div
      onClick={selectedKeyframe !== null ? onDeleteKeyframe : onAddKeyframe}
      className=&quot;w-200/641 h-[16px] sm:h-[22px] md:h-[24px] lg:h-[32px] bg-BrandOrange flex flex-row items-center justify-center rounded-xl px-[6.25px] sm:px-[9.375px] cursor-pointer&quot;
    &gt;
      &lt;p className=&quot;text-BrandBlack text-[10px] sm:text-[12px] md:text-[15px] lg:text-[17.5px] font-DmSans&quot;&gt;
        {selectedKeyframe !== null ? &quot;Delete Keyframe&quot; : &quot;Add Keyframe&quot;}
      &lt;/p&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/controlPill/PlaybackControls.jsx">import React from &apos;react&apos;;
import { IoPlayOutline } from &quot;react-icons/io5&quot;;
import { IoPlaySkipForwardOutline, IoPlaySkipBackOutline } from &quot;react-icons/io5&quot;;

/**
 * PlaybackControls - Play/pause and skip buttons
 */
export default function PlaybackControls({
  isPlaying,
  onPlayToggle,
  onSkipBack,
  onSkipForward,
}) {
  return (
    &lt;div className=&quot;flex flex-row items-center gap-[3.125px] sm:gap-[6.25px] justify-between&quot;&gt;
      &lt;div 
        onClick={onSkipBack}
        className=&quot;h-[16px] sm:h-[22px] md:h-[24px] lg:h-[32px] w-[16px] sm:w-[22px] md:w-[24px] lg:w-[32px] bg-BrandBlack2 border-[0.625px] border-BrandGray flex items-center justify-center rounded-sm cursor-pointer&quot;
      &gt;
        &lt;IoPlaySkipBackOutline className=&quot;text-BrandOrange text-[17.5px] sm:text-[20px] md:text-[22.5px] lg:text-[25px]&quot; /&gt;
      &lt;/div&gt;
      &lt;div
        onClick={onPlayToggle}
        className=&quot;h-[37.5px] w-[37.5px] sm:h-[43.75px] sm:w-[43.75px] md:h-[50px] md:w-[50px] bg-BrandOrange flex items-center justify-center rounded-lg cursor-pointer&quot;
      &gt;
        {isPlaying ? (
          &lt;svg
            width=&quot;22.5&quot;
            height=&quot;22.5&quot;
            viewBox=&quot;0 0 24 24&quot;
            fill=&quot;currentColor&quot;
            className=&quot;text-BrandBlack&quot;
          &gt;
            &lt;rect x=&quot;6&quot; y=&quot;4&quot; width=&quot;4&quot; height=&quot;16&quot; /&gt;
            &lt;rect x=&quot;14&quot; y=&quot;4&quot; width=&quot;4&quot; height=&quot;16&quot; /&gt;
          &lt;/svg&gt;
        ) : (
          &lt;IoPlayOutline className=&quot;text-BrandBlack text-[22.5px] sm:text-[22.5px] md:text-[25px] lg:text-[31.25px]&quot; /&gt;
        )}
      &lt;/div&gt;
      &lt;div 
        onClick={onSkipForward}
        className=&quot;h-[16px] sm:h-[22px] md:h-[24px] lg:h-[32px] w-[16px] sm:w-[22px] md:w-[24px] lg:w-[32px] bg-BrandBlack2 border-[0.625px] border-BrandGray flex items-center justify-center rounded-sm cursor-pointer&quot;
      &gt;
        &lt;IoPlaySkipForwardOutline className=&quot;text-BrandOrange text-[17.5px] sm:text-[20px] md:text-[22.5px] lg:text-[25px]&quot; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/controlPill/README.md"># ControlPill Component

This folder contains the ControlPill timeline control component and all its subcomponents.

## Component Structure

```
controlPill/
├── ControlPill.jsx       # Main timeline control component
├── TimePill.jsx          # Draggable timeline with ticks and thumb
├── KeyframeDisplay.jsx   # Keyframe icons on timeline
├── SpeedSlider.jsx       # Speed control slider with time display
├── PlaybackControls.jsx  # Play/pause/skip buttons
├── KeyframeManager.jsx   # Add/delete keyframe button
├── DropdownMenu.jsx      # Settings dropdown (trash, undo, redo, autoplay)
└── README.md            # This file
```

## Main ControlPill Component

The main `ControlPill.jsx` component orchestrates all these subcomponents and exposes state via optional callbacks.

### Usage Example

```jsx
import ControlPill from &apos;./components/controlPill/ControlPill&apos;;

function App() {
  const [timePercent, setTimePercent] = useState(0);
  const [keyframes, setKeyframes] = useState([]);
  const [speed, setSpeed] = useState(50);
  const [isPlaying, setIsPlaying] = useState(false);

  return (
    &lt;ControlPill
      // Optional: Receive state updates
      onTimePercentChange={(percent) =&gt; {
        setTimePercent(percent);
        console.log(&apos;Time:&apos;, percent);
      }}
      onKeyframesChange={(kfs) =&gt; {
        setKeyframes(kfs);
        console.log(&apos;Keyframes:&apos;, kfs);
      }}
      onSpeedChange={(speed) =&gt; {
        setSpeed(speed);
        console.log(&apos;Speed:&apos;, speed);
      }}
      onPlayStateChange={(playing) =&gt; {
        setIsPlaying(playing);
        console.log(&apos;Playing:&apos;, playing);
      }}
      onSelectedKeyframeChange={(kf) =&gt; {
        console.log(&apos;Selected keyframe:&apos;, kf);
      }}
      onAutoplayChange={(enabled) =&gt; {
        console.log(&apos;Autoplay:&apos;, enabled);
      }}
      
      // Optional: External control (two-way binding)
      externalTimePercent={timePercent}
      externalIsPlaying={isPlaying}
      externalSpeed={speed}
    /&gt;
  );
}
```

### Exposed State

The ControlPill component exposes the following state via callbacks:

1. **timePercent** (0-100) - Current timeline position
2. **keyframes** - Array of keyframe positions (0-100 values)
3. **speedMultiplier** (0-100) - Speed control value
4. **isPlaying** - Playback state
5. **selectedKeyframe** - Currently selected keyframe (number | null)
6. **autoplayEnabled** - Whether animation loops

### Key Functions

- `onTimePercentChange(timePercent)` - Called when timeline position changes
- `onKeyframesChange(keyframes)` - Called when keyframes are added/removed
- `onSpeedChange(speedMultiplier)` - Called when speed slider changes
- `onPlayStateChange(isPlaying)` - Called when play/pause state changes
- `onSelectedKeyframeChange(keyframe)` - Called when keyframe selection changes
- `onAutoplayChange(enabled)` - Called when autoplay toggle changes

## Component Details

### TimePill
- Displays the timeline with tick marks at 0%, 25%, 50%, 75%, 100%
- Shows keyframe icons (via KeyframeDisplay)
- Draggable thumb for scrubbing through timeline
- Clickable to jump to position

### KeyframeDisplay
- Renders keyframe icons on the timeline
- Shows selected vs unselected states
- Handles keyframe click events

### SpeedSlider
- Material-UI slider for speed control (0-100)
- Displays calculated duration in seconds
- Shows time icon

### PlaybackControls
- Play/pause button (toggles playback)
- Skip back button (placeholder for implementation)
- Skip forward button (placeholder for implementation)

### KeyframeManager
- &quot;Add Keyframe&quot; button when no keyframe is selected
- &quot;Delete Keyframe&quot; button when a keyframe is selected
- Limits to 10 keyframes maximum
- Enforces minimum 4% distance between keyframes

### DropdownMenu
- Trash icon - Clear all keyframes
- Undo icon - Undo last action
- Redo icon - Redo last undone action
- Autoplay toggle - Enable/disable looping
- Close button - Collapse dropdown

## Notes

- All callbacks are optional - ControlPill works standalone
- External control props allow two-way binding for controlled component pattern
- Speed calculation: `speed = (0.25 + (speedMultiplier / 100) * 3.75) * 3`
- Base loop duration: 30 seconds
- Visual timeline maps 3%-97% visual range to 0-100% timePercent</file><file path="src/components/controlPill/SpeedSlider.jsx">import React from &apos;react&apos;;
import { IoTimeOutline } from &quot;react-icons/io5&quot;;
import { Slider } from &apos;@mui/material&apos;;

const LOOP_SECONDS = 30; // Duration for one full traversal from 0 -&gt; 100

/**
 * SpeedSlider - Speed control slider with time display
 */
export default function SpeedSlider({
  speedMultiplier,
  onSpeedChange,
}) {
  // Calculate actual duration based on speed multiplier
  const calculateDuration = () =&gt; {
    const speed = (0.25 + (speedMultiplier / 100) * 3.75) * 3;
    const actualDuration = LOOP_SECONDS / speed;
    return `${Math.round(actualDuration)}s`;
  };

  return (
    &lt;div className=&quot;h-[16px] sm:h-[22px] md:h-[24px] lg:h-[32px] w-200/641 bg-BrandBlack2 flex flex-row rounded-xl items-center justify-center px-[6.25px] sm:px-[9.375px] gap-[6.25px] sm:gap-[9.375px]&quot;&gt;
      &lt;IoTimeOutline className=&quot;text-BrandOrange text-[14px] sm:text-[16px] md:text-[18px] lg:text-[20px] flex-shrink-0&quot; /&gt;
      &lt;Slider
        min={0}
        max={100}
        step={1}
        value={speedMultiplier}
        onChange={(e, newValue) =&gt; onSpeedChange(newValue)}
        className=&quot;flex-1&quot;
        sx={{
          color: &apos;#FF7A18&apos;,
          height: &apos;6.25px&apos;,
          &apos;&amp; .MuiSlider-thumb&apos;: {
            width: &apos;12.5px&apos;,
            height: &apos;12.5px&apos;,
            backgroundColor: &apos;#FF7A18&apos;,
            boxShadow: &apos;0 2px 4px rgba(0, 0, 0, 0.2)&apos;,
            &apos;&amp;:hover&apos;: {
              boxShadow: &apos;0 4px 8px rgba(0, 0, 0, 0.3)&apos;,
            },
            &apos;&amp;:focus, &amp;:active, &amp;.Mui-focusVisible&apos;: {
              outline: &apos;none&apos;,
              boxShadow: &apos;0 2px 4px rgba(0, 0, 0, 0.2)&apos;,
            },
          },
          &apos;&amp; .MuiSlider-track&apos;: {
            backgroundColor: &apos;#FF7A18&apos;,
            height: &apos;6.25px&apos;,
            border: &apos;none&apos;,
          },
          &apos;&amp; .MuiSlider-rail&apos;: {
            backgroundColor: &apos;#75492a&apos;,
            height: &apos;6.25px&apos;,
            opacity: 1,
          },
        }}
      /&gt;
      &lt;div className=&quot;sm:py-[6.25px] font-DmSans rounded-md text-[10.9375px] sm:text-[12.5px] md:text-[14.0625px] text-BrandGray flex items-center justify-center&quot;&gt;
        {calculateDuration()}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/controlPill/TimePill.jsx">import React, { useRef, useEffect } from &apos;react&apos;;
import KeyframeDisplay from &apos;./KeyframeDisplay&apos;;

/**
 * TimePill - The draggable timeline component
 * Displays the timeline with tick marks, keyframes, and a draggable thumb
 */
export default function TimePill({
  timePercent,
  onTimeChange,
  keyframes = [],
  selectedKeyframe = null,
  onKeyframeClick,
  onDragStart,
  onDragEnd,
  isDragging,
}) {
  const pillRef = useRef(null);
  const justFinishedDragging = useRef(false);

  // Convert mouse position to timePercent (0-100) considering the 3%-97% visual range
  const getPercentFromMousePosition = (clientX) =&gt; {
    if (!pillRef.current) return 0;
    const rect = pillRef.current.getBoundingClientRect();
    const x = clientX - rect.left;
    const percent = (x / rect.width) * 100;
    // Map from 0-100% clickable range to 3-97% visual range, then back to 0-100 timePercent
    const visualPercent = Math.max(3, Math.min(97, percent));
    const timePercentValue = ((visualPercent - 3) / 94) * 100;
    return Math.max(0, Math.min(100, timePercentValue));
  };

  // Convert timePercent (0-100) to visual position percentage (3-97%)
  const timePercentToVisualPosition = (timePercent) =&gt; {
    return 3 + (timePercent / 100) * 94;
  };

  // Handle click on pill to jump to position
  const handlePillClick = (e) =&gt; {
    // Don&apos;t handle click if we just finished dragging (prevents click on drag end)
    if (isDragging || justFinishedDragging.current) {
      justFinishedDragging.current = false;
      return;
    }
    const newPercent = getPercentFromMousePosition(e.clientX);
    onTimeChange(newPercent);
  };

  // Handle drag start
  const handleDragStart = (e) =&gt; {
    e.preventDefault();
    e.stopPropagation(); // Prevent pill click from firing
    onDragStart();
  };

  // Handle drag move
  useEffect(() =&gt; {
    if (!isDragging) return;

    const handleMouseMove = (e) =&gt; {
      const newPercent = getPercentFromMousePosition(e.clientX);
      onTimeChange(newPercent);
    };

    const handleMouseUp = () =&gt; {
      justFinishedDragging.current = true;
      onDragEnd?.(); // Notify parent that dragging ended
      // Reset after a short delay to allow click event to be checked
      setTimeout(() =&gt; {
        justFinishedDragging.current = false;
      }, 10);
    };

    document.addEventListener(&apos;mousemove&apos;, handleMouseMove);
    document.addEventListener(&apos;mouseup&apos;, handleMouseUp);

    return () =&gt; {
      document.removeEventListener(&apos;mousemove&apos;, handleMouseMove);
      document.removeEventListener(&apos;mouseup&apos;, handleMouseUp);
    };
  }, [isDragging, onTimeChange, onDragEnd]);

  return (
    &lt;div
      ref={pillRef}
      onClick={handlePillClick}
      className=&quot;h-29/124 mt-[3.125px] sm:mt-[6.25px] md:mt-[6.25px] lg:mt-[6.25px] w-full flex items-center px-[6.25px] bg-BrandBlack2 border-[0.3125px] border-BrandGray rounded-full relative cursor-pointer&quot;
    &gt;
      {/* The horizontal rule (line) inside the pill */}
      &lt;hr className=&quot;absolute left-0 top-1/2 w-full text-BrandOrange2 -translate-y-1/2&quot; /&gt;
      
      {/* Vertical tick marks at 0%, 25%, 50%, 75%, 100% */}
      {[0, 25, 50, 75, 100].map((percent) =&gt; {
        const visualPos = timePercentToVisualPosition(percent);
        return (
          &lt;div
            key={`tick-${percent}`}
            className=&quot;absolute z-5 bg-BrandOrange2&quot;
            style={{
              left: `${visualPos}%`,
              top: &quot;50%&quot;,
              transform: &quot;translate(-50%, -50%)&quot;,
              width: &quot;1.25px&quot;,
              height: &quot;10px&quot;,
              pointerEvents: &quot;none&quot;,
            }}
          /&gt;
        );
      })}

      {/* Keyframe icons scattered along the pill */}
      &lt;KeyframeDisplay
        keyframes={keyframes}
        selectedKeyframe={selectedKeyframe}
        onKeyframeClick={onKeyframeClick}
      /&gt;

      {/* The circle (thumb) positioned on top of the line */}
      &lt;div
        onMouseDown={handleDragStart}
        className=&quot;absolute z-10 top-1/2 transform -translate-x-1/2 -translate-y-1/2 h-[3.125px] w-[3.125px] sm:h-[15.625px] sm:w-[15.625px] bg-BrandOrange rounded-full cursor-grab active:cursor-grabbing&quot;
        style={{ 
          left: `${timePercentToVisualPosition(timePercent)}%`, 
          pointerEvents: &apos;auto&apos; 
        }}
      /&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/MessagePopup/MessagePopup.jsx">import React, { useEffect, useState } from &apos;react&apos;;

export default function MessagePopup({ message, subtitle, visible, type = &quot;standard&quot;, onClose, autoHideDuration = 3000 }) {
    const [isVisible, setIsVisible] = useState(visible);

    useEffect(() =&gt; {
        setIsVisible(visible);
    }, [visible]);

    useEffect(() =&gt; {
        if (isVisible &amp;&amp; autoHideDuration &gt; 0) {
            const timer = setTimeout(() =&gt; {
                setIsVisible(false);
                onClose?.();
            }, autoHideDuration);

            return () =&gt; clearTimeout(timer);
        }
    }, [isVisible, autoHideDuration, onClose]);

    if (!isVisible) return null;

    const typeStyles = {
        error: {
            bg: &quot;bg-red-900/90&quot;,
            border: &quot;border-red-500&quot;,
            text: &quot;text-red-200&quot;,
            title: &quot;text-red-300&quot;,
        },
        success: {
            bg: &quot;bg-green-900/90&quot;,
            border: &quot;border-green-500&quot;,
            text: &quot;text-green-200&quot;,
            title: &quot;text-green-300&quot;,
        },
        standard: {
            bg: &quot;bg-BrandBlack2&quot;,
            border: &quot;border-BrandOrange&quot;,
            text: &quot;text-BrandOrange&quot;,
            title: &quot;text-BrandOrange&quot;,
        },
    };

    const styles = typeStyles[type] || typeStyles.standard;

    return (
        &lt;div className={`flex flex-col items-center justify-center absolute top-[10px] left-1/2 -translate-x-1/2 z-[100] p-2 sm:p-2.5 rounded-md ${styles.bg} border-[1px] ${styles.border} shadow-lg min-w-[150px] sm:min-w-[200px] max-w-[90vw] transition-opacity duration-300`}&gt;
            &lt;h2 className={`${styles.title} text-xs sm:text-sm font-DmSans font-semibold mb-0.5`}&gt;{message}&lt;/h2&gt;
            {subtitle &amp;&amp; (
                &lt;p className={`${styles.text} text-[10px] sm:text-xs font-DmSans`}&gt;{subtitle}&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}</file><file path="src/components/MessagePopup/README.md"># MessagePopup Component

This folder contains the MessagePopup component, a notification/toast-style popup that displays messages to users with different styling based on message type.

## Component Overview

The MessagePopup is a notification component that appears at the top center of the screen. It supports three message types (error, success, standard) with distinct styling, and automatically dismisses after a configurable duration.

## Usage

### Basic Import

```jsx
import MessagePopup from &quot;./components/messagePopup/MessagePopup&quot;;
```

### Component Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `message` | `string` | Required | The main message text to display |
| `subtitle` | `string` | `&quot;&quot;` | Optional subtitle text displayed below the message |
| `visible` | `boolean` | `false` | Controls whether the popup is visible |
| `type` | `&quot;error&quot; \| &quot;success&quot; \| &quot;standard&quot;` | `&quot;standard&quot;` | Message type that determines styling |
| `onClose` | `function` | `undefined` | Callback function called when popup closes (auto-dismiss or manual) |
| `autoHideDuration` | `number` | `3000` | Duration in milliseconds before auto-dismissing (0 to disable) |

### Example Implementation

```jsx
import { useState } from &quot;react&quot;;
import MessagePopup from &quot;./components/messagePopup/MessagePopup&quot;;

function App() {
  const [messagePopup, setMessagePopup] = useState({
    visible: false,
    message: &quot;&quot;,
    subtitle: &quot;&quot;,
    type: &quot;standard&quot;,
  });

  // Method to show message popup
  const showMessage = (message, subtitle = &quot;&quot;, type = &quot;standard&quot;, duration = 3000) =&gt; {
    setMessagePopup({
      visible: true,
      message,
      subtitle,
      type,
    });
  };

  const hideMessage = () =&gt; {
    setMessagePopup((prev) =&gt; ({ ...prev, visible: false }));
  };

  return (
    &lt;&gt;
      &lt;MessagePopup
        message={messagePopup.message}
        subtitle={messagePopup.subtitle}
        visible={messagePopup.visible}
        type={messagePopup.type}
        onClose={hideMessage}
      /&gt;
      
      {/* Example usage */}
      &lt;button onClick={() =&gt; showMessage(&quot;Success!&quot;, &quot;Operation completed&quot;, &quot;success&quot;)}&gt;
        Show Success
      &lt;/button&gt;
      &lt;button onClick={() =&gt; showMessage(&quot;Error&quot;, &quot;Something went wrong&quot;, &quot;error&quot;)}&gt;
        Show Error
      &lt;/button&gt;
      &lt;button onClick={() =&gt; showMessage(&quot;Info&quot;, &quot;This is a message&quot;, &quot;standard&quot;)}&gt;
        Show Standard
      &lt;/button&gt;
    &lt;/&gt;
  );
}
```

## Message Types

### Error (`type=&quot;error&quot;`)
- **Background**: Dark red (`bg-red-900/90`)
- **Border**: Red (`border-red-500`)
- **Text**: Light red (`text-red-200`)
- **Title**: Medium red (`text-red-300`)
- **Use case**: Display error messages, validation failures, or critical issues

### Success (`type=&quot;success&quot;`)
- **Background**: Dark green (`bg-green-900/90`)
- **Border**: Green (`border-green-500`)
- **Text**: Light green (`text-green-200`)
- **Title**: Medium green (`text-green-300`)
- **Use case**: Display success messages, confirmations, or positive feedback

### Standard (`type=&quot;standard&quot;`)
- **Background**: Brand black (`bg-BrandBlack2`)
- **Border**: Brand orange (`border-BrandOrange`)
- **Text**: Brand orange (`text-BrandOrange`)
- **Title**: Brand orange (`text-BrandOrange`)
- **Use case**: Display general information, neutral messages, or default notifications

## Features

### Auto-Dismiss
- The popup automatically hides after `autoHideDuration` milliseconds (default: 3000ms)
- Set `autoHideDuration={0}` to disable auto-dismiss
- The `onClose` callback is triggered when the popup auto-dismisses

### Manual Control
- Control visibility via the `visible` prop
- Call `onClose` to manually hide the popup
- The component uses internal state to manage visibility transitions

### Responsive Design
- Responsive padding: `p-2 sm:p-2.5`
- Responsive minimum width: `min-w-[150px] sm:min-w-[200px]`
- Responsive text sizes for both message and subtitle
- Maximum width constraint: `max-w-[90vw]` to prevent overflow on small screens

### Positioning
- Absolutely positioned at top center of screen
- Uses `top-[10px] left-1/2 -translate-x-1/2` for centering
- High z-index (`z-[100]`) to appear above other content

## Styling Details

### Layout
- Flex column layout with centered items
- Rounded corners (`rounded-md`)
- Shadow effect (`shadow-lg`)
- Smooth opacity transitions (`transition-opacity duration-300`)

### Typography
- **Message (h2)**: 
  - Size: `text-xs sm:text-sm`
  - Weight: `font-semibold`
  - Font: `font-DmSans`
  - Margin bottom: `mb-0.5`
- **Subtitle (p)**:
  - Size: `text-[10px] sm:text-xs`
  - Font: `font-DmSans`
  - Only rendered if `subtitle` prop is provided

## Best Practices

1. **Keep messages concise**: The popup has limited space, especially on mobile devices
2. **Use appropriate types**: Match the message type to the content (error for errors, success for successes)
3. **Provide subtitles for context**: Use the subtitle prop to add additional context without cluttering the main message
4. **Handle multiple messages**: If showing multiple messages in sequence, ensure proper state management to avoid overlapping popups
5. **Accessibility**: The component uses semantic HTML (`h2` for message, `p` for subtitle) for screen readers

## Integration with App State

The MessagePopup is typically integrated into the main App component with state management:

```jsx
// State structure
const [messagePopup, setMessagePopup] = useState({
  visible: false,
  message: &quot;&quot;,
  subtitle: &quot;&quot;,
  type: &quot;standard&quot;,
});

// Helper function to show messages
const showMessage = (message, subtitle = &quot;&quot;, type = &quot;standard&quot;, duration = 3000) =&gt; {
  setMessagePopup({
    visible: true,
    message,
    subtitle,
    type,
  });
};

// Helper function to hide messages
const hideMessage = () =&gt; {
  setMessagePopup((prev) =&gt; ({ ...prev, visible: false }));
};
```

This pattern allows you to call `showMessage()` from anywhere in your app (via props or context) to display notifications.

## Notes

- The component returns `null` when not visible, so it doesn&apos;t render anything in the DOM
- The internal `isVisible` state is synced with the `visible` prop to handle smooth transitions
- The auto-dismiss timer is cleaned up properly when the component unmounts or when visibility changes
- All styling uses Tailwind CSS classes with responsive breakpoints</file><file path="src/components/rightPanel/AdvancedSettingsButton.jsx">import React from &quot;react&quot;;
import { IoSettingsOutline } from &quot;react-icons/io5&quot;;

export default function AdvancedSettingsButton({ isOpen = false, onOpen }) {
  return (
    &lt;div className=&quot;w-full py-1 sm:py-1.5 md:py-2 border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4&quot;&gt;
      &lt;button
        onClick={() =&gt; onOpen?.()}
        className={`w-full flex flex-row border-[0.5px] border-BrandGray2 justify-evenly ${isOpen ? &quot;bg-BrandBlack&quot; : &quot;bg-BrandBlack2&quot;
          } py-1.5 sm:py-2 px-2 sm:px-2.5 md:px-3 rounded-md items-center gap-0.5 sm:gap-1 cursor-pointer hover:bg-BrandBlack transition-colors duration-200`}
      &gt;
        &lt;IoSettingsOutline className=&quot;text-BrandWhite text-sm sm:text-base md:text-lg&quot; /&gt;
        &lt;p className=&quot;text-BrandWhite text-[10px] sm:text-xs font-bold font-DmSans&quot;&gt;Advanced Settings&lt;/p&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/rightPanel/AllPlayersSection.jsx">import React from &quot;react&quot;;
import { ImCheckboxChecked, ImCheckboxUnchecked } from &quot;react-icons/im&quot;;
import { Slider } from &quot;@mui/material&quot;;

export default function AllPlayersSection({ value, onChange }) {
  const playerSize = value?.sizePercent ?? 100;
  // Default to showing player numbers unless explicitly turned off.
  const showNumber = value?.showNumber ?? true;
  const showName = value?.showName ?? false;

  const update = (patch) =&gt; onChange?.({ ...value, ...patch });


  return (
    &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-1.5 sm:pb-2 items-start justify-center gap-0.5 &quot;&gt;
      &lt;div className=&quot;text-BrandOrange text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;All Players&lt;/div&gt;

      &lt;div className=&quot;flex flex-row w-full items-center justify-between&quot;&gt;
        &lt;p className=&quot;text-BrandOrange text-[10px] sm:text-xs md:text-sm font-DmSans&quot;&gt; Size: {playerSize}%&lt;/p&gt;
      &lt;/div&gt;

      {/* Prevent slider thumb from causing horizontal overflow */}
      &lt;div className=&quot;w-full min-w-0 overflow-x-hidden overflow-y-hidden flex items-center justify-start px-2&quot;&gt;
        &lt;Slider
          min={5}
          max={200}
          step={5}
          value={playerSize}
          onChange={(_, newValue) =&gt; update({ sizePercent: Array.isArray(newValue) ? newValue[0] : newValue })}
          sx={{
            width: &quot;100%&quot;,
            color: &quot;#FF7A18&quot;,
            height: &quot;6.25px&quot;,
            &quot;&amp; .MuiSlider-thumb&quot;: {
              width: &quot;12.5px&quot;,
              height: &quot;12.5px&quot;,
              backgroundColor: &quot;#FF7A18&quot;,
              boxShadow: &quot;0 2px 4px rgba(0, 0, 0, 0.2)&quot;,
              &quot;&amp;:hover&quot;: {
                boxShadow: &quot;0 4px 8px rgba(0, 0, 0, 0.3)&quot;,
              },
              &quot;&amp;:focus, &amp;:active, &amp;.Mui-focusVisible&quot;: {
                outline: &quot;none&quot;,
                boxShadow: &quot;0 2px 4px rgba(0, 0, 0, 0.2)&quot;,
              },
            },
            &quot;&amp; .MuiSlider-track&quot;: {
              backgroundColor: &quot;#FF7A18&quot;,
              height: &quot;6.25px&quot;,
              border: &quot;none&quot;,
            },
            &quot;&amp; .MuiSlider-rail&quot;: {
              backgroundColor: &quot;#75492a&quot;,
              height: &quot;6.25px&quot;,
              opacity: 1,
            },
          }}
          aria-label=&quot;Player size percent&quot;
        /&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex flex-row w-full items-center justify-between&quot;&gt;
        &lt;p className=&quot;text-BrandOrange text-[10px] sm:text-xs md:text-sm font-DmSans&quot;&gt; Show Number:&lt;/p&gt;
        &lt;button type=&quot;button&quot; onClick={() =&gt; update({ showNumber: !showNumber })} className=&quot;focus:outline-none cursor-pointer&quot;&gt;
          {showNumber ? (
            &lt;ImCheckboxChecked className=&quot;text-BrandOrange w-3 h-3 sm:w-3.5 sm:h-3.5 md:w-4 md:h-4&quot; /&gt;
          ) : (
            &lt;ImCheckboxUnchecked className=&quot;text-BrandGray2 w-3 h-3 sm:w-3.5 sm:h-3.5 md:w-4 md:h-4&quot; /&gt;
          )}
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex flex-row w-full items-center justify-between&quot;&gt;
        &lt;p className=&quot;text-BrandOrange text-[10px] sm:text-xs md:text-sm font-DmSans&quot;&gt; Show Name:&lt;/p&gt;
        &lt;button type=&quot;button&quot; onClick={() =&gt; update({ showName: !showName })} className=&quot;focus:outline-none cursor-pointer&quot;&gt;
          {showName ? (
            &lt;ImCheckboxChecked className=&quot;text-BrandOrange w-3 h-3 sm:w-3.5 sm:h-3.5 md:w-4 md:h-4&quot; /&gt;
          ) : (
            &lt;ImCheckboxUnchecked className=&quot;text-BrandGray2 w-3 h-3 sm:w-3.5 sm:h-3.5 md:w-4 md:h-4&quot; /&gt;
          )}
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/rightPanel/ExportActions.jsx">import React from &quot;react&quot;;
import { BsBookmarkPlus } from &quot;react-icons/bs&quot;;
import { IoMdDownload } from &quot;react-icons/io&quot;;

const actionButtonClass = `
  w-full flex flex-row items-center justify-center gap-2
  bg-BrandOrange text-BrandBlack font-DmSans font-semibold
  text-[10px] sm:text-xs md:text-sm
  rounded-lg py-2 sm:py-2.5 px-3
  border border-BrandOrange/80
  transition-all duration-200
  hover:bg-BrandOrange/95 hover:border-BrandOrange
  active:scale-[0.98] active:bg-BrandOrange/90
  focus:outline-none focus-visible:ring-2 focus-visible:ring-BrandOrange focus-visible:ring-offset-2 focus-visible:ring-offset-BrandBlack
`;

export default function ExportActions({ onSaveToPlaybook, onDownload }) {
  return (
    &lt;div className=&quot;w-full flex flex-col gap-2&quot;&gt;
      &lt;button
        type=&quot;button&quot;
        onClick={() =&gt; onSaveToPlaybook?.()}
        className={actionButtonClass}
      &gt;
        &lt;BsBookmarkPlus className=&quot;text-BrandBlack shrink-0 text-base sm:text-lg md:text-xl&quot; aria-hidden /&gt;
        &lt;span&gt;Save to Playbook&lt;/span&gt;
      &lt;/button&gt;

      &lt;button
        type=&quot;button&quot;
        onClick={() =&gt; onDownload?.()}
        className={actionButtonClass}
      &gt;
        &lt;IoMdDownload className=&quot;text-BrandBlack shrink-0 text-base sm:text-lg md:text-xl&quot; aria-hidden /&gt;
        &lt;span&gt;Download&lt;/span&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/rightPanel/FieldSettingsSection.jsx">import React, { useEffect, useRef, useState } from &quot;react&quot;;
import { BiRedo, BiUndo } from &quot;react-icons/bi&quot;;
import { FiRotateCcw, FiRotateCw } from &quot;react-icons/fi&quot;;
import { MdOutlineResetTv, MdOutlineZoomIn, MdOutlineZoomOut } from &quot;react-icons/md&quot;;
import { TbRotateDot } from &quot;react-icons/tb&quot;;
import { PanelButton } from &quot;../subcomponents/Buttons.jsx&quot;;

export default function FieldSettingsSection({
  zoomPercent,
  onZoomIn,
  onZoomOut,
  onZoomPercentChange,
  onRotateLeft,
  onRotateCenter,
  onRotateRight,
  onUndo,
  onRedo,
  onReset,
}) {
  const iconClass = &quot;text-BrandOrange text-sm sm:text-base md:text-lg lg:text-xl&quot;;

  const [isEditingZoom, setIsEditingZoom] = useState(false);
  const [draftZoom, setDraftZoom] = useState(String(zoomPercent ?? 100));
  const zoomInputRef = useRef(null);

  useEffect(() =&gt; {
    if (!isEditingZoom) return;
    if (!zoomInputRef.current) return;
    zoomInputRef.current.focus();
    zoomInputRef.current.select();
  }, [isEditingZoom]);

  useEffect(() =&gt; {
    if (isEditingZoom) return;
    setDraftZoom(String(zoomPercent ?? 100));
  }, [zoomPercent, isEditingZoom]);

  const commitZoom = () =&gt; {
    const parsed = Number(draftZoom);
    const next = Number.isFinite(parsed) ? parsed : zoomPercent;
    onZoomPercentChange?.(next);
    setIsEditingZoom(false);
  };

  const cancelZoom = () =&gt; {
    setDraftZoom(String(zoomPercent ?? 100));
    setIsEditingZoom(false);
  };

  const handleZoomChange = (e) =&gt; {
    const value = e.target.value;
    if (value === &quot;&quot; || /^\d+$/.test(value)) setDraftZoom(value);
  };

  const handleZoomKeyDown = (e) =&gt; {
    if (e.key === &quot;Enter&quot;) commitZoom();
    if (e.key === &quot;Escape&quot;) cancelZoom();
  };

  return (
    &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4 items-start justify-center &quot;&gt;
      &lt;div className=&quot;text-BrandOrange text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;Field Settings&lt;/div&gt;

      &lt;div className=&quot;w-full grid grid-cols-3 gap-1.5 sm:gap-2 md:gap-3 mt-1 sm:mt-1.5 md:mt-2&quot;&gt;
        &lt;div&gt;
          &lt;PanelButton Icon={&lt;FiRotateCcw className={iconClass} /&gt;} onClick={() =&gt; onRotateLeft?.()} isSelected={false} /&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;PanelButton Icon={&lt;TbRotateDot className={iconClass} /&gt;} onClick={() =&gt; onRotateCenter?.()} isSelected={false} /&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;PanelButton Icon={&lt;FiRotateCw className={iconClass} /&gt;} onClick={() =&gt; onRotateRight?.()} isSelected={false} /&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;PanelButton Icon={&lt;MdOutlineZoomOut className={iconClass} /&gt;} onClick={() =&gt; onZoomOut?.()} isSelected={false} /&gt;
        &lt;/div&gt;

        &lt;div className=&quot;flex items-center justify-center m-auto&quot;&gt;
          {isEditingZoom ? (
            &lt;input
              ref={zoomInputRef}
              type=&quot;text&quot;
              value={draftZoom}
              onChange={handleZoomChange}
              onBlur={commitZoom}
              onKeyDown={handleZoomKeyDown}
              className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base bg-transparent border-none outline-none focus:outline-none text-center font-DmSans w-10 sm:w-12&quot;
              maxLength={4}
            /&gt;
          ) : (
            &lt;p
              className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base font-DmSans cursor-pointer&quot;
              onClick={() =&gt; setIsEditingZoom(true)}
            &gt;
              {zoomPercent}%
            &lt;/p&gt;
          )}
        &lt;/div&gt;

        &lt;div&gt;
          &lt;PanelButton Icon={&lt;MdOutlineZoomIn className={iconClass} /&gt;} onClick={() =&gt; onZoomIn?.()} isSelected={false} /&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;PanelButton Icon={&lt;BiUndo className={iconClass} /&gt;} onClick={() =&gt; onUndo?.()} isSelected={false} /&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;PanelButton Icon={&lt;MdOutlineResetTv className={iconClass} /&gt;} onClick={() =&gt; onReset?.()} isSelected={false} /&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;PanelButton Icon={&lt;BiRedo className={iconClass} /&gt;} onClick={() =&gt; onRedo?.()} isSelected={false} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/rightPanel/PlayerEditPanel.jsx">import React, { useEffect, useRef } from &quot;react&quot;;
import { IoClose } from &quot;react-icons/io5&quot;;

export default function PlayerEditPanel({
  isOpen,
  player,
  draft,
  onChange,
  onClose,
  onSave,
}) {
  const firstInputRef = useRef(null);

  useEffect(() =&gt; {
    if (isOpen) {
      firstInputRef.current?.focus();
    }
  }, [isOpen]);

  if (!isOpen) return null;
  const nameValue = draft?.name ?? player?.name ?? &quot;&quot;;
  const numberValue = draft?.number ?? player?.number ?? &quot;&quot;;
  const assignmentValue = draft?.assignment ?? player?.assignment ?? &quot;&quot;;

  return (
    &lt;aside
      className=&quot;absolute right-0 top-0 h-screen w-48 sm:w-56 md:w-64 bg-BrandBlack border-l border-BrandGray2/60 shadow-2xl z-[60] flex flex-col&quot;
      role=&quot;dialog&quot;
      aria-label=&quot;Edit player&quot;
    &gt;
      &lt;div className=&quot;flex items-center justify-between px-3 py-3 border-b border-BrandGray2/60&quot;&gt;
        &lt;p className=&quot;text-BrandOrange text-sm sm:text-base font-DmSans font-semibold&quot;&gt;Edit Player&lt;/p&gt;
        &lt;button
          type=&quot;button&quot;
          onClick={onClose}
          className=&quot;text-BrandOrange text-lg&quot;
          aria-label=&quot;Close edit panel&quot;
        &gt;
          &lt;IoClose /&gt;
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex-1 overflow-y-auto px-3 py-3 flex flex-col gap-2&quot;&gt;
        &lt;label className=&quot;flex flex-col gap-1&quot;&gt;
          &lt;span className=&quot;text-BrandOrange text-xs sm:text-sm&quot;&gt;Number&lt;/span&gt;
          &lt;input
            ref={firstInputRef}
            type=&quot;text&quot;
            value={numberValue}
            onChange={(e) =&gt; onChange?.({ number: e.target.value })}
            onKeyDown={(e) =&gt; {
              if (e.key === &quot;Enter&quot;) onSave?.();
              if (e.key === &quot;Escape&quot;) onClose?.();
            }}
            className=&quot;w-full h-8 sm:h-9 bg-BrandBlack border-[0.5px] border-BrandGray text-BrandWhite rounded-md px-2 text-xs sm:text-sm focus:outline-none focus:border-BrandOrange transition-colors&quot;
          /&gt;
        &lt;/label&gt;
        &lt;label className=&quot;flex flex-col gap-1&quot;&gt;
          &lt;span className=&quot;text-BrandOrange text-xs sm:text-sm&quot;&gt;Name&lt;/span&gt;
          &lt;input
            type=&quot;text&quot;
            value={nameValue}
            onChange={(e) =&gt; onChange?.({ name: e.target.value })}
            onKeyDown={(e) =&gt; {
              if (e.key === &quot;Enter&quot;) onSave?.();
              if (e.key === &quot;Escape&quot;) onClose?.();
            }}
            className=&quot;w-full h-8 sm:h-9 bg-BrandBlack border-[0.5px] border-BrandGray text-BrandWhite rounded-md px-2 text-xs sm:text-sm focus:outline-none focus:border-BrandOrange transition-colors&quot;
          /&gt;
        &lt;/label&gt;
        &lt;label className=&quot;flex flex-col gap-1&quot;&gt;
          &lt;span className=&quot;text-BrandOrange text-xs sm:text-sm&quot;&gt;Assignment&lt;/span&gt;
          &lt;input
            type=&quot;text&quot;
            value={assignmentValue}
            onChange={(e) =&gt; onChange?.({ assignment: e.target.value })}
            onKeyDown={(e) =&gt; {
              if (e.key === &quot;Enter&quot;) onSave?.();
              if (e.key === &quot;Escape&quot;) onClose?.();
            }}
            className=&quot;w-full h-8 sm:h-9 bg-BrandBlack border-[0.5px] border-BrandGray text-BrandWhite rounded-md px-2 text-xs sm:text-sm focus:outline-none focus:border-BrandOrange transition-colors&quot;
          /&gt;
        &lt;/label&gt;
      &lt;/div&gt;

      &lt;div className=&quot;px-3 pb-3 pt-2 flex gap-2&quot;&gt;
        &lt;button
          type=&quot;button&quot;
          onClick={onClose}
          className=&quot;flex-1 h-8 sm:h-9 border border-BrandGray text-BrandWhite rounded-md text-xs sm:text-sm font-DmSans&quot;
        &gt;
          Cancel
        &lt;/button&gt;
        &lt;button
          type=&quot;button&quot;
          onClick={onSave}
          className=&quot;flex-1 h-8 sm:h-9 bg-BrandOrange text-BrandBlack rounded-md text-xs sm:text-sm font-DmSans font-semibold hover:bg-BrandOrange/90 transition-colors&quot;
        &gt;
          Save
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/aside&gt;
  );
}</file><file path="src/components/rightPanel/PlayerRow.jsx">import React from &quot;react&quot;;
import { FiEdit } from &quot;react-icons/fi&quot;;
import { MdDeleteOutline } from &quot;react-icons/md&quot;;

export default function PlayerRow({ player, isSelected = false, onClick, onEdit, onDelete }) {
  if (!player) return null;
  const nameText = player.name ?? &quot;&quot;;
  const assignmentText = player.assignment ?? &quot;&quot;;
  return (
    &lt;div
      role=&quot;button&quot;
      tabIndex={0}
      onClick={() =&gt; onClick?.(player.id, { toggle: true })}
      onKeyDown={(e) =&gt; {
        if (e.key === &quot;Enter&quot; || e.key === &quot; &quot;) onClick?.(player.id);
      }}
      className={`w-full flex flex-row rounded-sm items-center justify-between px-1 py-0.5 sm:py-1 transition-colors cursor-pointer
        ${isSelected ? &quot;bg-BrandBlack border border-BrandOrange&quot; : &quot;bg-BrandBlack2 border border-transparent&quot;}
        hover:bg-BrandBlack`}
    &gt;
      {/* Color indicator */}
      &lt;div
        className=&quot;w-3 h-3 sm:w-[14px] sm:h-[14px] md:w-4 md:h-4 rounded-full border-[0.25px] border-BrandBlack shrink-0&quot;
        style={{ backgroundColor: player.color || &quot;#ef4444&quot; }}
      /&gt;

      {/* Number + optional label/assignment */}
      &lt;div className=&quot;flex-1 min-w-0 flex flex-col items-center justify-center px-1&quot;&gt;
        &lt;div className=&quot;w-full min-w-0 flex flex-row items-center justify-center gap-1&quot;&gt;
          {/*
            Top row: number + name share identical typography.
            Name truncates with ellipsis when long.
          */}
          {(player.number ?? &quot;&quot;) !== &quot;&quot; &amp;&amp; (
            &lt;span className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base font-DmSans font-semibold leading-none shrink-0&quot;&gt;
              {player.number}
            &lt;/span&gt;
          )}
          {(player.number ?? &quot;&quot;) !== &quot;&quot; &amp;&amp; nameText !== &quot;&quot; &amp;&amp; (
            &lt;span className=&quot;text-BrandGray text-[10px] sm:text-xs md:text-sm leading-none shrink-0&quot;&gt;•&lt;/span&gt;
          )}
          {nameText !== &quot;&quot; &amp;&amp; (
            &lt;span className=&quot;text-BrandWhite text-xs sm:text-sm md:text-sm font-DmSans font-semibold leading-none min-w-0 truncate&quot;&gt;
              {nameText}
            &lt;/span&gt;
          )}
        &lt;/div&gt;

        {assignmentText !== &quot;&quot; &amp;&amp; (
          &lt;p className=&quot;text-BrandGray text-[7px] sm:text-[8px] md:text-[10px] font-DmSans leading-none truncate w-full text-center&quot;&gt;
            {assignmentText}
          &lt;/p&gt;
        )}
      &lt;/div&gt;

      {/* Actions */}
      &lt;div className=&quot;flex flex-row justify-center items-center gap-0.5 sm:gap-1 shrink-0&quot;&gt;
        &lt;button
          type=&quot;button&quot;
          onClick={(e) =&gt; {
            e.stopPropagation();
            onEdit?.(player.id);
          }}
          className=&quot;text-BrandOrange text-xs sm:text-sm md:text-base&quot;
          aria-label=&quot;Edit player&quot;
        &gt;
          &lt;FiEdit /&gt;
        &lt;/button&gt;
        &lt;button
          type=&quot;button&quot;
          onClick={(e) =&gt; {
            e.stopPropagation();
            onDelete?.(player.id);
          }}
          className=&quot;text-BrandOrange text-xs sm:text-sm md:text-base&quot;
          aria-label=&quot;Delete player&quot;
        &gt;
          &lt;MdDeleteOutline /&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/rightPanel/PlayersSection.jsx">import React, { useEffect, useRef } from &quot;react&quot;;
import PlayerRow from &quot;./PlayerRow&quot;;

export default function PlayersSection({
  playersById,
  representedPlayerIds,
  selectedPlayerIds,
  onSelectPlayer,
  onEditPlayer,
  onDeletePlayer,
}) {
  const ids = representedPlayerIds || [];
  const count = ids.length;
  const rowRefs = useRef(new Map());

  useEffect(() =&gt; {
    const targetId = selectedPlayerIds?.[0];
    if (!targetId) return;
    if (!ids.includes(targetId)) return;

    const node = rowRefs.current.get(targetId);
    if (!node) return;

    const frame = window.requestAnimationFrame(() =&gt; {
      node.scrollIntoView({ block: &quot;nearest&quot; });
    });

    return () =&gt; window.cancelAnimationFrame(frame);
  }, [selectedPlayerIds, ids]);

  return (
    &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4 items-start justify-center &quot;&gt;
      &lt;div className=&quot;text-BrandOrange text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;Players ({count})&lt;/div&gt;

      &lt;div className=&quot;flex flex-col w-full items-start justify-start gap-0.5 sm:gap-1 mt-1 sm:mt-1.5 md:mt-2 max-h-[140px] overflow-y-auto hide-scroll&quot;&gt;
        {ids.map((id) =&gt; {
          const player = playersById?.[id];
          if (!player) return null;
          return (
            &lt;div
              key={id}
              ref={(node) =&gt; {
                if (node) rowRefs.current.set(id, node);
                else rowRefs.current.delete(id);
              }}
              className=&quot;w-full&quot;
            &gt;
              &lt;PlayerRow
                player={player}
                isSelected={selectedPlayerIds?.includes(id)}
                onClick={(meta) =&gt; onSelectPlayer?.(id, meta)}
                onEdit={onEditPlayer}
                onDelete={onDeletePlayer}
              /&gt;
            &lt;/div&gt;
          );
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/rightPanel/PlayNameEditor.jsx">import React, { useEffect, useRef, useState } from &quot;react&quot;;
import { FiEdit } from &quot;react-icons/fi&quot;;

export default function PlayNameEditor({ value, onChange, maxLength = 10 }) {
  const [isEditing, setIsEditing] = useState(false);
  const inputRef = useRef(null);

  useEffect(() =&gt; {
    if (!isEditing) return;
    if (!inputRef.current) return;
    inputRef.current.focus();
    inputRef.current.select();
  }, [isEditing]);

  const handleEnableEdit = () =&gt; {
    if ((value || &quot;&quot;).length &lt;= maxLength) setIsEditing(true);
  };

  const handleSave = () =&gt; setIsEditing(false);

  const handleNameChange = (e) =&gt; {
    const next = e.target.value;
    if (next.length &lt;= maxLength) onChange?.(next);
  };

  const handleKeyDown = (e) =&gt; {
    if (e.key === &quot;Enter&quot;) handleSave();
    if (e.key === &quot;Escape&quot;) setIsEditing(false);
  };

  return (
    &lt;div className=&quot;flex flex-row border-b border-BrandGray2 pb-1.5 sm:pb-2 items-center justify-center gap-1.5 sm:gap-2 font-DmSans font-bold&quot;&gt;
      {isEditing ? (
        &lt;input
          ref={inputRef}
          type=&quot;text&quot;
          value={value}
          onChange={handleNameChange}
          onBlur={handleSave}
          onKeyDown={handleKeyDown}
          className=&quot;text-BrandWhite text-lg sm:text-xl md:text-2xl bg-transparent border-none outline-none focus:outline-none text-center font-DmSans font-bold w-full max-w-[100px] sm:max-w-[110px] md:max-w-[120px]&quot;
          maxLength={maxLength}
        /&gt;
      ) : (
        &lt;div className=&quot;text-BrandWhite text-lg sm:text-xl md:text-2xl cursor-pointer&quot; onClick={handleEnableEdit}&gt;
          {value}
        &lt;/div&gt;
      )}
      &lt;FiEdit
        className={`text-xs sm:text-sm cursor-pointer transition-colors ${(value || &quot;&quot;).length &gt; maxLength ? &quot;text-BrandGray cursor-not-allowed&quot; : &quot;text-BrandWhite hover:text-BrandOrange&quot;
          }`}
        onClick={handleEnableEdit}
      /&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/rightPanel/README.md"># Right Panel sections (`src/components/rightPanel/`)

This folder contains the **section components** used by the Right Panel. The main Right Panel component lives in `src/components/RightPanel.jsx` and composes these sections.

## High-level behavior

- **Fixed-width, full-height panel**: `RightPanel.jsx` (in `src/components/`) renders an `&lt;aside&gt;` that is `h-screen` and uses flex column layout.
- **Scrollable content + pinned footer**:
- The **main content** (play name, field settings, players list, advanced settings, all-players controls) lives inside a **scroll container**.
  - The **export actions** (“Save to Playbook”, “Download”) live in a **non-scrolling footer** at the bottom.

This is implemented by splitting the panel into:

- **Scrollable area**: `flex-1 min-h-0 overflow-y-auto overflow-x-hidden`
- **Footer**: `shrink-0` (so it never gets pushed off-screen)

You can see this in `src/components/RightPanel.jsx`.

## Data flow (where state comes from)

`RightPanel.jsx` itself is mostly a **layout/composition** component. State is owned by `src/App.jsx` and passed down as props:

- **Play name**
  - `playName` (string)
  - `onPlayNameChange(nextName)`
- **Field controls**
  - `zoomPercent`
  - `onZoomIn()`, `onZoomOut()`
  - `onZoomPercentChange(nextPercent)`
  - `onRotateLeft()`, `onRotateCenter()`, `onRotateRight()`
  - `onUndo()`, `onRedo()`, `onReset()`
- **Players list / selection**
  - `playersById` (map of player objects)
  - `representedPlayerIds` (array of ids shown in list)
  - `selectedPlayerIds` (array of selected ids)
  - `onSelectPlayer(id, { toggle })`
- **All players display**
  - `allPlayersDisplay` (object: `sizePercent`, `color`, `showNumber`, `showName`)
  - `onAllPlayersDisplayChange(nextObject)`
- **Advanced settings**
  - `advancedSettingsOpen`
  - `onOpenAdvancedSettings()`
- **Export**
  - `onSaveToPlaybook()`
  - `onDownload()`

## Section-by-section

### `PlayNameEditor.jsx`

- Inline editable title at the top (“Name”).
- Click the text (or pencil icon) to edit.
- Enforces `maxLength`.

### `FieldSettingsSection.jsx`

- Grid of icon buttons (rotate/zoom/undo/reset/redo) + editable zoom percent.
- **No tooltips/popovers** (tooltips were removed; buttons are “plain” now).

### `PlayersSection.jsx`

- Shows `Players (count)` header and a scrollable list of players (bounded height).
- Renders each row using `PlayerRow.jsx`.

### `PlayerRow.jsx`

- Single row UI for a player in the list.
- Top line: `number • name` (name truncates with `...` when long).
- Second line: assignment only (truncates).
- Right-side icons: edit/delete (callbacks are optional).

### `AdvancedSettingsButton.jsx`

- Button that triggers the advanced settings modal/panel via `onOpen`.

### `AllPlayersSection.jsx`

Controls that apply to **all players** (defaults / display preferences):

- **Size slider**: uses MUI `Slider` styled to match the ControlPill slider theme.
- **Color**: hex display + color picker popover (`Popover` + `ColorPickerPopover`).
- **Show Number / Show Name**: checkbox toggles.

### `ExportActions.jsx`

- The bottom “export” buttons.
- Includes its own vertical spacing (`gap-*`) so it still looks correct when pinned inside the footer wrapper.

## Common layout gotchas

- **Pinned footer requires `min-h-0` on the scroll area**:
  - Without `min-h-0`, the scroll container may not shrink and the footer can get pushed off-screen.
- **Horizontal scroll prevention**:
  - The scroll container uses `overflow-x-hidden` so controls like sliders don’t create sideways scrolling.</file><file path="src/components/rightPanel/SavePrefabButton.jsx">import React from &quot;react&quot;;
import { IoSaveOutline } from &quot;react-icons/io5&quot;;

export default function SavePrefabButton() {
  return (
    &lt;div className=&quot;w-full py-1 sm:py-1.5 md:py-2 border-b border-BrandGray2 pb-2 sm:pb-3 md:pb-4&quot;&gt;
      &lt;button
        type=&quot;button&quot;
        title=&quot;Save current frame as prefab&quot;
        className=&quot;w-full flex flex-col border-[0.5px] border-BrandGray2 justify-center bg-BrandBlack2 py-2 sm:py-2.5 px-2 sm:px-2.5 md:px-3 rounded-md items-center gap-1 sm:gap-1.5 cursor-pointer hover:bg-BrandBlack transition-colors duration-200&quot;
      &gt;
        &lt;IoSaveOutline className=&quot;text-BrandWhite text-base sm:text-lg md:text-xl shrink-0&quot; aria-hidden /&gt;
        &lt;span className=&quot;text-BrandWhite text-[10px] sm:text-xs font-bold font-DmSans text-center leading-tight break-words min-w-0&quot;&gt;
          Save Current Frame as Prefab
        &lt;/span&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/rightPanel/SelectedPlayersSection.jsx">import React, { useEffect, useState } from &quot;react&quot;;
import { ImCheckboxChecked, ImCheckboxUnchecked } from &quot;react-icons/im&quot;;

export default function SelectedPlayersSection({
  selectedPlayerIds = [],
  selectedPlayers = [],
  allPlayersDisplay,
  onAllPlayersDisplayChange,
  onSelectedPlayersColorChange,
}) {
  const selectedCount = selectedPlayerIds.length;
  const baseColor = allPlayersDisplay?.color ?? &quot;#ef4444&quot;;
  const selectedBaseColor = selectedPlayers?.[0]?.color ?? baseColor;
  const showNumber = allPlayersDisplay?.showNumber ?? true;
  const showName = allPlayersDisplay?.showName ?? false;
  const hasMixedSelectedColors = selectedPlayers.some(
    (player) =&gt; (player?.color ?? baseColor) !== selectedBaseColor
  );

  const [selectedForBulk, setSelectedForBulk] = useState(() =&gt; new Set(selectedPlayerIds));
  const COLOR_OPTIONS = [
    { label: &quot;Red&quot;, value: &quot;#ef4444&quot; },
    { label: &quot;Blue&quot;, value: &quot;#3b82f6&quot; },
  ];

  useEffect(() =&gt; {
    setSelectedForBulk(new Set(selectedPlayerIds));
  }, [selectedPlayerIds]);

  const updateAllPlayersDisplay = (patch) =&gt;
    onAllPlayersDisplayChange?.({ ...allPlayersDisplay, ...patch });

  const applyBulkColor = (hex) =&gt; {
    if (!selectedForBulk.size) return;
    onSelectedPlayersColorChange?.(hex, Array.from(selectedForBulk));
  };

  const toggleBulkSelection = (id) =&gt; {
    setSelectedForBulk((prev) =&gt; {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  return (
    &lt;div className=&quot;flex flex-col border-b border-BrandGray2 pb-1.5 sm:pb-2 items-start justify-center gap-0.5&quot;&gt;
      &lt;div className=&quot;text-BrandOrange text-xs sm:text-sm md:text-base font-DmSans&quot;&gt;
        Selected Players ({selectedCount})
      &lt;/div&gt;

      &lt;div className=&quot;flex flex-col w-full items-start justify-between gap-0.5 sm:gap-1 relative&quot;&gt;
        &lt;p className=&quot;text-BrandOrange text-[10px] sm:text-xs md:text-sm font-DmSans&quot;&gt;Change Color:&lt;/p&gt;
        &lt;div className=&quot;w-full flex flex-row gap-1 sm:gap-1.5&quot;&gt;
          {COLOR_OPTIONS.map((option) =&gt; {
            const isActive = !hasMixedSelectedColors &amp;&amp; selectedBaseColor.toLowerCase() === option.value;
            return (
              &lt;button
                key={option.value}
                type=&quot;button&quot;
                onClick={() =&gt; applyBulkColor(option.value)}
                className={`flex-1 flex items-center justify-center gap-1 py-1 sm:py-1.5 rounded-md border transition-colors
                  ${isActive ? &quot;border-BrandOrange bg-BrandBlack&quot; : &quot;border-BrandGray2 bg-BrandBlack2 hover:bg-BrandBlack2/90&quot;}`}
              &gt;
                &lt;span
                  className=&quot;w-2.5 h-2.5 sm:w-3 sm:h-3 rounded-full&quot;
                  style={{ backgroundColor: option.value }}
                /&gt;
                &lt;span className={`text-[10px] sm:text-xs font-DmSans ${isActive ? &quot;text-BrandWhite&quot; : &quot;text-BrandGray&quot;}`}&gt;
                  {option.label}
                &lt;/span&gt;
              &lt;/button&gt;
            );
          })}
        &lt;/div&gt;
        {hasMixedSelectedColors &amp;&amp; (
          &lt;div className=&quot;text-[9px] sm:text-[10px] text-BrandGray font-DmSans&quot;&gt;Mixed colors selected&lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div className=&quot;flex flex-row w-full items-center justify-between&quot;&gt;
        &lt;p className=&quot;text-BrandOrange text-[10px] sm:text-xs md:text-sm font-DmSans&quot;&gt; Show Number:&lt;/p&gt;
        &lt;button
          type=&quot;button&quot;
          onClick={() =&gt; updateAllPlayersDisplay({ showNumber: !showNumber })}
          className=&quot;focus:outline-none cursor-pointer&quot;
        &gt;
          {showNumber ? (
            &lt;ImCheckboxChecked className=&quot;text-BrandOrange w-3 h-3 sm:w-3.5 sm:h-3.5 md:w-4 md:h-4&quot; /&gt;
          ) : (
            &lt;ImCheckboxUnchecked className=&quot;text-BrandGray2 w-3 h-3 sm:w-3.5 sm:h-3.5 md:w-4 md:h-4&quot; /&gt;
          )}
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex flex-row w-full items-center justify-between&quot;&gt;
        &lt;p className=&quot;text-BrandOrange text-[10px] sm:text-xs md:text-sm font-DmSans&quot;&gt; Show Name:&lt;/p&gt;
        &lt;button
          type=&quot;button&quot;
          onClick={() =&gt; updateAllPlayersDisplay({ showName: !showName })}
          className=&quot;focus:outline-none cursor-pointer&quot;
        &gt;
          {showName ? (
            &lt;ImCheckboxChecked className=&quot;text-BrandOrange w-3 h-3 sm:w-3.5 sm:h-3.5 md:w-4 md:h-4&quot; /&gt;
          ) : (
            &lt;ImCheckboxUnchecked className=&quot;text-BrandGray2 w-3 h-3 sm:w-3.5 sm:h-3.5 md:w-4 md:h-4&quot; /&gt;
          )}
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div className=&quot;w-full flex flex-col gap-1 pt-1&quot;&gt;
        {selectedPlayers.map((player) =&gt; {
          if (!player) return null;
          const checked = selectedForBulk.has(player.id);
          return (
            &lt;div
              key={player.id}
              className=&quot;w-full flex items-center justify-between bg-BrandBlack2 border border-BrandGray2 rounded-md px-1.5 py-1&quot;
            &gt;
              &lt;div className=&quot;flex-1 min-w-0 flex items-center gap-1&quot;&gt;
                &lt;span className=&quot;text-BrandOrange text-[10px] sm:text-xs font-DmSans font-bold&quot;&gt;
                  {player.number ?? &quot;&quot;}
                &lt;/span&gt;
                &lt;span className=&quot;text-BrandGray text-[10px] sm:text-xs font-DmSans truncate&quot;&gt;
                  {player.name ?? &quot;&quot;}
                &lt;/span&gt;
              &lt;/div&gt;
              &lt;button
                type=&quot;button&quot;
                onClick={() =&gt; toggleBulkSelection(player.id)}
                className=&quot;focus:outline-none cursor-pointer&quot;
                aria-label=&quot;Toggle bulk selection&quot;
              &gt;
                {checked ? (
                  &lt;ImCheckboxChecked className=&quot;text-BrandOrange w-3 h-3 sm:w-3.5 sm:h-3.5&quot; /&gt;
                ) : (
                  &lt;ImCheckboxUnchecked className=&quot;text-BrandGray2 w-3 h-3 sm:w-3.5 sm:h-3.5&quot; /&gt;
                )}
              &lt;/button&gt;
            &lt;/div&gt;
          );
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/sidebar/AddPlayerSection.jsx">import { BsPersonAdd } from &quot;react-icons/bs&quot;;
import { IoChevronDownOutline } from &quot;react-icons/io5&quot;;
import { SidebarChevronButton, WideSidebarRowButton } from &quot;../subcomponents/Buttons&quot;;
import { Popover, PopoverForm, Tooltip } from &quot;../subcomponents/Popovers&quot;;

const iconClass = &quot;text-BrandOrange text-xl sm:text-2xl md:text-3xl&quot;;
const selectedIconClass = &quot;text-BrandBlack text-xl sm:text-2xl md:text-3xl&quot;;

export default function AddPlayerSection({
    isSelected,
    openPopover,
    hoveredTooltip,
    numberValue,
    nameValue,
    playerSearch,
    showPlayerDropdown,
    filteredPlayers,
    anchorRef,
    dropdownRef,
    onToolSelect,
    onPopoverToggle,
    onPopoverClose,
    onNumberChange,
    onNameChange,
    onPlayerSearchChange,
    onPlayerAssign,
    onShowPlayerDropdownChange,
    onHoverTooltip,
    onAddPlayer,
    onQuickAdd,
    wide = false,
}) {
    const popoverKey = &quot;addPlayer&quot;;
    const isOpen = openPopover === popoverKey;
    const ButtonComponent = wide ? WideSidebarRowButton : SidebarChevronButton;
    const handleSubmit = () =&gt; {
        onAddPlayer?.({
            number: numberValue,
            name: nameValue,
            assignment: playerSearch,
        });
    };
    const handleKeyDown = (e) =&gt; {
        if (e.key !== &quot;Enter&quot;) return;
        e.preventDefault();
        handleSubmit();
    };

    return (
        &lt;div
            className=&quot;relative&quot;
            onMouseEnter={() =&gt; onHoverTooltip?.(&quot;addPlayer&quot;)}
            onMouseLeave={() =&gt; onHoverTooltip?.(null)}
        &gt;
            &lt;ButtonComponent
                ref={anchorRef}
                Icon={&lt;BsPersonAdd className={isSelected ? selectedIconClass : iconClass} /&gt;}
                label=&quot;Add Player&quot;
                onHover={() =&gt; {}}
                isSelected={isSelected}
                chevronActive={isOpen}
                onClick={() =&gt; onQuickAdd?.()}
                onRowClick={() =&gt; onToolSelect?.(&quot;addPlayer&quot;)}
                onChevronClick={() =&gt; onPopoverToggle?.(popoverKey)}
            /&gt;
            &lt;Tooltip isOpen={hoveredTooltip === &quot;addPlayer&quot; &amp;&amp; !isOpen} text=&quot;Add Player (A)&quot; /&gt;
            &lt;Popover isOpen={isOpen} onClose={onPopoverClose} anchorRef={anchorRef}&gt;
                &lt;PopoverForm&gt;
                    &lt;div className=&quot;flex flex-col gap-1.5 sm:gap-2&quot;&gt;
                        &lt;div className=&quot;flex flex-col gap-0.5 sm:gap-1&quot;&gt;
                            &lt;p className=&quot;text-BrandOrange text-xs sm:text-sm&quot;&gt;Number:&lt;/p&gt;
                            &lt;input
                                type=&quot;text&quot;
                                className=&quot;w-full h-8 sm:h-9 bg-BrandBlack border-[0.5px] border-BrandGray text-BrandWhite rounded-md px-2 text-xs sm:text-sm focus:outline-none focus:border-BrandOrange transition-colors&quot;
                                value={numberValue ?? &quot;&quot;}
                                onChange={(e) =&gt; onNumberChange?.(e.target.value)}
                                onKeyDown={handleKeyDown}
                            /&gt;
                        &lt;/div&gt;
                        &lt;div className=&quot;flex flex-col gap-0.5 sm:gap-1&quot;&gt;
                            &lt;p className=&quot;text-BrandOrange text-xs sm:text-sm&quot;&gt;Name:&lt;/p&gt;
                            &lt;input
                                type=&quot;text&quot;
                                className=&quot;w-full h-8 sm:h-9 bg-BrandBlack border-[0.5px] border-BrandGray text-BrandWhite rounded-md px-2 text-xs sm:text-sm focus:outline-none focus:border-BrandOrange transition-colors&quot;
                                value={nameValue ?? &quot;&quot;}
                                onChange={(e) =&gt; onNameChange?.(e.target.value)}
                                onKeyDown={handleKeyDown}
                            /&gt;
                        &lt;/div&gt;
                        &lt;div className=&quot;flex flex-col gap-0.5 sm:gap-1 relative&quot;&gt;
                            &lt;p className=&quot;text-BrandOrange text-xs sm:text-sm&quot;&gt;Assign To:&lt;/p&gt;
                            &lt;div className=&quot;relative&quot;&gt;
                                &lt;div className=&quot;w-full h-8 sm:h-9 bg-BrandBlack border-[0.5px] border-BrandGray rounded-md flex items-center overflow-hidden&quot;&gt;
                                    &lt;input
                                        type=&quot;text&quot;
                                        className=&quot;flex-1 min-w-0 h-8 sm:h-9 bg-transparent border-r-[0.5px] border-BrandGray text-BrandWhite px-2 text-xs sm:text-sm focus:outline-none focus:border-BrandOrange transition-colors rounded-l-md&quot;
                                        placeholder=&quot;Search player&quot;
                                        value={playerSearch}
                                        onChange={(e) =&gt; onPlayerSearchChange?.(e.target.value)}
                                        onFocus={() =&gt; onShowPlayerDropdownChange?.(true)}
                                        onKeyDown={handleKeyDown}
                                    /&gt;
                                    &lt;button
                                        onClick={() =&gt; onShowPlayerDropdownChange?.(!showPlayerDropdown)}
                                        className=&quot;h-8 sm:h-9 w-8 sm:w-9 flex items-center justify-center transition-colors rounded-r-md shrink-0&quot;
                                    &gt;
                                        &lt;IoChevronDownOutline
                                            className={`text-BrandOrange text-base sm:text-lg transition-transform ${showPlayerDropdown ? &quot;rotate-180&quot; : &quot;&quot;}`}
                                        /&gt;
                                    &lt;/button&gt;
                                &lt;/div&gt;
                                {showPlayerDropdown &amp;&amp; (
                                    &lt;div
                                        ref={dropdownRef}
                                        className=&quot;absolute left-0 top-full w-full bg-BrandBlack border border-BrandGray rounded-md mt-1 max-h-40 overflow-y-auto z-10 shadow-lg&quot;
                                    &gt;
                                        {filteredPlayers?.length &gt; 0 ? (
                                            filteredPlayers.map((player, idx) =&gt; (
                                                &lt;div
                                                    key={idx}
                                                    onClick={() =&gt; {
                                                        onPlayerAssign?.(player);
                                                        onShowPlayerDropdownChange?.(false);
                                                    }}
                                                    className=&quot;px-2 py-1 text-BrandWhite hover:bg-BrandOrange hover:text-BrandBlack cursor-pointer transition-colors text-xs sm:text-sm truncate&quot;
                                                &gt;
                                                    {player}
                                                &lt;/div&gt;
                                            ))
                                        ) : (
                                            &lt;div className=&quot;px-2 py-1 text-BrandGray text-xs&quot;&gt;No players found&lt;/div&gt;
                                        )}
                                    &lt;/div&gt;
                                )}
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;button
                            type=&quot;button&quot;
                            onClick={handleSubmit}
                            className=&quot;w-full h-8 sm:h-9 bg-BrandOrange text-BrandBlack rounded-md text-xs sm:text-sm font-DmSans font-semibold hover:bg-BrandOrange/90 transition-colors mt-1&quot;
                        &gt;
                            Add Player
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/PopoverForm&gt;
            &lt;/Popover&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/sidebar/EraserToolSection.jsx">import { PiEraserFill } from &quot;react-icons/pi&quot;;
import { FaRegCircle } from &quot;react-icons/fa&quot;;
import { TbCircleDotted } from &quot;react-icons/tb&quot;;
import { SidebarChevronButton, WideSidebarRowButton } from &quot;../subcomponents/Buttons&quot;;
import { Popover, PopoverGrid, Tooltip } from &quot;../subcomponents/Popovers&quot;;

const iconClass = &quot;text-BrandOrange text-xl sm:text-2xl md:text-3xl&quot;;
const selectedIconClass = &quot;text-BrandBlack text-xl sm:text-2xl md:text-3xl&quot;;

export default function EraserToolSection({
    eraserToolType,
    isSelected,
    openPopover,
    hoveredTooltip,
    anchorRef,
    onToolSelect,
    onEraserSubTool,
    onPopoverToggle,
    onPopoverClose,
    onHoverTooltip,
    wide = false,
}) {
    const popoverKey = &quot;eraserOptions&quot;;
    const isOpen = openPopover === popoverKey;
    const ButtonComponent = wide ? WideSidebarRowButton : SidebarChevronButton;

    return (
        &lt;div
            className=&quot;relative&quot;
            onMouseEnter={() =&gt; onHoverTooltip?.(&quot;eraser&quot;)}
            onMouseLeave={() =&gt; onHoverTooltip?.(null)}
        &gt;
            &lt;ButtonComponent
                ref={anchorRef}
                Icon={&lt;PiEraserFill className={isSelected ? selectedIconClass : iconClass} /&gt;}
                {...(wide &amp;&amp; { label: &quot;Eraser&quot; })}
                onHover={() =&gt; {}}
                isSelected={isSelected}
                chevronActive={isOpen}
                onClick={() =&gt; onToolSelect?.(&quot;eraser&quot;)}
                onRowClick={() =&gt; onToolSelect?.(&quot;eraser&quot;)}
                onChevronClick={() =&gt; onPopoverToggle?.(popoverKey)}
            /&gt;
            &lt;Tooltip isOpen={hoveredTooltip === &quot;eraser&quot; &amp;&amp; !isOpen} text=&quot;Eraser Tool (E)&quot; /&gt;
            &lt;Popover isOpen={isOpen} onClose={onPopoverClose} anchorRef={anchorRef}&gt;
                &lt;PopoverGrid cols={2}&gt;
                    &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                        &lt;button
                            onClick={() =&gt; onEraserSubTool?.(&quot;full&quot;)}
                            className={`
                                rounded-md border border-BrandGray
                                flex items-center justify-center
                                p-2 aspect-square w-full
                                transition-all duration-100
                                ${eraserToolType === &quot;full&quot; ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/80&quot;}
                            `}
                        &gt;
                            &lt;FaRegCircle className={eraserToolType === &quot;full&quot; ? selectedIconClass : iconClass} /&gt;
                        &lt;/button&gt;
                        &lt;span className=&quot;text-[10px] text-BrandOrange&quot;&gt;Full (F)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                        &lt;button
                            onClick={() =&gt; onEraserSubTool?.(&quot;partial&quot;)}
                            className={`
                                rounded-md border border-BrandGray
                                flex items-center justify-center
                                p-2 aspect-square w-full
                                transition-all duration-100
                                ${eraserToolType === &quot;partial&quot; ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/80&quot;}
                            `}
                        &gt;
                            &lt;TbCircleDotted className={eraserToolType === &quot;partial&quot; ? selectedIconClass : iconClass} /&gt;
                        &lt;/button&gt;
                        &lt;span className=&quot;text-[10px] text-BrandOrange&quot;&gt;Partial (O)&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/PopoverGrid&gt;
            &lt;/Popover&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/sidebar/HistoryActionsSection.jsx">import { Button, WideSidebarRowButton } from &quot;../subcomponents/Buttons&quot;;
import { Tooltip } from &quot;../subcomponents/Popovers&quot;;
import { BiUndo, BiRedo, BiReset } from &quot;react-icons/bi&quot;;

const iconClass = &quot;text-BrandOrange text-xl sm:text-2xl md:text-3xl&quot;;

export default function HistoryActionsSection({ onUndo, onRedo, onReset, hoveredTooltip, onHoverTooltip, wide = false }) {
    const actions = [
        { key: &quot;undo&quot;, Icon: &lt;BiUndo className={iconClass} /&gt;, label: &quot;Undo&quot;, onClick: onUndo },
        { key: &quot;redo&quot;, Icon: &lt;BiRedo className={iconClass} /&gt;, label: &quot;Redo&quot;, onClick: onRedo },
        { key: &quot;reset&quot;, Icon: &lt;BiReset className={iconClass} /&gt;, label: &quot;Reset&quot;, onClick: onReset },
    ];

    if (wide) {
        return (
            &lt;div className=&quot;w-full flex flex-col gap-1 sm:gap-1.5&quot;&gt;
                {actions.map(({ key, Icon, label, onClick }) =&gt; (
                    &lt;div
                        key={key}
                        className=&quot;relative w-full&quot;
                        onMouseEnter={() =&gt; onHoverTooltip?.(key)}
                        onMouseLeave={() =&gt; onHoverTooltip?.(null)}
                    &gt;
                        &lt;WideSidebarRowButton
                            Icon={Icon}
                            label={label}
                            onHover={() =&gt; {}}
                            onClick={() =&gt; onClick?.()}
                            onRowClick={() =&gt; onClick?.()}
                            isSelected={false}
                        /&gt;
                        &lt;Tooltip isOpen={hoveredTooltip === key} text={label} /&gt;
                    &lt;/div&gt;
                ))}
            &lt;/div&gt;
        );
    }

    return (
        &lt;div className=&quot;w-full flex flex-col items-center gap-1 sm:gap-2 md:gap-3 lg:gap-4 p-1 py-2 lg:px-3&quot;&gt;
            {actions.map(({ key, Icon, label, onClick }) =&gt; (
                &lt;div
                    key={key}
                    className=&quot;relative w-full&quot;
                    onMouseEnter={() =&gt; onHoverTooltip?.(key)}
                    onMouseLeave={() =&gt; onHoverTooltip?.(null)}
                &gt;
                    &lt;Button
                        Icon={Icon}
                        onHover={() =&gt; {}}
                        onClick={() =&gt; onClick?.()}
                        isSelected={false}
                    /&gt;
                    &lt;Tooltip isOpen={hoveredTooltip === key} text={label} /&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}</file><file path="src/components/sidebar/PenToolSection.jsx">import { PiPenNib } from &quot;react-icons/pi&quot;;
import { FaArrowUpLong } from &quot;react-icons/fa6&quot;;
import { SidebarChevronButton, WideSidebarRowButton } from &quot;../subcomponents/Buttons&quot;;
import { Popover, PopoverGrid, Tooltip } from &quot;../subcomponents/Popovers&quot;;

const iconClass = &quot;text-BrandOrange text-xl sm:text-2xl md:text-3xl&quot;;
const selectedIconClass = &quot;text-BrandBlack text-xl sm:text-2xl md:text-3xl&quot;;

export default function PenToolSection({
    penToolType,
    isSelected,
    openPopover,
    hoveredTooltip,
    anchorRef,
    onToolSelect,
    onPenSubTool,
    onPopoverToggle,
    onPopoverClose,
    onHoverTooltip,
    wide = false,
}) {
    const popoverKey = &quot;penOptions&quot;;
    const isOpen = openPopover === popoverKey;
    const label = penToolType === &quot;arrow&quot; ? &quot;Arrow&quot; : &quot;Pen&quot;;
    const IconNode = penToolType === &quot;arrow&quot; ? (
        &lt;FaArrowUpLong
            className={isSelected ? selectedIconClass : iconClass}
            style={{ transform: &quot;rotate(45deg)&quot; }}
        /&gt;
    ) : (
        &lt;PiPenNib
            className={isSelected ? selectedIconClass : iconClass}
            style={{ transform: &quot;rotate(90deg)&quot; }}
        /&gt;
    );
    const ButtonComponent = wide ? WideSidebarRowButton : SidebarChevronButton;

    return (
        &lt;div
            className=&quot;relative&quot;
            onMouseEnter={() =&gt; onHoverTooltip?.(&quot;pen&quot;)}
            onMouseLeave={() =&gt; onHoverTooltip?.(null)}
        &gt;
            &lt;ButtonComponent
                ref={anchorRef}
                Icon={IconNode}
                {...(wide &amp;&amp; { label })}
                onHover={() =&gt; {}}
                isSelected={isSelected}
                chevronActive={isOpen}
                onClick={() =&gt; onToolSelect?.(&quot;pen&quot;)}
                onRowClick={() =&gt; onToolSelect?.(&quot;pen&quot;)}
                onChevronClick={() =&gt; onPopoverToggle?.(popoverKey)}
            /&gt;
            &lt;Tooltip
                isOpen={hoveredTooltip === &quot;pen&quot; &amp;&amp; !isOpen}
                text={penToolType === &quot;arrow&quot; ? &quot;Arrow Tool (Q)&quot; : &quot;Pen Tool (P)&quot;}
            /&gt;
            &lt;Popover isOpen={isOpen} onClose={onPopoverClose} anchorRef={anchorRef}&gt;
                &lt;PopoverGrid cols={2}&gt;
                    &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                        &lt;button
                            onClick={() =&gt; onPenSubTool?.(&quot;pen&quot;)}
                            className={`
                                rounded-md border border-BrandGray
                                flex items-center justify-center
                                p-2 aspect-square w-full
                                transition-all duration-100
                                ${penToolType === &quot;pen&quot; ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/80&quot;}
                            `}
                        &gt;
                            &lt;PiPenNib
                                className={penToolType === &quot;pen&quot; ? selectedIconClass : iconClass}
                                style={{ transform: &quot;rotate(90deg)&quot; }}
                            /&gt;
                        &lt;/button&gt;
                        &lt;span className=&quot;text-[10px] text-BrandOrange&quot;&gt;Pen (P)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                        &lt;button
                            onClick={() =&gt; onPenSubTool?.(&quot;arrow&quot;)}
                            className={`
                                rounded-md border border-BrandGray
                                flex items-center justify-center
                                p-2 aspect-square w-full
                                transition-all duration-100
                                ${penToolType === &quot;arrow&quot; ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/80&quot;}
                            `}
                        &gt;
                            &lt;FaArrowUpLong
                                className={penToolType === &quot;arrow&quot; ? selectedIconClass : iconClass}
                                style={{ transform: &quot;rotate(45deg)&quot; }}
                            /&gt;
                        &lt;/button&gt;
                        &lt;span className=&quot;text-[10px] text-BrandOrange&quot;&gt;Arrow (Q)&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/PopoverGrid&gt;
            &lt;/Popover&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/sidebar/PlayerColorSection.jsx">import { SidebarChevronButton, WideSidebarRowButton } from &quot;../subcomponents/Buttons&quot;;
import { Popover, PopoverGrid, Tooltip } from &quot;../subcomponents/Popovers&quot;;

const PLAYER_COLORS = { red: &quot;#ef4444&quot;, blue: &quot;#3b82f6&quot; };

export default function PlayerColorSection({
    playerColor,
    isSelected,
    openPopover,
    hoveredTooltip,
    anchorRef,
    onToolSelect,
    onPlayerColorChange,
    onPopoverToggle,
    onPopoverClose,
    onHoverTooltip,
    onQuickAdd,
    wide = false,
}) {
    const popoverKey = &quot;playerColor&quot;;
    const isOpen = openPopover === popoverKey;
    const ButtonComponent = wide ? WideSidebarRowButton : SidebarChevronButton;

    return (
        &lt;div
            className=&quot;relative&quot;
            onMouseEnter={() =&gt; onHoverTooltip?.(&quot;player&quot;)}
            onMouseLeave={() =&gt; onHoverTooltip?.(null)}
        &gt;
            &lt;ButtonComponent
                ref={anchorRef}
                Icon={
                    &lt;div
                        className=&quot;h-6 w-6 rounded-full border border-BrandBlack&quot;
                        style={{ backgroundColor: playerColor }}
                    /&gt;
                }
                label=&quot;Color&quot;
                onHover={() =&gt; {}}
                isSelected={isSelected}
                chevronActive={isOpen}
                onClick={() =&gt; onQuickAdd?.()}
                onRowClick={() =&gt; onToolSelect?.(&quot;color&quot;)}
                onChevronClick={() =&gt; onPopoverToggle?.(popoverKey)}
            /&gt;
            &lt;Tooltip isOpen={hoveredTooltip === &quot;player&quot; &amp;&amp; !isOpen} text=&quot;Switch Color (C)&quot; /&gt;
            &lt;Popover isOpen={isOpen} onClose={onPopoverClose} anchorRef={anchorRef}&gt;
                &lt;PopoverGrid cols={2}&gt;
                    &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                        &lt;button
                            onClick={() =&gt; onPlayerColorChange?.(PLAYER_COLORS.red)}
                            className={`
                                rounded-md border border-BrandGray
                                flex items-center justify-center
                                p-2 aspect-square w-full
                                transition-all duration-100
                                ${playerColor === PLAYER_COLORS.red ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/80&quot;}
                            `}
                        &gt;
                            &lt;div
                                className=&quot;h-5 w-5 md:h-7 md:w-7 rounded-full border border-BrandBlack&quot;
                                style={{ backgroundColor: PLAYER_COLORS.red }}
                            /&gt;
                        &lt;/button&gt;
                        &lt;span className=&quot;text-[10px] text-BrandOrange&quot;&gt;Red&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                        &lt;button
                            onClick={() =&gt; onPlayerColorChange?.(PLAYER_COLORS.blue)}
                            className={`
                                rounded-md border border-BrandGray
                                flex items-center justify-center
                                p-2 aspect-square w-full
                                transition-all duration-100
                                ${playerColor === PLAYER_COLORS.blue ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/80&quot;}
                            `}
                        &gt;
                            &lt;div
                                className=&quot;h-5 w-5 md:h-7 md:w-7 rounded-full border border-BrandBlack&quot;
                                style={{ backgroundColor: PLAYER_COLORS.blue }}
                            /&gt;
                        &lt;/button&gt;
                        &lt;span className=&quot;text-[10px] text-BrandOrange&quot;&gt;Blue&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/PopoverGrid&gt;
            &lt;/Popover&gt;
        &lt;/div&gt;
    );
}

export { PLAYER_COLORS };</file><file path="src/components/sidebar/PrefabsSection.jsx">import { TbCopyPlusFilled } from &quot;react-icons/tb&quot;;
import { SidebarChevronButton, WideSidebarRowButton } from &quot;../subcomponents/Buttons&quot;;
import { Popover, Tooltip } from &quot;../subcomponents/Popovers&quot;;
import { PrefabsPopover } from &quot;../subcomponents/PrefabsPopover&quot;;

const iconClass = &quot;text-BrandOrange text-xl sm:text-2xl md:text-3xl&quot;;

export default function PrefabsSection({
    prefabs,
    openPopover,
    hoveredTooltip,
    anchorRef,
    onPopoverToggle,
    onPopoverClose,
    onPrefabSelect,
    onHoverTooltip,
    wide = false,
}) {
    const popoverKey = &quot;prefabs&quot;;
    const isOpen = openPopover === popoverKey;
    const ButtonComponent = wide ? WideSidebarRowButton : SidebarChevronButton;

    const handlePrefabSelect = (prefab) =&gt; {
        onPrefabSelect?.(prefab);
        onPopoverClose?.();
    };

    return (
        &lt;div
            className=&quot;relative&quot;
            onMouseEnter={() =&gt; onHoverTooltip?.(&quot;prefabs&quot;)}
            onMouseLeave={() =&gt; onHoverTooltip?.(null)}
        &gt;
            &lt;ButtonComponent
                ref={anchorRef}
                Icon={&lt;TbCopyPlusFilled className={iconClass} /&gt;}
                label=&quot;Prefabs&quot;
                onHover={() =&gt; {}}
                isSelected={false}
                chevronActive={isOpen}
                onClick={() =&gt; {}}
                onRowClick={() =&gt; onPopoverToggle?.(popoverKey)}
                onChevronClick={() =&gt; onPopoverToggle?.(popoverKey)}
            /&gt;
            &lt;Tooltip isOpen={hoveredTooltip === &quot;prefabs&quot; &amp;&amp; !isOpen} text=&quot;Prefabs&quot; /&gt;
            &lt;Popover isOpen={isOpen} onClose={onPopoverClose} anchorRef={anchorRef} topOffset=&quot;top-[-150px]&quot;&gt;
                &lt;PrefabsPopover prefabs={prefabs} onPrefabSelect={handlePrefabSelect} /&gt;
            &lt;/Popover&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/sidebar/README.md"># Sidebar sections (`src/components/sidebar/`)

This folder contains the **Sidebar** (narrow, icon-only) and its section subcomponents. The public entry for the narrow sidebar is `src/components/Sidebar.jsx`, which renders `SidebarRoot` from here.

**Note:** The app currently mounts **WideSidebar** (`src/components/WideSidebar.jsx` / `src/components/wideSidebar/`) instead of Sidebar. Sidebar is kept in the codebase but unmounted. WideSidebar reuses these same section components with `wide={true}` to show icon + tool name in a row.

## Structure

```
sidebar/
├── README.md               # This file
├── SidebarRoot.jsx         # Narrow sidebar: layout, state, callbacks
├── SelectToolSection.jsx   # Select/Hand (supports wide prop)
├── PenToolSection.jsx      # Pen/Arrow (supports wide prop)
├── EraserToolSection.jsx   # Eraser (supports wide prop)
├── AddPlayerSection.jsx    # Add Player (supports wide prop)
├── PlayerColorSection.jsx  # Player color (supports wide prop)
├── PrefabsSection.jsx      # Prefabs (supports wide prop)
└── HistoryActionsSection.jsx # Undo, Redo, Reset (supports wide prop)
```

## Callbacks (state sent up)

All callbacks are optional. Sidebar works standalone.

| Callback | When called |
|----------|-------------|
| `onToolChange(tool)` | Current tool: `&quot;select&quot;` \| `&quot;hand&quot;` \| `&quot;pen&quot;` \| `&quot;eraser&quot;` \| `&quot;addPlayer&quot;` \| `&quot;player&quot;` \| `&quot;prefab&quot;` |
| `onSelectSubTool?(subTool)` | User picks Select or Hand in the select popover |
| `onPenSubTool?(subTool)` | User picks Pen or Arrow in the pen popover |
| `onEraserSubTool?(subTool)` | User picks Full or Partial in the eraser popover |
| `onPlayerColorChange?(hex)` | User picks a color in the player-color popover |
| `onUndo?()` | User clicks Undo |
| `onRedo?()` | User clicks Redo |
| `onReset?()` | User clicks Reset |
| `onPrefabSelect?(prefab)` | User selects a prefab in the Prefabs popover |
| `onAddPlayer?(data)` | Reserved for add-player form submit |

## Usage (from App)

The app uses **WideSidebar**; to use the narrow Sidebar instead, swap the import and component:

```jsx
import WideSidebar from &apos;./components/WideSidebar&apos;;  // current
// import Sidebar from &apos;./components/Sidebar&apos;;       // narrow, icon-only

&lt;WideSidebar
  onToolChange={(tool) =&gt; { if (tool === &quot;hand&quot; || tool === &quot;select&quot;) setCanvasTool(tool); }}
  onUndo={onUndo}
  onRedo={onRedo}
  onReset={onReset}
/&gt;
```

## Optional props from parent

- `players` – list for Add Player “Assign To” dropdown (defaults to built-in list if not passed)
- `prefabs` – list for Prefabs popover (defaults to built-in list if not passed)</file><file path="src/components/sidebar/SelectToolSection.jsx">import { LuMousePointer2 } from &quot;react-icons/lu&quot;;
import { IoHandLeftOutline } from &quot;react-icons/io5&quot;;
import { SidebarChevronButton, WideSidebarRowButton } from &quot;../subcomponents/Buttons&quot;;
import { Popover, PopoverGrid, Tooltip } from &quot;../subcomponents/Popovers&quot;;

const iconClass = &quot;text-BrandOrange text-xl sm:text-2xl md:text-3xl&quot;;
const selectedIconClass = &quot;text-BrandBlack text-xl sm:text-2xl md:text-3xl&quot;;

export default function SelectToolSection({
    selectToolType,
    isSelected,
    openPopover,
    hoveredTooltip,
    anchorRef,
    onToolSelect,
    onSelectSubTool,
    onPopoverToggle,
    onPopoverClose,
    onHoverTooltip,
    wide = false,
}) {
    const popoverKey = &quot;selectOptions&quot;;
    const isOpen = openPopover === popoverKey;
    const label = selectToolType === &quot;hand&quot; ? &quot;Hand&quot; : &quot;Select&quot;;
    const IconNode = selectToolType === &quot;hand&quot; ? (
        &lt;IoHandLeftOutline className={isSelected ? selectedIconClass : iconClass} /&gt;
    ) : (
        &lt;LuMousePointer2 className={isSelected ? selectedIconClass : iconClass} /&gt;
    );

    const ButtonComponent = wide ? WideSidebarRowButton : SidebarChevronButton;

    return (
        &lt;div
            className=&quot;relative&quot;
            onMouseEnter={() =&gt; onHoverTooltip?.(&quot;select&quot;)}
            onMouseLeave={() =&gt; onHoverTooltip?.(null)}
        &gt;
            &lt;ButtonComponent
                ref={anchorRef}
                Icon={IconNode}
                {...(wide &amp;&amp; { label })}
                onHover={() =&gt; {}}
                isSelected={isSelected}
                chevronActive={isOpen}
                onClick={() =&gt; onToolSelect?.(selectToolType)}
                onRowClick={() =&gt; onToolSelect?.(selectToolType)}
                onChevronClick={() =&gt; onPopoverToggle?.(popoverKey)}
            /&gt;
            &lt;Tooltip
                isOpen={hoveredTooltip === &quot;select&quot; &amp;&amp; !isOpen}
                text={selectToolType === &quot;hand&quot; ? &quot;Hand Tool (H)&quot; : &quot;Select Tool (S)&quot;}
            /&gt;
            &lt;Popover isOpen={isOpen} onClose={onPopoverClose} anchorRef={anchorRef}&gt;
                &lt;PopoverGrid cols={2}&gt;
                    &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                        &lt;button
                            onClick={() =&gt; onSelectSubTool?.(&quot;select&quot;)}
                            className={`
                                rounded-md border border-BrandGray
                                flex items-center justify-center
                                p-2 aspect-square w-full
                                transition-all duration-100
                                ${selectToolType === &quot;select&quot; ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/80&quot;}
                            `}
                        &gt;
                            &lt;LuMousePointer2 className={selectToolType === &quot;select&quot; ? selectedIconClass : iconClass} /&gt;
                        &lt;/button&gt;
                        &lt;span className=&quot;text-[10px] text-BrandOrange&quot;&gt;Select (S)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                        &lt;button
                            onClick={() =&gt; onSelectSubTool?.(&quot;hand&quot;)}
                            className={`
                                rounded-md border border-BrandGray
                                flex items-center justify-center
                                p-2 aspect-square w-full
                                transition-all duration-100
                                ${selectToolType === &quot;hand&quot; ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/80&quot;}
                            `}
                        &gt;
                            &lt;IoHandLeftOutline className={selectToolType === &quot;hand&quot; ? selectedIconClass : iconClass} /&gt;
                        &lt;/button&gt;
                        &lt;span className=&quot;text-[10px] text-BrandOrange&quot;&gt;Hand (H)&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/PopoverGrid&gt;
            &lt;/Popover&gt;
        &lt;/div&gt;
    );
}</file><file path="src/components/sidebar/SidebarRoot.jsx">import { useState, useEffect, useRef } from &quot;react&quot;;
import rugbyScrum from &quot;../../assets/prefabIcons/Rugby Scrum.png&quot;;
import rugbyLineout from &quot;../../assets/prefabIcons/Rugby Lineout.png&quot;;
import rugbyKickoff from &quot;../../assets/prefabIcons/Rugby KickOff.png&quot;;

import SelectToolSection from &quot;./SelectToolSection&quot;;
import PenToolSection from &quot;./PenToolSection&quot;;
import EraserToolSection from &quot;./EraserToolSection&quot;;
import AddPlayerSection from &quot;./AddPlayerSection&quot;;
import PlayerColorSection, { PLAYER_COLORS } from &quot;./PlayerColorSection&quot;;
import PrefabsSection from &quot;./PrefabsSection&quot;;
import HistoryActionsSection from &quot;./HistoryActionsSection&quot;;

const DEFAULT_PLAYERS = [
    &quot;Tommy Kilbane&quot;, &quot;Tristan Arndt&quot;, &quot;Tommy Graham&quot;, &quot;Trenton Bui&quot;, &quot;Ty Johnson&quot;,
    &quot;Trey Burkhart&quot;, &quot;Trey Lundy&quot;, &quot;Trevor Jackson&quot;, &quot;Trevor Simms&quot;, &quot;Tyler Banks&quot;,
    &quot;Tyler Davis&quot;, &quot;Tyler Gray&quot;, &quot;Tyler Smith&quot;, &quot;Tyler Wilson&quot;, &quot;Zachary Breaux&quot;,
    &quot;Zachary Brown&quot;, &quot;Zachary Chavez&quot;, &quot;Zachary Davis&quot;, &quot;Zachary Green&quot;, &quot;Zachary Johnson&quot;,
    &quot;Zachary Lee&quot;, &quot;Zachary Martin&quot;, &quot;Zachary Martinez&quot;, &quot;Zachary Miller&quot;, &quot;Zachary Mitchell&quot;,
    &quot;Zachary Moore&quot;, &quot;Zachary Nelson&quot;, &quot;Zachary Phillips&quot;, &quot;Zachary Robinson&quot;, &quot;Zachary Rodriguez&quot;,
    &quot;Zachary Scott&quot;, &quot;Zachary Smith&quot;, &quot;Zachary Taylor&quot;, &quot;Zachary Thompson&quot;, &quot;Zachary Walker&quot;,
    &quot;Zachary Wilson&quot;, &quot;Zachary Young&quot;,
];

const iconClass = &quot;text-BrandOrange text-xl sm:text-2xl md:text-3xl&quot;;

function buildDefaultPrefabs() {
    return [
        {
            id: &quot;lineout&quot;,
            label: &quot;Lineout&quot;,
            mode: &quot;offense&quot;,
            icon: &lt;img src={rugbyLineout} alt=&quot;Lineout&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Number of Players&quot;, options: [&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;], value: &quot;5&quot;, onChange: (v) =&gt; console.log(&quot;Lineout players:&quot;, v) }],
        },
        {
            id: &quot;scrum&quot;,
            label: &quot;Scrum&quot;,
            mode: &quot;offense&quot;,
            icon: &lt;img src={rugbyScrum} alt=&quot;Scrum&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Number of Players&quot;, options: [&quot;3&quot;, &quot;8&quot;], value: &quot;3&quot;, onChange: (v) =&gt; console.log(&quot;Scrum players:&quot;, v) }],
        },
        {
            id: &quot;kickoff1&quot;,
            label: &quot;Kickoff&quot;,
            mode: &quot;offense&quot;,
            icon: &lt;img src={rugbyKickoff} alt=&quot;Kickoff&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Area&quot;, options: [&quot;Goal Line&quot;, &quot;22&quot;, &quot;50&quot;], value: &quot;5&quot;, onChange: (v) =&gt; console.log(&quot;Kickoff area:&quot;, v) }],
        },
        {
            id: &quot;scrum1&quot;,
            label: &quot;Scrum&quot;,
            mode: &quot;defense&quot;,
            icon: &lt;img src={rugbyLineout} alt=&quot;Lineout&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Formation&quot;, options: [&quot;3&quot;, &quot;8&quot;], value: &quot;3&quot;, onChange: (v) =&gt; console.log(&quot;Scrum formation:&quot;, v) }],
        },
        {
            id: &quot;lineout2&quot;,
            label: &quot;Lineout&quot;,
            mode: &quot;defense&quot;,
            icon: &lt;img src={rugbyLineout} alt=&quot;Lineout&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Players&quot;, options: [&quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;], value: &quot;4&quot;, onChange: (v) =&gt; console.log(&quot;Lineout players:&quot;, v) }],
        },
        {
            id: &quot;kickoff2&quot;,
            label: &quot;Kickoff&quot;,
            mode: &quot;defense&quot;,
            icon: &lt;img src={rugbyKickoff} alt=&quot;Kickoff&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Area&quot;, options: [&quot;Goal Line&quot;, &quot;22&quot;, &quot;50&quot;], value: &quot;Goal Line&quot;, onChange: (v) =&gt; console.log(&quot;Kickoff area:&quot;, v) }],
        },
    ];
}

export default function SidebarRoot({
    onToolChange,
    onSelectSubTool,
    onPenSubTool,
    onEraserSubTool,
    onPlayerColorChange,
    onUndo,
    onRedo,
    onReset,
    onDeleteSelected,
    onPrefabSelect,
    onAddPlayer,
    players: playersProp,
    prefabs: prefabsProp,
}) {
    const [selectedTool, setSelectedTool] = useState(&quot;select&quot;);
    const [selectToolType, setSelectToolType] = useState(&quot;select&quot;);
    const [penToolType, setPenToolType] = useState(&quot;pen&quot;);
    const [eraserToolType, setEraserToolType] = useState(&quot;eraser&quot;);
    const [openPopover, setOpenPopover] = useState(null);
    const [playerNumber, setPlayerNumber] = useState(&quot;&quot;);
    const [playerName, setPlayerName] = useState(&quot;&quot;);
    const [playerSearch, setPlayerSearch] = useState(&quot;&quot;);
    const [showPlayerDropdown, setShowPlayerDropdown] = useState(false);
    const [playerColor, setPlayerColor] = useState(PLAYER_COLORS.red);
    const [hoveredTooltip, setHoveredTooltip] = useState(null);

    const selectButtonRef = useRef(null);
    const penButtonRef = useRef(null);
    const eraserButtonRef = useRef(null);
    const addPlayerButtonRef = useRef(null);
    const playerButtonRef = useRef(null);
    const prefabsButtonRef = useRef(null);
    const playerDropdownRef = useRef(null);

    const players = playersProp ?? DEFAULT_PLAYERS;
    const prefabs = prefabsProp ?? buildDefaultPrefabs();
    const filteredPlayers = players.filter((p) =&gt;
        String(p).toLowerCase().includes(playerSearch.toLowerCase())
    );

    const togglePopover = (key) =&gt; {
        setOpenPopover((prev) =&gt; (prev === key ? null : key));
    };
    const closePopover = () =&gt; setOpenPopover(null);

    const handleSelectSubTool = (option) =&gt; {
        setSelectToolType(option);
        setSelectedTool(option);
        closePopover();
        onSelectSubTool?.(option);
    };
    const handlePenSubTool = (option) =&gt; {
        setPenToolType(option);
        setSelectedTool(&quot;pen&quot;);
        closePopover();
        onPenSubTool?.(option);
    };
    const handleEraserSubTool = (option) =&gt; {
        setEraserToolType(option);
        setSelectedTool(&quot;eraser&quot;);
        closePopover();
        onEraserSubTool?.(option);
    };
    const handlePlayerColorChange = (hex) =&gt; {
        setPlayerColor(hex);
        closePopover();
        onPlayerColorChange?.(hex);
    };
    const handlePrefabSelect = (prefab) =&gt; {
        setSelectedTool(&quot;prefab&quot;);
        onPrefabSelect?.(prefab);
    };
    const handlePlayerAssign = (name) =&gt; {
        setPlayerSearch(name);
        setShowPlayerDropdown(false);
    };
    const handleAddPlayer = (data) =&gt; {
        const next = {
            number: data?.number ?? playerNumber,
            name: data?.name ?? playerName,
            assignment: data?.assignment ?? playerSearch,
            color: playerColor,
        };
        const hasValue =
            String(next.number ?? &quot;&quot;).trim() !== &quot;&quot; ||
            String(next.name ?? &quot;&quot;).trim() !== &quot;&quot; ||
            String(next.assignment ?? &quot;&quot;).trim() !== &quot;&quot;;
        if (!hasValue) return;
        onAddPlayer?.(next);
        setPlayerNumber(&quot;&quot;);
        setPlayerName(&quot;&quot;);
        setPlayerSearch(&quot;&quot;);
        setShowPlayerDropdown(false);
    };
    const handleQuickAddPlayer = () =&gt; {
        onAddPlayer?.({ color: playerColor });
    };

    useEffect(() =&gt; {
        onToolChange?.(selectedTool);
    }, [selectedTool, onToolChange]);

    useEffect(() =&gt; {
        const handleKeyDown = (e) =&gt; {
            const tag = e.target.tagName;
            if (tag === &quot;INPUT&quot; || tag === &quot;TEXTAREA&quot; || e.target.isContentEditable) return;
            if (e.ctrlKey || e.metaKey) {
                const key = e.key.toLowerCase();
                if (key === &quot;z&quot;) {
                    e.preventDefault();
                    onUndo?.();
                    return;
                }
                if (key === &quot;y&quot;) {
                    e.preventDefault();
                    onRedo?.();
                    return;
                }
                if (key === &quot;d&quot;) {
                    e.preventDefault();
                    onDeleteSelected?.();
                    return;
                }
            }
            const key = e.key.toLowerCase();
            if (key === &quot;s&quot;) {
                setSelectToolType(&quot;select&quot;);
                setSelectedTool(&quot;select&quot;);
                closePopover();
            } else if (key === &quot;h&quot;) {
                setSelectToolType(&quot;hand&quot;);
                setSelectedTool(&quot;hand&quot;);
                closePopover();
            } else if (key === &quot;p&quot;) {
                handlePenSubTool(&quot;pen&quot;);
            } else if (key === &quot;q&quot;) {
                handlePenSubTool(&quot;arrow&quot;);
            } else if (key === &quot;e&quot;) {
                setSelectedTool(&quot;eraser&quot;);
                closePopover();
            } else if (key === &quot;f&quot;) {
                handleEraserSubTool(&quot;full&quot;);
            } else if (key === &quot;o&quot;) {
                handleEraserSubTool(&quot;partial&quot;);
            } else if (key === &quot;a&quot;) {
                setSelectedTool(&quot;addPlayer&quot;);
                closePopover();
            } else if (key === &quot;c&quot;) {
                const nextColor = playerColor === PLAYER_COLORS.red ? PLAYER_COLORS.blue : PLAYER_COLORS.red;
                handlePlayerColorChange(nextColor);
                setSelectedTool(&quot;color&quot;);
            }
        };
        window.addEventListener(&quot;keydown&quot;, handleKeyDown);
        return () =&gt; window.removeEventListener(&quot;keydown&quot;, handleKeyDown);
    }, [closePopover, handleEraserSubTool, handlePenSubTool, handlePlayerColorChange, onDeleteSelected, onRedo, onUndo, playerColor]);

    useEffect(() =&gt; {
        if (!showPlayerDropdown) return;
        const handleClickOutside = (e) =&gt; {
            const input = e.target.closest(&apos;input[placeholder=&quot;Search player&quot;]&apos;);
            const button = e.target.closest(&quot;button&quot;);
            const dropdown = playerDropdownRef.current;
            if (dropdown &amp;&amp; !dropdown.contains(e.target) &amp;&amp; !input &amp;&amp; !button) {
                setShowPlayerDropdown(false);
            }
        };
        document.addEventListener(&quot;mousedown&quot;, handleClickOutside);
        return () =&gt; document.removeEventListener(&quot;mousedown&quot;, handleClickOutside);
    }, [showPlayerDropdown]);

    useEffect(() =&gt; {
        if (openPopover !== &quot;addPlayer&quot;) setShowPlayerDropdown(false);
    }, [openPopover]);

    const hr = &lt;hr className=&quot;w-4/5 self-center border-BrandGray&quot; /&gt;;

    return (
        &lt;aside
            className=&quot;
                h-screen shrink-0 bg-BrandBlack
                w-14 sm:w-16 md:w-18 lg:w-20
                px-2 py-3 sm:py-4 md:py-5 lg:py-6
                flex flex-col justify-center
                gap-1 sm:gap-2 md:gap-3 lg:gap-4
                select-none z-50
            &quot;
        &gt;
            &lt;SelectToolSection
                selectToolType={selectToolType}
                isSelected={selectedTool === &quot;select&quot; || selectedTool === &quot;hand&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={selectButtonRef}
                onToolSelect={(t) =&gt; setSelectedTool(t)}
                onSelectSubTool={handleSelectSubTool}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
            {hr}

            &lt;PenToolSection
                penToolType={penToolType}
                isSelected={selectedTool === &quot;pen&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={penButtonRef}
                onToolSelect={() =&gt; setSelectedTool(&quot;pen&quot;)}
                onPenSubTool={handlePenSubTool}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
            {hr}

            &lt;EraserToolSection
                eraserToolType={eraserToolType}
                isSelected={selectedTool === &quot;eraser&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={eraserButtonRef}
                onToolSelect={() =&gt; setSelectedTool(&quot;eraser&quot;)}
                onEraserSubTool={handleEraserSubTool}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
            {hr}

            &lt;AddPlayerSection
                isSelected={selectedTool === &quot;addPlayer&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                numberValue={playerNumber}
                nameValue={playerName}
                playerSearch={playerSearch}
                showPlayerDropdown={showPlayerDropdown}
                filteredPlayers={filteredPlayers}
                anchorRef={addPlayerButtonRef}
                dropdownRef={playerDropdownRef}
                onToolSelect={() =&gt; setSelectedTool(&quot;addPlayer&quot;)}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onNumberChange={setPlayerNumber}
                onNameChange={setPlayerName}
                onPlayerSearchChange={setPlayerSearch}
                onPlayerAssign={handlePlayerAssign}
                onShowPlayerDropdownChange={setShowPlayerDropdown}
                onHoverTooltip={setHoveredTooltip}
                onAddPlayer={handleAddPlayer}
                onQuickAdd={handleQuickAddPlayer}
            /&gt;
            {hr}

            &lt;PlayerColorSection
                playerColor={playerColor}
                isSelected={selectedTool === &quot;color&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={playerButtonRef}
                onToolSelect={() =&gt; setSelectedTool(&quot;color&quot;)}
                onPlayerColorChange={handlePlayerColorChange}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onHoverTooltip={setHoveredTooltip}
                onQuickAdd={handleQuickAddPlayer}
            /&gt;
            {hr}

            &lt;PrefabsSection
                prefabs={prefabs}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={prefabsButtonRef}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onPrefabSelect={handlePrefabSelect}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
            {hr}

            &lt;HistoryActionsSection
                onUndo={onUndo}
                onRedo={onRedo}
                onReset={onReset}
                hoveredTooltip={hoveredTooltip}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
        &lt;/aside&gt;
    );
}</file><file path="src/components/subcomponents/controlPill/DropdownMenu.jsx">import React from &apos;react&apos;;
import { FaChevronDown, FaTimes } from &quot;react-icons/fa&quot;;
import { BiUndo } from &quot;react-icons/bi&quot;;
import { BiRedo } from &quot;react-icons/bi&quot;;
import { FaRegTrashCan } from &quot;react-icons/fa6&quot;;

/**
 * DropdownMenu - Settings dropdown with trash, undo, redo, and autoplay controls
 */
export default function DropdownMenu({
  isOpen,
  onToggle,
  onTrash,
  onUndo,
  onRedo,
  autoplayEnabled,
  onAutoplayToggle,
  canUndo,
  canRedo,
}) {
  if (!isOpen) {
    return (
      &lt;div
        onClick={onToggle}
        className=&quot;absolute top-[97.5%] select-none left-1/2 transform -translate-x-1/2 -translate-y-1/2 h-[25px] w-[25px] bg-BrandBlack rounded-full border-[0.625px] border-BrandGray flex items-center justify-center cursor-pointer hover:bg-BrandBlack2 transition-colors&quot;
      &gt;
        &lt;FaChevronDown className=&quot;text-BrandOrange text-[12.5px] sm:text-[12.5px] md:text-[12.5px] font-DmSans&quot; /&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;absolute top-[96.5%] left-1/2 select-none transform -translate-x-1/2 -translate-y-1/2 h-[40px] bg-BrandBlack rounded-full border-[0.625px] border-BrandGray flex items-center gap-[12px] px-[12px]&quot;&gt;
      {/* Trash icon */}
      &lt;FaRegTrashCan
        onClick={onTrash}
        className=&quot;text-BrandOrange text-[12.5px] sm:text-[12.5px] md:text-[18px] font-DmSans cursor-pointer hover:opacity-80 transition-opacity&quot;
      /&gt;

      {/* Undo icon */}
      &lt;BiUndo
        onClick={onUndo}
        className={`text-BrandOrange text-[12.5px] sm:text-[12.5px] md:text-[18px] font-DmSans cursor-pointer hover:opacity-80 transition-opacity ${!canUndo ? &apos;opacity-50 cursor-not-allowed&apos; : &apos;&apos;}`}
      /&gt;

      {/* Redo icon */}
      &lt;BiRedo
        onClick={onRedo}
        className={`text-BrandOrange text-[12.5px] sm:text-[12.5px] md:text-[18px] font-DmSans cursor-pointer hover:opacity-80 transition-opacity ${!canRedo ? &apos;opacity-50 cursor-not-allowed&apos; : &apos;&apos;}`}
      /&gt;

      {/* Autoplay pill switch */}
      &lt;div className=&quot;flex items-center gap-[8px]&quot;&gt;
        &lt;span className=&quot;text-BrandGray text-[10px] sm:text-[12px] md:text-[14px] font-DmSans whitespace-nowrap&quot;&gt;Autoplay&lt;/span&gt;
        &lt;button
          onClick={(e) =&gt; {
            e.stopPropagation();
            onAutoplayToggle();
          }}
          className={`relative w-[40px] h-[20px] rounded-full transition-colors duration-200 cursor-pointer focus:outline-none ${autoplayEnabled ? &apos;bg-BrandOrange&apos; : &apos;bg-BrandGray&apos;
            }`}
          aria-label=&quot;Toggle autoplay&quot;
        &gt;
          &lt;span
            className={`absolute top-1/2 left-0 transform -translate-y-1/2 transition-transform duration-200 w-[16px] h-[16px] bg-BrandBlack rounded-full shadow-sm ${autoplayEnabled ? &apos;translate-x-[22px]&apos; : &apos;translate-x-[4px]&apos;
              }`}
          /&gt;
        &lt;/button&gt;
      &lt;/div&gt;

      {/* Close button (X) */}
      &lt;FaTimes
        onClick={onToggle}
        className=&quot;text-BrandOrange text-[14px] sm:text-[14px] md:text-[18px] font-DmSans cursor-pointer hover:opacity-80 transition-opacity ml-[4px]&quot;
      /&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/subcomponents/controlPill/KeyframeDisplay.jsx">import React from &apos;react&apos;;
import SelectedKeyframeIcon from &quot;../../../assets/keyframes/Selected Key Frame.png&quot;;
import UnselectedKeyframeIcon from &quot;../../../assets/keyframes/Unselected Key Frame.png&quot;;

/**
 * KeyframeDisplay - Displays keyframe icons on the timeline
 */
export default function KeyframeDisplay({
  keyframes = [],
  selectedKeyframe = null,
  onKeyframeClick,
}) {
  // Convert timePercent (0-100) to visual position percentage (3-97%)
  const timePercentToVisualPosition = (timePercent) =&gt; {
    return 3 + (timePercent / 100) * 94;
  };

  return (
    &lt;&gt;
      {keyframes.map((kfTimePercent, idx) =&gt; {
        const visualPos = timePercentToVisualPosition(kfTimePercent);
        const isSelected = selectedKeyframe === kfTimePercent;
        return (
          &lt;img
            key={`kf-${kfTimePercent}-${idx}`}
            src={isSelected ? SelectedKeyframeIcon : UnselectedKeyframeIcon}
            alt=&quot;keyframe&quot;
            draggable={false}
            onClick={(e) =&gt; onKeyframeClick(e, kfTimePercent)}
            className=&quot;absolute z-30 cursor-pointer&quot;
            style={{
              left: `${visualPos}%`,
              top: &quot;50%&quot;,
              transform: &quot;translate(-50%, -50%)&quot;,
              width: &quot;25px&quot;,
              height: &quot;25px&quot;,
              objectFit: &quot;contain&quot;,
              pointerEvents: &quot;auto&quot;,
            }}
          /&gt;
        );
      })}
    &lt;/&gt;
  );
}</file><file path="src/components/subcomponents/controlPill/KeyframeManager.jsx">import React from &apos;react&apos;;

/**
 * KeyframeManager - Button to add or delete keyframes
 */
export default function KeyframeManager({
  selectedKeyframe,
  onAddKeyframe,
  onDeleteKeyframe,
}) {
  return (
    &lt;div
      onClick={selectedKeyframe !== null ? onDeleteKeyframe : onAddKeyframe}
      className=&quot;w-200/641 h-[16px] sm:h-[22px] md:h-[24px] lg:h-[32px] bg-BrandOrange flex flex-row items-center justify-center rounded-xl px-[6.25px] sm:px-[9.375px] cursor-pointer&quot;
    &gt;
      &lt;p className=&quot;text-BrandBlack text-[10px] sm:text-[12px] md:text-[15px] lg:text-[17.5px] font-DmSans&quot;&gt;
        {selectedKeyframe !== null ? &quot;Delete Keyframe&quot; : &quot;Add Keyframe&quot;}
      &lt;/p&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/subcomponents/controlPill/PlaybackControls.jsx">import React from &apos;react&apos;;
import { IoPlayOutline } from &quot;react-icons/io5&quot;;
import { IoPlaySkipForwardOutline, IoPlaySkipBackOutline } from &quot;react-icons/io5&quot;;

/**
 * PlaybackControls - Play/pause and skip buttons
 */
export default function PlaybackControls({
  isPlaying,
  onPlayToggle,
  onSkipBack,
  onSkipForward,
}) {
  return (
    &lt;div className=&quot;flex flex-row items-center gap-[3.125px] sm:gap-[6.25px] justify-between&quot;&gt;
      &lt;div 
        onClick={onSkipBack}
        className=&quot;h-[16px] sm:h-[22px] md:h-[24px] lg:h-[32px] w-[16px] sm:w-[22px] md:w-[24px] lg:w-[32px] bg-BrandBlack2 border-[0.625px] border-BrandGray flex items-center justify-center rounded-sm cursor-pointer&quot;
      &gt;
        &lt;IoPlaySkipBackOutline className=&quot;text-BrandOrange text-[17.5px] sm:text-[20px] md:text-[22.5px] lg:text-[25px]&quot; /&gt;
      &lt;/div&gt;
      &lt;div
        onClick={onPlayToggle}
        className=&quot;h-[37.5px] w-[37.5px] sm:h-[43.75px] sm:w-[43.75px] md:h-[50px] md:w-[50px] bg-BrandOrange flex items-center justify-center rounded-lg cursor-pointer&quot;
      &gt;
        {isPlaying ? (
          &lt;svg
            width=&quot;22.5&quot;
            height=&quot;22.5&quot;
            viewBox=&quot;0 0 24 24&quot;
            fill=&quot;currentColor&quot;
            className=&quot;text-BrandBlack&quot;
          &gt;
            &lt;rect x=&quot;6&quot; y=&quot;4&quot; width=&quot;4&quot; height=&quot;16&quot; /&gt;
            &lt;rect x=&quot;14&quot; y=&quot;4&quot; width=&quot;4&quot; height=&quot;16&quot; /&gt;
          &lt;/svg&gt;
        ) : (
          &lt;IoPlayOutline className=&quot;text-BrandBlack text-[22.5px] sm:text-[22.5px] md:text-[25px] lg:text-[31.25px]&quot; /&gt;
        )}
      &lt;/div&gt;
      &lt;div 
        onClick={onSkipForward}
        className=&quot;h-[16px] sm:h-[22px] md:h-[24px] lg:h-[32px] w-[16px] sm:w-[22px] md:w-[24px] lg:w-[32px] bg-BrandBlack2 border-[0.625px] border-BrandGray flex items-center justify-center rounded-sm cursor-pointer&quot;
      &gt;
        &lt;IoPlaySkipForwardOutline className=&quot;text-BrandOrange text-[17.5px] sm:text-[20px] md:text-[22.5px] lg:text-[25px]&quot; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/subcomponents/controlPill/README.md"># ControlPill Subcomponents

This folder contains the subcomponents that make up the ControlPill timeline control.

## Component Structure

```
controlPill/
├── TimePill.jsx          # Draggable timeline with ticks and thumb
├── KeyframeDisplay.jsx   # Keyframe icons on timeline
├── SpeedSlider.jsx       # Speed control slider with time display
├── PlaybackControls.jsx # Play/pause/skip buttons
├── KeyframeManager.jsx   # Add/delete keyframe button
├── DropdownMenu.jsx      # Settings dropdown (trash, undo, redo, autoplay)
└── README.md            # This file
```

## Main ControlPill Component

The main `ControlPill.jsx` component (in `src/components/`) orchestrates all these subcomponents and exposes state via optional callbacks.

### Usage Example

```jsx
import ControlPill from &apos;./components/ControlPill&apos;;

function App() {
  const [timePercent, setTimePercent] = useState(0);
  const [keyframes, setKeyframes] = useState([]);
  const [speed, setSpeed] = useState(50);
  const [isPlaying, setIsPlaying] = useState(false);

  return (
    &lt;ControlPill
      // Optional: Receive state updates
      onTimePercentChange={(percent) =&gt; {
        setTimePercent(percent);
        console.log(&apos;Time:&apos;, percent);
      }}
      onKeyframesChange={(kfs) =&gt; {
        setKeyframes(kfs);
        console.log(&apos;Keyframes:&apos;, kfs);
      }}
      onSpeedChange={(speed) =&gt; {
        setSpeed(speed);
        console.log(&apos;Speed:&apos;, speed);
      }}
      onPlayStateChange={(playing) =&gt; {
        setIsPlaying(playing);
        console.log(&apos;Playing:&apos;, playing);
      }}
      onSelectedKeyframeChange={(kf) =&gt; {
        console.log(&apos;Selected keyframe:&apos;, kf);
      }}
      onAutoplayChange={(enabled) =&gt; {
        console.log(&apos;Autoplay:&apos;, enabled);
      }}
      
      // Optional: External control (two-way binding)
      externalTimePercent={timePercent}
      externalIsPlaying={isPlaying}
      externalSpeed={speed}
    /&gt;
  );
}
```

### Exposed State

The ControlPill component exposes the following state via callbacks:

1. **timePercent** (0-100) - Current timeline position
2. **keyframes** - Array of keyframe positions (0-100 values)
3. **speedMultiplier** (0-100) - Speed control value
4. **isPlaying** - Playback state
5. **selectedKeyframe** - Currently selected keyframe (number | null)
6. **autoplayEnabled** - Whether animation loops

### Key Functions

- `onTimePercentChange(timePercent)` - Called when timeline position changes
- `onKeyframesChange(keyframes)` - Called when keyframes are added/removed
- `onSpeedChange(speedMultiplier)` - Called when speed slider changes
- `onPlayStateChange(isPlaying)` - Called when play/pause state changes
- `onSelectedKeyframeChange(keyframe)` - Called when keyframe selection changes
- `onAutoplayChange(enabled)` - Called when autoplay toggle changes

## Component Details

### TimePill
- Displays the timeline with tick marks at 0%, 25%, 50%, 75%, 100%
- Shows keyframe icons (via KeyframeDisplay)
- Draggable thumb for scrubbing through timeline
- Clickable to jump to position

### KeyframeDisplay
- Renders keyframe icons on the timeline
- Shows selected vs unselected states
- Handles keyframe click events

### SpeedSlider
- Material-UI slider for speed control (0-100)
- Displays calculated duration in seconds
- Shows time icon

### PlaybackControls
- Play/pause button (toggles playback)
- Skip back button (placeholder for implementation)
- Skip forward button (placeholder for implementation)

### KeyframeManager
- &quot;Add Keyframe&quot; button when no keyframe is selected
- &quot;Delete Keyframe&quot; button when a keyframe is selected
- Limits to 10 keyframes maximum
- Enforces minimum 4% distance between keyframes

### DropdownMenu
- Trash icon - Clear all keyframes
- Undo icon - Undo last action
- Redo icon - Redo last undone action
- Autoplay toggle - Enable/disable looping
- Close button - Collapse dropdown

## Notes

- All callbacks are optional - ControlPill works standalone
- External control props allow two-way binding for controlled component pattern
- Speed calculation: `speed = (0.25 + (speedMultiplier / 100) * 3.75) * 3`
- Base loop duration: 30 seconds
- Visual timeline maps 3%-97% visual range to 0-100% timePercent</file><file path="src/components/subcomponents/controlPill/SpeedSlider.jsx">import React from &apos;react&apos;;
import { IoTimeOutline } from &quot;react-icons/io5&quot;;
import { Slider } from &apos;@mui/material&apos;;

const LOOP_SECONDS = 30; // Duration for one full traversal from 0 -&gt; 100

/**
 * SpeedSlider - Speed control slider with time display
 */
export default function SpeedSlider({
  speedMultiplier,
  onSpeedChange,
}) {
  // Calculate actual duration based on speed multiplier
  const calculateDuration = () =&gt; {
    const speed = (0.25 + (speedMultiplier / 100) * 3.75) * 3;
    const actualDuration = LOOP_SECONDS / speed;
    return `${Math.round(actualDuration)}s`;
  };

  return (
    &lt;div className=&quot;h-[16px] sm:h-[22px] md:h-[24px] lg:h-[32px] w-200/641 bg-BrandBlack2 flex flex-row rounded-xl items-center justify-center px-[6.25px] sm:px-[9.375px] gap-[6.25px] sm:gap-[9.375px]&quot;&gt;
      &lt;IoTimeOutline className=&quot;text-BrandOrange text-[14px] sm:text-[16px] md:text-[18px] lg:text-[20px] flex-shrink-0&quot; /&gt;
      &lt;Slider
        min={0}
        max={100}
        step={1}
        value={speedMultiplier}
        onChange={(e, newValue) =&gt; onSpeedChange(newValue)}
        className=&quot;flex-1&quot;
        sx={{
          color: &apos;#FF7A18&apos;,
          height: &apos;6.25px&apos;,
          &apos;&amp; .MuiSlider-thumb&apos;: {
            width: &apos;12.5px&apos;,
            height: &apos;12.5px&apos;,
            backgroundColor: &apos;#FF7A18&apos;,
            boxShadow: &apos;0 2px 4px rgba(0, 0, 0, 0.2)&apos;,
            &apos;&amp;:hover&apos;: {
              boxShadow: &apos;0 4px 8px rgba(0, 0, 0, 0.3)&apos;,
            },
            &apos;&amp;:focus, &amp;:active, &amp;.Mui-focusVisible&apos;: {
              outline: &apos;none&apos;,
              boxShadow: &apos;0 2px 4px rgba(0, 0, 0, 0.2)&apos;,
            },
          },
          &apos;&amp; .MuiSlider-track&apos;: {
            backgroundColor: &apos;#FF7A18&apos;,
            height: &apos;6.25px&apos;,
            border: &apos;none&apos;,
          },
          &apos;&amp; .MuiSlider-rail&apos;: {
            backgroundColor: &apos;#75492a&apos;,
            height: &apos;6.25px&apos;,
            opacity: 1,
          },
        }}
      /&gt;
      &lt;div className=&quot;sm:py-[6.25px] font-DmSans rounded-md text-[10.9375px] sm:text-[12.5px] md:text-[14.0625px] text-BrandGray flex items-center justify-center&quot;&gt;
        {calculateDuration()}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/subcomponents/controlPill/TimePill.jsx">import React, { useRef, useEffect } from &apos;react&apos;;
import KeyframeDisplay from &apos;./KeyframeDisplay&apos;;

/**
 * TimePill - The draggable timeline component
 * Displays the timeline with tick marks, keyframes, and a draggable thumb
 */
export default function TimePill({
  timePercent,
  onTimeChange,
  keyframes = [],
  selectedKeyframe = null,
  onKeyframeClick,
  onDragStart,
  onDragEnd,
  isDragging,
}) {
  const pillRef = useRef(null);
  const justFinishedDragging = useRef(false);

  // Convert mouse position to timePercent (0-100) considering the 3%-97% visual range
  const getPercentFromMousePosition = (clientX) =&gt; {
    if (!pillRef.current) return 0;
    const rect = pillRef.current.getBoundingClientRect();
    const x = clientX - rect.left;
    const percent = (x / rect.width) * 100;
    // Map from 0-100% clickable range to 3-97% visual range, then back to 0-100 timePercent
    const visualPercent = Math.max(3, Math.min(97, percent));
    const timePercentValue = ((visualPercent - 3) / 94) * 100;
    return Math.max(0, Math.min(100, timePercentValue));
  };

  // Convert timePercent (0-100) to visual position percentage (3-97%)
  const timePercentToVisualPosition = (timePercent) =&gt; {
    return 3 + (timePercent / 100) * 94;
  };

  // Handle click on pill to jump to position
  const handlePillClick = (e) =&gt; {
    // Don&apos;t handle click if we just finished dragging (prevents click on drag end)
    if (isDragging || justFinishedDragging.current) {
      justFinishedDragging.current = false;
      return;
    }
    const newPercent = getPercentFromMousePosition(e.clientX);
    onTimeChange(newPercent);
  };

  // Handle drag start
  const handleDragStart = (e) =&gt; {
    e.preventDefault();
    e.stopPropagation(); // Prevent pill click from firing
    onDragStart();
  };

  // Handle drag move
  useEffect(() =&gt; {
    if (!isDragging) return;

    const handleMouseMove = (e) =&gt; {
      const newPercent = getPercentFromMousePosition(e.clientX);
      onTimeChange(newPercent);
    };

    const handleMouseUp = () =&gt; {
      justFinishedDragging.current = true;
      onDragEnd?.(); // Notify parent that dragging ended
      // Reset after a short delay to allow click event to be checked
      setTimeout(() =&gt; {
        justFinishedDragging.current = false;
      }, 10);
    };

    document.addEventListener(&apos;mousemove&apos;, handleMouseMove);
    document.addEventListener(&apos;mouseup&apos;, handleMouseUp);

    return () =&gt; {
      document.removeEventListener(&apos;mousemove&apos;, handleMouseMove);
      document.removeEventListener(&apos;mouseup&apos;, handleMouseUp);
    };
  }, [isDragging, onTimeChange, onDragEnd]);

  return (
    &lt;div
      ref={pillRef}
      onClick={handlePillClick}
      className=&quot;h-29/124 mt-[3.125px] sm:mt-[6.25px] md:mt-[6.25px] lg:mt-[6.25px] w-full flex items-center px-[6.25px] bg-BrandBlack2 border-[0.3125px] border-BrandGray rounded-full relative cursor-pointer&quot;
    &gt;
      {/* The horizontal rule (line) inside the pill */}
      &lt;hr className=&quot;absolute left-0 top-1/2 w-full text-BrandOrange2 -translate-y-1/2&quot; /&gt;
      
      {/* Vertical tick marks at 0%, 25%, 50%, 75%, 100% */}
      {[0, 25, 50, 75, 100].map((percent) =&gt; {
        const visualPos = timePercentToVisualPosition(percent);
        return (
          &lt;div
            key={`tick-${percent}`}
            className=&quot;absolute z-5 bg-BrandOrange2&quot;
            style={{
              left: `${visualPos}%`,
              top: &quot;50%&quot;,
              transform: &quot;translate(-50%, -50%)&quot;,
              width: &quot;1.25px&quot;,
              height: &quot;10px&quot;,
              pointerEvents: &quot;none&quot;,
            }}
          /&gt;
        );
      })}

      {/* Keyframe icons scattered along the pill */}
      &lt;KeyframeDisplay
        keyframes={keyframes}
        selectedKeyframe={selectedKeyframe}
        onKeyframeClick={onKeyframeClick}
      /&gt;

      {/* The circle (thumb) positioned on top of the line */}
      &lt;div
        onMouseDown={handleDragStart}
        className=&quot;absolute z-10 top-1/2 transform -translate-x-1/2 -translate-y-1/2 h-[3.125px] w-[3.125px] sm:h-[15.625px] sm:w-[15.625px] bg-BrandOrange rounded-full cursor-grab active:cursor-grabbing&quot;
        style={{ 
          left: `${timePercentToVisualPosition(timePercent)}%`, 
          pointerEvents: &apos;auto&apos; 
        }}
      /&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/subcomponents/Buttons.jsx">import React, { forwardRef } from &quot;react&quot;;
import { IoChevronDownOutline } from &quot;react-icons/io5&quot;;
import { FiEdit } from &quot;react-icons/fi&quot;;
import { MdDeleteOutline } from &quot;react-icons/md&quot;;
// Sidebar chevron button component
export const SidebarChevronButton = forwardRef(({
    Icon,
    label,
    onHover,
    onClick,
    onRowClick,
    onChevronClick,
    isSelected,
    chevronActive = false,
}, ref) =&gt; {
    const handleChevronClick = (e) =&gt; {
        e.stopPropagation();
        onChevronClick?.();
    };

    const buttonContent = (
        &lt;div className=&quot;w-full flex items-center gap-1&quot;&gt;
            &lt;button
                className={`
                    w-full aspect-square
                    rounded-md border-[0.5px] border-BrandGray
                    transition-all duration-100
                    flex items-center justify-center
                    ${isSelected ? &quot;bg-BrandOrange&quot; : &quot;bg-BrandBlack2&quot;}
                `}
                onMouseEnter={onHover}
                onClick={(e) =&gt; {
                    e.stopPropagation();
                    onClick?.();
                }}
            &gt;
                {Icon}
            &lt;/button&gt;
            &lt;button
                onClick={handleChevronClick}
                className={`
                    shrink-0 transition-colors duration-100
                    ${chevronActive ? &quot;text-BrandOrange&quot; : &quot;text-BrandOrange/60&quot;}
                    hover:text-BrandOrange
                `}
            &gt;
                &lt;IoChevronDownOutline className=&quot;text-[10px] sm:text-xs md:text-sm&quot; /&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    );

    if (label) {
        return (
            &lt;div
                ref={ref}
                className=&quot;w-full flex flex-col items-center gap-1 relative&quot;
                onClick={() =&gt; onRowClick?.()}
            &gt;
                {buttonContent}
                &lt;span className=&quot;text-[10px] sm:text-xs text-BrandGray text-center mt-1 leading-none font-DmSans&quot;&gt;
                    {label}
                &lt;/span&gt;
            &lt;/div&gt;
        );
    }

    return (
        &lt;div ref={ref} className=&quot;w-full relative&quot; onClick={() =&gt; onRowClick?.()}&gt;
            {buttonContent}
        &lt;/div&gt;
    );
});

SidebarChevronButton.displayName = &quot;SidebarChevronButton&quot;;

// Wide sidebar row: icon + label in a row (same width as RightPanel)
export const WideSidebarRowButton = forwardRef(({
    Icon,
    label,
    onHover,
    onClick,
    onRowClick,
    onChevronClick,
    isSelected,
    chevronActive = false,
}, ref) =&gt; {
    const handleChevronClick = (e) =&gt; {
        e.stopPropagation();
        onChevronClick?.();
    };

    return (
        &lt;div
            ref={ref}
            className={`
                w-full flex items-center gap-2.5 py-2 px-2 rounded-lg
                transition-colors duration-200
                ${isSelected ? &quot;bg-BrandBlack2&quot; : &quot;hover:bg-BrandBlack2/70&quot;}
            `}
            onClick={() =&gt; onRowClick?.()}
        &gt;
            &lt;button
                className={`
                    shrink-0 w-9 h-9 rounded-lg border flex items-center justify-center
                    transition-all duration-200
                    ${isSelected
                        ? &quot;bg-BrandOrange border-BrandOrange text-BrandBlack&quot;
                        : &quot;border-BrandGray2 bg-BrandBlack2 hover:border-BrandGray hover:bg-BrandBlack2/90 text-BrandOrange&quot;
                    }
                `}
                onMouseEnter={onHover}
                onClick={(e) =&gt; {
                    e.stopPropagation();
                    onClick?.();
                }}
            &gt;
                {Icon}
            &lt;/button&gt;
            &lt;span
                className={`
                    flex-1 min-w-0 text-xs sm:text-sm font-DmSans truncate transition-colors duration-200
                    ${isSelected ? &quot;text-BrandWhite font-medium&quot; : &quot;text-BrandGray hover:text-BrandWhite&quot;}
                `}
            &gt;
                {label}
            &lt;/span&gt;
            {onChevronClick != null &amp;&amp; (
                &lt;button
                    onClick={handleChevronClick}
                    className={`
                        shrink-0 p-0.5 rounded transition-colors duration-200
                        ${chevronActive ? &quot;text-BrandOrange&quot; : &quot;text-BrandGray2 hover:text-BrandOrange&quot;}
                    `}
                &gt;
                    &lt;IoChevronDownOutline className=&quot;text-sm&quot; /&gt;
                &lt;/button&gt;
            )}
        &lt;/div&gt;
    );
});

WideSidebarRowButton.displayName = &quot;WideSidebarRowButton&quot;;

// Original Button component (kept for backward compatibility)
export const Button = ({ Icon, onHover, onClick, isSelected }) =&gt; {
    return (
        &lt;div className=&quot;w-full&quot;&gt;
            &lt;button
                className={`
             w-full aspect-square
             rounded-md border-[0.5px] border-BrandGray
             transition-all duration-300
             flex items-center justify-center
             ${isSelected ? &quot;bg-BrandOrange &quot; : &quot;bg-BrandBlack2 &quot;}
           `}
                onMouseEnter={onHover}
                onClick={onClick}
            &gt;
                {Icon}
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

// Original ButtonWithLabel component (kept for backward compatibility)
export const ButtonWithLabel = ({ Icon, label, onHover, onClick, isSelected }) =&gt; {
    return (
        &lt;div className=&quot;w-full flex flex-col items-center gap-1&quot;&gt;
            &lt;button
                className={`
                    w-full aspect-square rounded-md border-[0.5px] border-BrandGray 
                    transition-all duration-300 flex items-center justify-center 
                    ${isSelected ? &quot;bg-BrandOrange &quot; : &quot;bg-BrandBlack2 &quot;}
                `}
                onMouseEnter={onHover}
                onClick={onClick}
            &gt;
                {Icon}
            &lt;/button&gt;
            &lt;span className=&quot;text-[10px] sm:text-xs text-BrandGray text-center leading-none font-DmSans&quot;&gt;
                {label}
            &lt;/span&gt;
        &lt;/div&gt;
    );
};

// Legacy components (deprecated, kept for compatibility)
export const ButtonWithChevron = ({ Icon, onHover, onClick, isSelected }) =&gt; {
    return (
        &lt;div className=&quot;w-full flex items-center gap-1&quot;&gt;
            &lt;button
                className={`
             w-full aspect-square
             rounded-md border-[0.5px] border-BrandGray
             transition-all duration-100
             flex items-center justify-center
           ${isSelected ? &quot;bg-BrandOrange &quot; : &quot;bg-BrandBlack2 &quot;}
           `}
                onMouseEnter={onHover}
                onClick={onClick}
            &gt;
                {Icon}
            &lt;/button&gt;
            &lt;IoChevronDownOutline className=&quot;shrink-0 text-BrandOrange text-[10px] sm:text-xs md:text-sm&quot; /&gt;
        &lt;/div&gt;
    );
};

export const ButtonWithChevronAndLabel = ({ Icon, label, onHover, onClick, isSelected }) =&gt; {
    return (
        &lt;div className=&quot;w-full flex flex-col items-center gap-1&quot;&gt;
            &lt;div className=&quot;w-full flex items-center gap-1&quot;&gt;
                &lt;button
                    className={`
              w-full aspect-square
              rounded-md border-[0.5px] border-BrandGray
              transition-all duration-300
              flex items-center justify-center
            ${isSelected ? &quot;bg-BrandOrange &quot; : &quot;bg-BrandBlack2 &quot;}
            `}
                    onMouseEnter={onHover}
                    onClick={onClick}
                &gt;
                    {Icon}
                &lt;/button&gt;

                &lt;IoChevronDownOutline className=&quot;shrink-0 text-BrandOrange text-[10px] sm:text-xs md:text-sm&quot; /&gt;
            &lt;/div&gt;

            &lt;span className=&quot;text-[10px] sm:text-xs text-BrandGray text-center leading-none font-DmSans&quot;&gt;
                {label}
            &lt;/span&gt;
        &lt;/div&gt;
    );
};

//panel button component
export const PanelButton = ({ Icon, onHover, onClick, isSelected = false }) =&gt; {
    return (

        &lt;button
            className={`
             w-full aspect-[5/3]
             rounded-lg border border-BrandGray2
             transition-all duration-200
             flex items-center justify-center p-1
             ${isSelected
                    ? &quot;bg-BrandOrange border-BrandOrange text-BrandBlack&quot;
                    : &quot;bg-BrandBlack2 hover:bg-BrandBlack2/90 hover:border-BrandGray text-BrandOrange&quot;}
           `}
            onMouseEnter={onHover}
            onClick={onClick}
        &gt;
            {Icon}
        &lt;/button&gt;

    );
};

export const PlayerButton = ({
    id,
    color = &quot;#ef4444&quot;,
    number,
    name,
    assignment,
    onClick,
    onEdit,
    onDelete,
    isSelected = false,
}) =&gt; {
    const hasMeta = Boolean(name) || Boolean(assignment);
    return (
        &lt;button
            type=&quot;button&quot;
            onClick={() =&gt; onClick?.(id)}
            className={`w-full flex flex-row rounded sm items-center justify-between px-1 py-0.5 sm:py-1 transition-colors
                ${isSelected ? &quot;bg-BrandBlack border border-BrandOrange&quot; : &quot;bg-BrandBlack2 border border-transparent&quot;}
                hover:bg-BrandBlack`}
        &gt;
            {/* Color indicator */}
            &lt;div
                className=&quot;w-3 h-3 sm:w-[14px] sm:h-[14px] md:w-4 md:h-4 rounded-full border-[0.25px] border-BrandBlack shrink-0&quot;
                style={{ backgroundColor: color }}
            /&gt;

            {/* Number + optional label/assignment */}
            &lt;div className=&quot;flex-1 min-w-0 flex flex-col items-center justify-center px-1&quot;&gt;
                &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm md:text-base font-DmSans leading-none&quot;&gt;
                    {number ?? &quot;&quot;}
                &lt;/p&gt;
                {hasMeta &amp;&amp; (
                    &lt;p className=&quot;text-BrandGray text-[9px] sm:text-[10px] md:text-xs font-DmSans leading-none truncate w-full text-center&quot;&gt;
                        {[name, assignment].filter(Boolean).join(&quot; • &quot;)}
                    &lt;/p&gt;
                )}
            &lt;/div&gt;

            {/* Actions */}
            &lt;div className=&quot;flex flex-row justify-center items-center gap-0.5 sm:gap-1 shrink-0&quot;&gt;
                &lt;button
                    type=&quot;button&quot;
                    onClick={(e) =&gt; {
                        e.stopPropagation();
                        onEdit?.(id);
                    }}
                    className=&quot;text-BrandOrange text-xs sm:text-sm md:text-base&quot;
                    aria-label=&quot;Edit player&quot;
                &gt;
                    &lt;FiEdit /&gt;
                &lt;/button&gt;
                &lt;button
                    type=&quot;button&quot;
                    onClick={(e) =&gt; {
                        e.stopPropagation();
                        onDelete?.(id);
                    }}
                    className=&quot;text-BrandOrange text-xs sm:text-sm md:text-base&quot;
                    aria-label=&quot;Delete player&quot;
                &gt;
                    &lt;MdDeleteOutline /&gt;
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/button&gt;
    );
};</file><file path="src/components/subcomponents/ColorPickerPopover.jsx">import React from &quot;react&quot;;
import { SketchPicker } from &quot;react-color&quot;;

export const ColorPickerPopover = ({ color, onChange }) =&gt; {
  const presetColors = [&quot;#0033FF&quot;, &quot;#FF0000&quot;];

  return (
    &lt;div
      className=&quot;
        ml-2 rounded-md
        bg-BrandBlack
        p-3 sm:p-4
        w-[160px] sm:w-[180px] md:w-[200px] lg:w-[220px] xl:w-[240px]
        shadow-lg
      &quot;
    &gt;
      &lt;style&gt;{`
        /* ===== Root picker panel ===== */
        .sketch-picker {
          background: transparent !important;
          border: none !important;
          box-shadow: none !important;
          padding: 0 !important;
          width: 100% !important;
        }

        /* The &quot;card&quot; around the picker in SketchPicker */
        .sketch-picker &gt; div {
          background: transparent !important;
        }

        /* Saturation area rounding */
        .sketch-picker .saturation-white,
        .sketch-picker .saturation-black {
          
        }

        /* Hue / Alpha bars */
        .sketch-picker .hue-horizontal,
        .sketch-picker .alpha-horizontal {
          border-radius: 9999px !important;
          height: 10px !important;
        }

        /* Labels (hex / r g b a) */
        .sketch-picker label {
          color: #FF7A18 !important; /* BrandOrange */
          font-size: 0.75rem !important;
        }

        /* ===== The input WRAPPERS are often where the border is ===== */
        .sketch-picker .flexbox-fix {
          border-top: 1px solid rgba(154,160,166,0.25) !important; /* subtle divider */
          margin-top: 10px !important;
          padding-top: 10px !important;
        }

        /* Each input block wrapper */
        .sketch-picker .flexbox-fix &gt; div {
          background: transparent !important;
        }

        /* Wrapper around the actual input */
        .sketch-picker input {
          background: #121212 !important; /* BrandBlack */
          border: none !important;        /* kill borders */
          outline: none !important;
          box-shadow: none !important;
          color: #F5F7FA !important;      /* BrandWhite */
          border-radius: 0.375rem !important;
          font-size: 0.75rem !important;
          padding: 0.35rem 0.5rem !important;
          width: 100% !important;
        }

        /* Some versions put a border on the div around the input */
        .sketch-picker input + span,
        .sketch-picker input:focus,
        .sketch-picker input:active {
          border: none !important;
          outline: none !important;
          box-shadow: 0 0 0 1px rgba(255,122,24,0.55) !important; /* orange focus ring */
        }

        /* The HEX box container sometimes has inline border */
        .sketch-picker .flexbox-fix div[style*=&quot;border&quot;] {
          border: none !important;
        }

        /* Preset color swatches section divider */
        .sketch-picker &gt; div:last-child {
          border-top: 1px solid rgba(154,160,166,0.25) !important;
          margin-top: 10px !important;
          padding-top: 10px !important;
        }
      `}&lt;/style&gt;

      &lt;SketchPicker
        color={color}
        onChange={onChange}
        onChangeComplete={onChange}
        disableAlpha={true}
        presetColors={presetColors}
        width={220}
        className=&quot;font-DmSans&quot;
      /&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/subcomponents/Popovers.jsx">import React, { useEffect, useLayoutEffect, useRef, useState } from &quot;react&quot;;
import { createPortal } from &quot;react-dom&quot;;

const GAP_PX = 8;

// Parse topOffset string like &quot;top-0&quot; or &quot;top-[-150px]&quot; to pixels
function parseTopOffset(topOffset) {
    if (typeof topOffset === &quot;number&quot;) return topOffset;
    if (typeof topOffset !== &quot;string&quot;) return 0;
    const match = topOffset.match(/-?\d+/);
    return match ? parseInt(match[0], 10) : 0;
}

// Generic Popover component – renders in a portal so it&apos;s never clipped by overflow-hidden
export const Popover = ({ isOpen, onClose, children, anchorRef, topOffset = &quot;top-0&quot;, position = &quot;right&quot;, marginRight }) =&gt; {
    const popoverRef = useRef(null);
    const [style, setStyle] = useState({ left: 0, top: 0, opacity: 0 });

    useEffect(() =&gt; {
        if (!isOpen) return;

        const handleEscape = (e) =&gt; {
            if (e.key === &quot;Escape&quot;) {
                onClose();
            }
        };

        const handleClickOutside = (e) =&gt; {
            if (
                popoverRef.current &amp;&amp;
                !popoverRef.current.contains(e.target) &amp;&amp;
                anchorRef &amp;&amp;
                !anchorRef.current?.contains(e.target)
            ) {
                onClose();
            }
        };

        document.addEventListener(&quot;keydown&quot;, handleEscape);
        document.addEventListener(&quot;mousedown&quot;, handleClickOutside);

        return () =&gt; {
            document.removeEventListener(&quot;keydown&quot;, handleEscape);
            document.removeEventListener(&quot;mousedown&quot;, handleClickOutside);
        };
    }, [isOpen, onClose, anchorRef]);

    const updatePosition = () =&gt; {
        if (!anchorRef?.current || !popoverRef.current) return;
        const anchorRect = anchorRef.current.getBoundingClientRect();
        const popoverRect = popoverRef.current.getBoundingClientRect();
        const topOffsetPx = parseTopOffset(topOffset);
        const margin = marginRight !== undefined ? marginRight * 4 : GAP_PX;

        let left;
        let top = anchorRect.top + topOffsetPx;

        if (position === &quot;left&quot;) {
            left = anchorRect.left - popoverRect.width - margin;
        } else {
            left = anchorRect.right + margin;
        }

        // Keep on screen
        const padding = 8;
        if (left + popoverRect.width &gt; window.innerWidth - padding) {
            left = window.innerWidth - popoverRect.width - padding;
        }
        if (left &lt; padding) {
            left = padding;
        }
        if (top + popoverRect.height &gt; window.innerHeight - padding) {
            top = window.innerHeight - popoverRect.height - padding;
        }
        if (top &lt; padding) {
            top = padding;
        }

        setStyle({ left, top, opacity: 1 });
    };

    useLayoutEffect(() =&gt; {
        if (!isOpen) return;
        updatePosition();
    }, [isOpen, anchorRef, topOffset, position, marginRight]);

    // Re-measure when window resizes or anchor moves
    useEffect(() =&gt; {
        if (!isOpen) return;
        const raf = requestAnimationFrame(updatePosition);
        window.addEventListener(&quot;resize&quot;, updatePosition);
        return () =&gt; {
            cancelAnimationFrame(raf);
            window.removeEventListener(&quot;resize&quot;, updatePosition);
        };
    }, [isOpen]);

    if (!isOpen) return null;

    const popoverContent = (
        &lt;div
            ref={popoverRef}
            className=&quot;fixed z-[100] shadow-lg&quot;
            style={style}
            onClick={(e) =&gt; e.stopPropagation()}
        &gt;
            {children}
        &lt;/div&gt;
    );

    return createPortal(popoverContent, document.body);
};

// Popover layout: Grid for option tiles
export const PopoverGrid = ({ cols = 2, children }) =&gt; {
    const gridCols = {
        2: &quot;grid-cols-2&quot;,
        3: &quot;grid-cols-3&quot;,
        4: &quot;grid-cols-4&quot;,
    };

    return (
        &lt;div
            className={`
                bg-BrandBlack  ml-2 rounded-md p-2
                grid ${gridCols[cols] || gridCols[2]} gap-2
                min-w-[120px] shadow-lg 
                font-DmSans
            `}
        &gt;
            {children}
        &lt;/div&gt;
    );
};

// Popover layout: List for future lists
export const PopoverList = ({ children }) =&gt; {
    return (
        &lt;div
            className=&quot;
                bg-BrandBlack2 z-50 ml-2 rounded-md p-2
                flex flex-col gap-1 min-w-[150px] shadow-lg
                font-DmSans
            &quot;
        &gt;
            {children}
        &lt;/div&gt;
    );
};

// Popover layout: Form for forms like Add Player
export const PopoverForm = ({ children }) =&gt; {
    return (
        &lt;div
            className=&quot;
                bg-BrandBlack2 z-50 ml-2 rounded-md p-3 sm:p-4
                flex flex-col gap-1.5 sm:gap-2
                w-[150px] sm:w-[150px] md:w-[150px] lg:w-[175px] xl:w-[200px]
                shadow-lg
                font-DmSans
            &quot;
        &gt;
            {children}
        &lt;/div&gt;
    );
};

// Tooltip component for hover tooltips
export const Tooltip = ({ children, text, isOpen }) =&gt; {
    if (!isOpen) return null;

    return (
        &lt;div
            className=&quot;
                absolute left-full ml-2 top-1/2 -translate-y-1/2 z-50
                bg-BrandBlack2 z-50 rounded-md px-2 py-1.5
                text-BrandWhite text-xs font-DmSans
                whitespace-nowrap shadow-lg
                border border-BrandGray/30
                pointer-events-none
            &quot;
        &gt;
            {text}
            {children}
        &lt;/div&gt;
    );
};</file><file path="src/components/subcomponents/PrefabsPopover.jsx">import React, { useState, useRef, useEffect } from &quot;react&quot;;
import { IoChevronDownOutline } from &quot;react-icons/io5&quot;;

// Dropdown Item Component (matches Add Player dropdown styling)
const DropdownItem = ({ dropdown }) =&gt; {
    const [isOpen, setIsOpen] = useState(false);
    const [selectedValue, setSelectedValue] = useState(dropdown.value ?? dropdown.options[0]);
    const dropdownItemRef = useRef(null);

    useEffect(() =&gt; {
        if (!isOpen) return;
        const handleClickOutside = (e) =&gt; {
            if (dropdownItemRef.current &amp;&amp; !dropdownItemRef.current.contains(e.target)) {
                setIsOpen(false);
            }
        };
        document.addEventListener(&quot;mousedown&quot;, handleClickOutside);
        return () =&gt; document.removeEventListener(&quot;mousedown&quot;, handleClickOutside);
    }, [isOpen]);

    return (
        &lt;div className=&quot;flex flex-col gap-0.5 sm:gap-1 relative&quot; ref={dropdownItemRef}&gt;
            &lt;p className=&quot;text-BrandOrange text-xs sm:text-sm&quot;&gt;{dropdown.label}:&lt;/p&gt;
            &lt;div className=&quot;relative&quot;&gt;
                &lt;div className=&quot;w-full h-8 sm:h-9 bg-BrandBlack2 border-[0.5px] border-BrandGray rounded-md flex items-center overflow-hidden&quot;&gt;
                    &lt;div className=&quot;flex-1 min-w-0 h-8 sm:h-9 bg-transparent border-r-[0.5px] border-BrandGray text-BrandWhite px-2 text-xs sm:text-sm flex items-center rounded-l-md&quot;&gt;
                        {selectedValue}
                    &lt;/div&gt;
                    &lt;button
                        onClick={() =&gt; setIsOpen(!isOpen)}
                        className=&quot;h-8 sm:h-9 w-8 sm:w-9 flex items-center justify-center border-l-[0.5px] border-BrandGray transition-colors rounded-r-md shrink-0 hover:bg-BrandBlack2&quot;
                    &gt;
                        &lt;IoChevronDownOutline
                            className={`text-BrandOrange text-base sm:text-lg transition-transform ${isOpen ? &quot;rotate-180&quot; : &quot;&quot;}`}
                        /&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
                {isOpen &amp;&amp; (
                    &lt;div className=&quot;absolute left-0 top-full w-full bg-BrandBlack border border-BrandGray rounded-md mt-1 max-h-40 overflow-y-auto z-10 shadow-lg&quot;&gt;
                        {dropdown.options.length &gt; 0 ? (
                            dropdown.options.map((option, optIdx) =&gt; (
                                &lt;div
                                    key={optIdx}
                                    onClick={() =&gt; {
                                        setSelectedValue(option);
                                        setIsOpen(false);
                                        if (dropdown.onChange) {
                                            dropdown.onChange(option);
                                        }
                                    }}
                                    className=&quot;px-2 py-1 text-BrandWhite hover:bg-BrandOrange hover:text-BrandBlack cursor-pointer transition-colors text-xs sm:text-sm truncate&quot;
                                &gt;
                                    {option}
                                &lt;/div&gt;
                            ))
                        ) : (
                            &lt;div className=&quot;px-2 py-1 text-BrandGray text-xs&quot;&gt;
                                No options available
                            &lt;/div&gt;
                        )}
                    &lt;/div&gt;
                )}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

// Individual Prefab Item Component
const PrefabItem = ({ prefab, onSelect, isOpen, onToggle, onClose }) =&gt; {
    const prefabRef = useRef(null);
    const dropdownRef = useRef(null);

    const hasDropdowns = prefab.dropdowns &amp;&amp; prefab.dropdowns.length &gt; 0;

    useEffect(() =&gt; {
        if (!isOpen) return;

        const handleClickOutside = (e) =&gt; {
            if (
                dropdownRef.current &amp;&amp;
                !dropdownRef.current.contains(e.target) &amp;&amp;
                prefabRef.current &amp;&amp;
                !prefabRef.current.contains(e.target)
            ) {
                onClose();
            }
        };

        document.addEventListener(&quot;mousedown&quot;, handleClickOutside);
        return () =&gt; document.removeEventListener(&quot;mousedown&quot;, handleClickOutside);
    }, [isOpen, onClose]);

    const handleChevronClick = (e) =&gt; {
        e.stopPropagation();
        if (!hasDropdowns) return;
        onToggle();
    };

    return (
        &lt;div className=&quot;relative&quot; ref={prefabRef}&gt;
            {/* Row */}
            &lt;div
                className=&quot;
          w-full flex items-center gap-2
          rounded-md border-[0.5px] border-BrandGray
          bg-BrandBlack2 hover:bg-BrandBlack2/80
          transition-all duration-100
          px-2 py-2
        &quot;
            &gt;
                {/* Icon Button (standard size) */}
                &lt;button
                    onClick={onSelect}
                    className=&quot;
            w-10 h-10 shrink-0
            rounded-md border-[0.5px] border-BrandGray
            bg-BrandOrange
            flex items-center justify-center
            hover:bg-BrandOrange/80
            transition-colors
          &quot;
                    title={prefab.label}
                &gt;
                    {/* Force icon size smaller no matter what prefab.icon is */}
                    &lt;span className=&quot;text-BrandOrange text-xl leading-none flex items-center justify-center&quot;&gt;
                        {prefab.icon}
                    &lt;/span&gt;
                &lt;/button&gt;

                {/* Label */}
                &lt;div className=&quot;flex-1 min-w-0&quot;&gt;
                    &lt;p className=&quot;text-BrandWhite text-xs sm:text-sm font-medium truncate font-DmSans&quot;&gt;
                        {prefab.label}
                    &lt;/p&gt;
                    {prefab.subLabel &amp;&amp; (
                        &lt;p className=&quot;text-BrandGray text-[10px] sm:text-xs truncate font-DmSans&quot;&gt;
                            {prefab.subLabel}
                        &lt;/p&gt;
                    )}
                &lt;/div&gt;

                {/* Chevron (always shown) */}
                &lt;button
                    onClick={handleChevronClick}
                    className={`
                                  w-8 h-8 shrink-0
                                  flex items-center justify-center rounded-md
                                  border-[0.5px] border-BrandGray
                                  bg-BrandBlack
                                  transition-colors
                                  ${hasDropdowns ? &quot;hover:bg-BrandBlack/80&quot; : &quot;opacity-40 cursor-not-allowed&quot;}
                                `}
                    aria-label=&quot;Prefab options&quot;
                &gt;
                    &lt;IoChevronDownOutline
                        className={`
              text-base transition-transform
              ${isOpen ? &quot;rotate-180 text-BrandOrange&quot; : &quot;text-BrandOrange/80&quot;}
            `}
                    /&gt;
                &lt;/button&gt;
            &lt;/div&gt;

            {/* Dropdown popover */}
            {isOpen &amp;&amp; hasDropdowns &amp;&amp; (
                &lt;div
                    ref={dropdownRef}
                    className=&quot;
            absolute left-full ml-5 top-0 z-50
            bg-BrandBlack 
            rounded-md p-3 shadow-lg
            min-w-[200px]
          &quot;
                    onClick={(e) =&gt; e.stopPropagation()}
                &gt;
                    &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
                        {prefab.dropdowns.map((dropdown, idx) =&gt; (
                            &lt;DropdownItem key={idx} dropdown={dropdown} /&gt;
                        ))}
                    &lt;/div&gt;
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
};

// Main Prefabs Popover Component
export const PrefabsPopover = ({ prefabs = [], onPrefabSelect }) =&gt; {
    const [mode, setMode] = useState(&quot;offense&quot;);
    const [openPrefabId, setOpenPrefabId] = useState(null);
    const [searchQuery, setSearchQuery] = useState(&quot;&quot;);

    const filteredPrefabs = prefabs.filter((p) =&gt; {
        const matchesMode = p.mode === mode || !p.mode;
        const matchesSearch = searchQuery === &quot;&quot; ||
            p.label.toLowerCase().includes(searchQuery.toLowerCase()) ||
            (p.subLabel &amp;&amp; p.subLabel.toLowerCase().includes(searchQuery.toLowerCase()));
        return matchesMode &amp;&amp; matchesSearch;
    });

    const handlePrefabToggle = (id) =&gt; setOpenPrefabId(openPrefabId === id ? null : id);
    const handlePrefabClose = () =&gt; setOpenPrefabId(null);

    return (
        &lt;div
            className=&quot;
        ml-2 rounded-md
        bg-BrandBlack 
        p-3 sm:p-4
        w-[260px]
        shadow-lg
        flex flex-col gap-3
      &quot;
        &gt;
            {/* Toggle pill */}
            &lt;div className=&quot;flex items-center justify-center&quot;&gt;
                &lt;div className=&quot;flex bg-BrandBlack2 rounded-full p-1 border-[0.5px] border-BrandGray font-DmSans&quot;&gt;
                    &lt;button
                        onClick={() =&gt; { setMode(&quot;offense&quot;); setOpenPrefabId(null); }}
                        className={`
              px-3 py-1 rounded-full text-xs sm:text-sm font-medium transition-all font-DmSans
              ${mode === &quot;offense&quot; ? &quot;bg-BrandOrange text-BrandBlack&quot; : &quot;text-BrandGray hover:text-BrandWhite&quot;}
            `}
                    &gt;
                        Offense
                    &lt;/button&gt;
                    &lt;button
                        onClick={() =&gt; { setMode(&quot;defense&quot;); setOpenPrefabId(null); }}
                        className={`
              px-3 py-1 rounded-full text-xs sm:text-sm font-medium transition-all font-DmSans
              ${mode === &quot;defense&quot; ? &quot;bg-BrandOrange text-BrandBlack&quot; : &quot;text-BrandGray hover:text-BrandWhite&quot;}
            `}
                    &gt;
                        Defense
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            {/* Search Bar */}
            &lt;div className=&quot;flex flex-col gap-0.5 sm:gap-1&quot;&gt;
                &lt;input
                    type=&quot;text&quot;
                    placeholder=&quot;Search prefabs...&quot;
                    value={searchQuery}
                    onChange={(e) =&gt; setSearchQuery(e.target.value)}
                    className=&quot;w-full h-8 sm:h-9 bg-BrandBlack border-[0.5px] border-BrandGray text-BrandWhite rounded-md px-2 text-xs sm:text-sm focus:outline-none focus:border-BrandOrange transition-colors font-DmSans&quot;
                /&gt;
            &lt;/div&gt;

            {/* List */}
            &lt;div className={`flex flex-col gap-2 ${filteredPrefabs.length &gt; 4 ? &quot;max-h-[320px] overflow-y-auto pr-1&quot; : &quot;&quot;}`}&gt;
                {filteredPrefabs.length ? (
                    filteredPrefabs.map((prefab, idx) =&gt; {
                        const id = prefab.id ?? idx;
                        return (
                            &lt;PrefabItem
                                key={id}
                                prefab={prefab}
                                onSelect={() =&gt; onPrefabSelect?.(prefab)}
                                isOpen={openPrefabId === id}
                                onToggle={() =&gt; handlePrefabToggle(id)}
                                onClose={handlePrefabClose}
                            /&gt;
                        );
                    })
                ) : (
                    &lt;div className=&quot;text-BrandGray text-xs text-center py-4&quot;&gt;
                        {searchQuery ? &quot;No prefabs found&quot; : &quot;No prefabs available&quot;}
                    &lt;/div&gt;
                )}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};</file><file path="src/components/wideSidebar/README.md"># Wide Sidebar (`src/components/wideSidebar/`)

The **Wide Sidebar** is the left tools panel used in the app. It has the **same width as the Right Panel** (`w-32 sm:w-36 md:w-40 lg:w-44 xl:w-48`) and shows **icon + tool name** in a row for each tool (Select, Hand, Pen, Eraser, Add Player, Player Color, Prefabs, Undo/Redo/Reset).

## Structure

```
wideSidebar/
├── README.md           # This file
└── WideSidebarRoot.jsx # Layout, state, callbacks; reuses sidebar sections with wide={true}
```

The public entry is `src/components/WideSidebar.jsx`, which renders `WideSidebarRoot`. The wide sidebar reuses the same section components as the narrow Sidebar (`src/components/sidebar/`) by passing `wide={true}` so each section renders icon + label in a row via `WideSidebarRowButton`.

## Relation to Sidebar

- **Sidebar** (narrow, icon-only) remains in the codebase at `src/components/Sidebar.jsx` and `src/components/sidebar/SidebarRoot.jsx` but is **not mounted** in the app.
- **WideSidebar** is what App mounts in place of Sidebar. It uses the same callbacks and optional props (`players`, `prefabs`).

## Callbacks (same as Sidebar)

| Callback | When called |
|----------|-------------|
| `onToolChange(tool)` | Current tool: `&quot;select&quot;` \| `&quot;hand&quot;` \| `&quot;pen&quot;` \| `&quot;eraser&quot;` \| `&quot;addPlayer&quot;` \| `&quot;player&quot;` \| `&quot;prefab&quot;` |
| `onSelectSubTool?(subTool)` | User picks Select or Hand |
| `onPenSubTool?(subTool)` | User picks Pen or Arrow |
| `onEraserSubTool?(subTool)` | User picks Full or Partial |
| `onPlayerColorChange?(hex)` | User picks a color |
| `onUndo?()`, `onRedo?()`, `onReset?()` | History actions |
| `onPrefabSelect?(prefab)` | User selects a prefab |
| `onAddPlayer?(data)` | Reserved for add-player form submit |

## Usage (from App)

```jsx
import WideSidebar from &apos;./components/WideSidebar&apos;;

&lt;WideSidebar
  onToolChange={(tool) =&gt; { if (tool === &quot;hand&quot; || tool === &quot;select&quot;) setCanvasTool(tool); }}
  onUndo={onUndo}
  onRedo={onRedo}
  onReset={onReset}
/&gt;
```

Optional props: `players`, `prefabs` (same as Sidebar).</file><file path="src/components/wideSidebar/WideSidebarRoot.jsx">import { useState, useEffect, useRef } from &quot;react&quot;;
import rugbyScrum from &quot;../../assets/prefabIcons/Rugby Scrum.png&quot;;
import rugbyLineout from &quot;../../assets/prefabIcons/Rugby Lineout.png&quot;;
import rugbyKickoff from &quot;../../assets/prefabIcons/Rugby KickOff.png&quot;;

import SelectToolSection from &quot;../sidebar/SelectToolSection&quot;;
import PenToolSection from &quot;../sidebar/PenToolSection&quot;;
import EraserToolSection from &quot;../sidebar/EraserToolSection&quot;;
import AddPlayerSection from &quot;../sidebar/AddPlayerSection&quot;;
import PlayerColorSection, { PLAYER_COLORS } from &quot;../sidebar/PlayerColorSection&quot;;
import PrefabsSection from &quot;../sidebar/PrefabsSection&quot;;
import HistoryActionsSection from &quot;../sidebar/HistoryActionsSection&quot;;

const iconClass = &quot;text-BrandOrange text-xl sm:text-2xl md:text-3xl&quot;;

const DEFAULT_PLAYERS = [
    &quot;Tommy Kilbane&quot;, &quot;Tristan Arndt&quot;, &quot;Tommy Graham&quot;, &quot;Trenton Bui&quot;, &quot;Ty Johnson&quot;,
    &quot;Trey Burkhart&quot;, &quot;Trey Lundy&quot;, &quot;Trevor Jackson&quot;, &quot;Trevor Simms&quot;, &quot;Tyler Banks&quot;,
    &quot;Tyler Davis&quot;, &quot;Tyler Gray&quot;, &quot;Tyler Smith&quot;, &quot;Tyler Wilson&quot;, &quot;Zachary Breaux&quot;,
    &quot;Zachary Brown&quot;, &quot;Zachary Chavez&quot;, &quot;Zachary Davis&quot;, &quot;Zachary Green&quot;, &quot;Zachary Johnson&quot;,
    &quot;Zachary Lee&quot;, &quot;Zachary Martin&quot;, &quot;Zachary Martinez&quot;, &quot;Zachary Miller&quot;, &quot;Zachary Mitchell&quot;,
    &quot;Zachary Moore&quot;, &quot;Zachary Nelson&quot;, &quot;Zachary Phillips&quot;, &quot;Zachary Robinson&quot;, &quot;Zachary Rodriguez&quot;,
    &quot;Zachary Scott&quot;, &quot;Zachary Smith&quot;, &quot;Zachary Taylor&quot;, &quot;Zachary Thompson&quot;, &quot;Zachary Walker&quot;,
    &quot;Zachary Wilson&quot;, &quot;Zachary Young&quot;,
];

function buildDefaultPrefabs() {
    return [
        {
            id: &quot;lineout&quot;,
            label: &quot;Lineout&quot;,
            mode: &quot;offense&quot;,
            icon: &lt;img src={rugbyLineout} alt=&quot;Lineout&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Number of Players&quot;, options: [&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;], value: &quot;5&quot;, onChange: (v) =&gt; console.log(&quot;Lineout players:&quot;, v) }],
        },
        {
            id: &quot;scrum&quot;,
            label: &quot;Scrum&quot;,
            mode: &quot;offense&quot;,
            icon: &lt;img src={rugbyScrum} alt=&quot;Scrum&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Number of Players&quot;, options: [&quot;3&quot;, &quot;8&quot;], value: &quot;3&quot;, onChange: (v) =&gt; console.log(&quot;Scrum players:&quot;, v) }],
        },
        {
            id: &quot;kickoff1&quot;,
            label: &quot;Kickoff&quot;,
            mode: &quot;offense&quot;,
            icon: &lt;img src={rugbyKickoff} alt=&quot;Kickoff&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Area&quot;, options: [&quot;Goal Line&quot;, &quot;22&quot;, &quot;50&quot;], value: &quot;5&quot;, onChange: (v) =&gt; console.log(&quot;Kickoff area:&quot;, v) }],
        },
        {
            id: &quot;scrum1&quot;,
            label: &quot;Scrum&quot;,
            mode: &quot;defense&quot;,
            icon: &lt;img src={rugbyLineout} alt=&quot;Lineout&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Formation&quot;, options: [&quot;3&quot;, &quot;8&quot;], value: &quot;3&quot;, onChange: (v) =&gt; console.log(&quot;Scrum formation:&quot;, v) }],
        },
        {
            id: &quot;lineout2&quot;,
            label: &quot;Lineout&quot;,
            mode: &quot;defense&quot;,
            icon: &lt;img src={rugbyLineout} alt=&quot;Lineout&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Players&quot;, options: [&quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;], value: &quot;4&quot;, onChange: (v) =&gt; console.log(&quot;Lineout players:&quot;, v) }],
        },
        {
            id: &quot;kickoff2&quot;,
            label: &quot;Kickoff&quot;,
            mode: &quot;defense&quot;,
            icon: &lt;img src={rugbyKickoff} alt=&quot;Kickoff&quot; className={iconClass} /&gt;,
            dropdowns: [{ label: &quot;Area&quot;, options: [&quot;Goal Line&quot;, &quot;22&quot;, &quot;50&quot;], value: &quot;Goal Line&quot;, onChange: (v) =&gt; console.log(&quot;Kickoff area:&quot;, v) }],
        },
    ];
}

// Same width as RightPanel: w-32 sm:w-36 md:w-40 lg:w-44 xl:w-48
const WIDE_SIDEBAR_WIDTH_CLASS = &quot;w-32 sm:w-36 md:w-40 lg:w-44 xl:w-48&quot;;

export default function WideSidebarRoot({
    onToolChange,
    onSelectSubTool,
    onPenSubTool,
    onEraserSubTool,
    onPlayerColorChange,
    onUndo,
    onRedo,
    onReset,
    onDeleteSelected,
    onPrefabSelect,
    onAddPlayer,
    players: playersProp,
    prefabs: prefabsProp,
}) {
    const [selectedTool, setSelectedTool] = useState(&quot;select&quot;);
    const [selectToolType, setSelectToolType] = useState(&quot;select&quot;);
    const [penToolType, setPenToolType] = useState(&quot;pen&quot;);
    const [eraserToolType, setEraserToolType] = useState(&quot;eraser&quot;);
    const [openPopover, setOpenPopover] = useState(null);
    const [playerNumber, setPlayerNumber] = useState(&quot;&quot;);
    const [playerName, setPlayerName] = useState(&quot;&quot;);
    const [playerSearch, setPlayerSearch] = useState(&quot;&quot;);
    const [showPlayerDropdown, setShowPlayerDropdown] = useState(false);
    const [playerColor, setPlayerColor] = useState(PLAYER_COLORS.red);
    const [hoveredTooltip, setHoveredTooltip] = useState(null);

    const selectButtonRef = useRef(null);
    const penButtonRef = useRef(null);
    const eraserButtonRef = useRef(null);
    const addPlayerButtonRef = useRef(null);
    const playerButtonRef = useRef(null);
    const prefabsButtonRef = useRef(null);
    const playerDropdownRef = useRef(null);

    const players = playersProp ?? DEFAULT_PLAYERS;
    const prefabs = prefabsProp ?? buildDefaultPrefabs();
    const filteredPlayers = players.filter((p) =&gt;
        String(p).toLowerCase().includes(playerSearch.toLowerCase())
    );

    const togglePopover = (key) =&gt; {
        setOpenPopover((prev) =&gt; (prev === key ? null : key));
    };
    const closePopover = () =&gt; setOpenPopover(null);

    const handleSelectSubTool = (option) =&gt; {
        setSelectToolType(option);
        setSelectedTool(option);
        closePopover();
        onSelectSubTool?.(option);
    };
    const handlePenSubTool = (option) =&gt; {
        setPenToolType(option);
        setSelectedTool(&quot;pen&quot;);
        closePopover();
        onPenSubTool?.(option);
    };
    const handleEraserSubTool = (option) =&gt; {
        setEraserToolType(option);
        setSelectedTool(&quot;eraser&quot;);
        closePopover();
        onEraserSubTool?.(option);
    };
    const handlePlayerColorChange = (hex) =&gt; {
        setPlayerColor(hex);
        closePopover();
        onPlayerColorChange?.(hex);
    };
    const handlePrefabSelect = (prefab) =&gt; {
        setSelectedTool(&quot;prefab&quot;);
        onPrefabSelect?.(prefab);
    };
    const handlePlayerAssign = (name) =&gt; {
        setPlayerSearch(name);
        setShowPlayerDropdown(false);
    };
    const handleAddPlayer = (data) =&gt; {
        const next = {
            number: data?.number ?? playerNumber,
            name: data?.name ?? playerName,
            assignment: data?.assignment ?? playerSearch,
            color: playerColor,
        };
        const hasValue =
            String(next.number ?? &quot;&quot;).trim() !== &quot;&quot; ||
            String(next.name ?? &quot;&quot;).trim() !== &quot;&quot; ||
            String(next.assignment ?? &quot;&quot;).trim() !== &quot;&quot;;
        if (!hasValue) return;
        onAddPlayer?.(next);
        setPlayerNumber(&quot;&quot;);
        setPlayerName(&quot;&quot;);
        setPlayerSearch(&quot;&quot;);
        setShowPlayerDropdown(false);
    };
    const handleQuickAddPlayer = () =&gt; {
        onAddPlayer?.({ color: playerColor });
    };

    useEffect(() =&gt; {
        onToolChange?.(selectedTool);
    }, [selectedTool, onToolChange]);

    useEffect(() =&gt; {
        const handleKeyDown = (e) =&gt; {
            const tag = e.target.tagName;
            if (tag === &quot;INPUT&quot; || tag === &quot;TEXTAREA&quot; || e.target.isContentEditable) return;
            if (e.ctrlKey || e.metaKey) {
                const key = e.key.toLowerCase();
                if (key === &quot;z&quot;) {
                    e.preventDefault();
                    onUndo?.();
                    return;
                }
                if (key === &quot;y&quot;) {
                    e.preventDefault();
                    onRedo?.();
                    return;
                }
                if (key === &quot;d&quot;) {
                    e.preventDefault();
                    onDeleteSelected?.();
                    return;
                }
            }
            const key = e.key.toLowerCase();
            if (key === &quot;s&quot;) {
                setSelectToolType(&quot;select&quot;);
                setSelectedTool(&quot;select&quot;);
                closePopover();
            } else if (key === &quot;h&quot;) {
                setSelectToolType(&quot;hand&quot;);
                setSelectedTool(&quot;hand&quot;);
                closePopover();
            } else if (key === &quot;p&quot;) {
                handlePenSubTool(&quot;pen&quot;);
            } else if (key === &quot;q&quot;) {
                handlePenSubTool(&quot;arrow&quot;);
            } else if (key === &quot;e&quot;) {
                setSelectedTool(&quot;eraser&quot;);
                closePopover();
            } else if (key === &quot;f&quot;) {
                handleEraserSubTool(&quot;full&quot;);
            } else if (key === &quot;o&quot;) {
                handleEraserSubTool(&quot;partial&quot;);
            } else if (key === &quot;a&quot;) {
                setSelectedTool(&quot;addPlayer&quot;);
                closePopover();
            } else if (key === &quot;c&quot;) {
                const nextColor = playerColor === PLAYER_COLORS.red ? PLAYER_COLORS.blue : PLAYER_COLORS.red;
                handlePlayerColorChange(nextColor);
                setSelectedTool(&quot;color&quot;);
            }
        };
        window.addEventListener(&quot;keydown&quot;, handleKeyDown);
        return () =&gt; window.removeEventListener(&quot;keydown&quot;, handleKeyDown);
    }, [closePopover, handleEraserSubTool, handlePenSubTool, handlePlayerColorChange, onDeleteSelected, onRedo, onUndo, playerColor]);

    useEffect(() =&gt; {
        if (!showPlayerDropdown) return;
        const handleClickOutside = (e) =&gt; {
            const input = e.target.closest(&apos;input[placeholder=&quot;Search player&quot;]&apos;);
            const button = e.target.closest(&quot;button&quot;);
            const dropdown = playerDropdownRef.current;
            if (dropdown &amp;&amp; !dropdown.contains(e.target) &amp;&amp; !input &amp;&amp; !button) {
                setShowPlayerDropdown(false);
            }
        };
        document.addEventListener(&quot;mousedown&quot;, handleClickOutside);
        return () =&gt; document.removeEventListener(&quot;mousedown&quot;, handleClickOutside);
    }, [showPlayerDropdown]);

    useEffect(() =&gt; {
        if (openPopover !== &quot;addPlayer&quot;) setShowPlayerDropdown(false);
    }, [openPopover]);

    const hr = &lt;hr className=&quot;w-full border-0 border-t border-BrandGray2/60&quot; /&gt;;

    return (
        &lt;aside
            className={`
                h-screen shrink-0 bg-BrandBlack ${WIDE_SIDEBAR_WIDTH_CLASS}
                border-l border-BrandGray2/50
                px-2 sm:px-2.5 md:px-3 py-4 sm:py-5
                flex flex-col justify-center
                gap-0.5 sm:gap-1 md:gap-1.5
                select-none z-50 overflow-visible
            `}
        &gt;
            &lt;p className=&quot;text-BrandGray2 text-[10px] sm:text-xs font-DmSans uppercase tracking-wider px-2 mb-0.5&quot;&gt;
                Tools
            &lt;/p&gt;
            &lt;SelectToolSection
                wide
                selectToolType={selectToolType}
                isSelected={selectedTool === &quot;select&quot; || selectedTool === &quot;hand&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={selectButtonRef}
                onToolSelect={(t) =&gt; setSelectedTool(t)}
                onSelectSubTool={handleSelectSubTool}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
            {hr}

            &lt;PenToolSection
                wide
                penToolType={penToolType}
                isSelected={selectedTool === &quot;pen&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={penButtonRef}
                onToolSelect={() =&gt; setSelectedTool(&quot;pen&quot;)}
                onPenSubTool={handlePenSubTool}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
            {hr}

            &lt;EraserToolSection
                wide
                eraserToolType={eraserToolType}
                isSelected={selectedTool === &quot;eraser&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={eraserButtonRef}
                onToolSelect={() =&gt; setSelectedTool(&quot;eraser&quot;)}
                onEraserSubTool={handleEraserSubTool}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
            {hr}

            &lt;AddPlayerSection
                wide
                isSelected={selectedTool === &quot;addPlayer&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                numberValue={playerNumber}
                nameValue={playerName}
                playerSearch={playerSearch}
                showPlayerDropdown={showPlayerDropdown}
                filteredPlayers={filteredPlayers}
                anchorRef={addPlayerButtonRef}
                dropdownRef={playerDropdownRef}
                onToolSelect={() =&gt; setSelectedTool(&quot;addPlayer&quot;)}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onNumberChange={setPlayerNumber}
                onNameChange={setPlayerName}
                onPlayerSearchChange={setPlayerSearch}
                onPlayerAssign={handlePlayerAssign}
                onShowPlayerDropdownChange={setShowPlayerDropdown}
                onHoverTooltip={setHoveredTooltip}
                onAddPlayer={handleAddPlayer}
                onQuickAdd={handleQuickAddPlayer}
            /&gt;
            {hr}

            &lt;PlayerColorSection
                wide
                playerColor={playerColor}
                isSelected={selectedTool === &quot;color&quot;}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={playerButtonRef}
                onToolSelect={() =&gt; setSelectedTool(&quot;color&quot;)}
                onPlayerColorChange={handlePlayerColorChange}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onHoverTooltip={setHoveredTooltip}
                onQuickAdd={handleQuickAddPlayer}
            /&gt;
            {hr}

            &lt;PrefabsSection
                wide
                prefabs={prefabs}
                openPopover={openPopover}
                hoveredTooltip={hoveredTooltip}
                anchorRef={prefabsButtonRef}
                onPopoverToggle={togglePopover}
                onPopoverClose={closePopover}
                onPrefabSelect={handlePrefabSelect}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
            {hr}

            &lt;p className=&quot;text-BrandGray2 text-[10px] sm:text-xs font-DmSans uppercase tracking-wider px-2 mt-1 mb-0.5&quot;&gt;
                History
            &lt;/p&gt;
            &lt;HistoryActionsSection
                wide
                onUndo={onUndo}
                onRedo={onRedo}
                onReset={onReset}
                hoveredTooltip={hoveredTooltip}
                onHoverTooltip={setHoveredTooltip}
            /&gt;
        &lt;/aside&gt;
    );
}</file><file path="src/components/AdvancedSettings.jsx">import React from &apos;react&apos;;
import { FaTimes } from &quot;react-icons/fa&quot;;
import PitchSettingsSection from &quot;./advancedSettings/PitchSettingsSection&quot;;
import PlayerSettingsSection from &quot;./advancedSettings/PlayerSettingsSection&quot;;
import ExportVideoSettingsSection from &quot;./advancedSettings/ExportVideoSettingsSection&quot;;
import AnimationSettingsSection from &quot;./advancedSettings/AnimationSettingsSection&quot;;
import LoggerSettingsSection from &quot;./advancedSettings/LoggerSettingsSection&quot;;
import SavePrefabButton from &quot;./rightPanel/SavePrefabButton&quot;;

export default function AdvancedSettings({ value, onChange, onReset, onClose }) {
    const settings = value ?? {};
    const pitch = settings.pitch ?? {};
    const players = settings.players ?? {};
    const exportVideo = settings.exportVideo ?? {};
    const animation = settings.animation ?? {};
    const logging = settings.logging ?? {};

    const update = (patch) =&gt; onChange?.({ ...settings, ...patch });
    const updatePitch = (patch) =&gt; update({ pitch: { ...pitch, ...patch } });
    const updatePlayers = (patch) =&gt; update({ players: { ...players, ...patch } });
    const updateExportVideo = (patch) =&gt; update({ exportVideo: { ...exportVideo, ...patch } });
    const updateAnimation = (patch) =&gt; update({ animation: { ...animation, ...patch } });
    const updateLogging = (patch) =&gt; update({ logging: { ...logging, ...patch } });

    return (
        &lt;div className=&quot;absolute right-0 top-0 h-screen z-50 flex flex-col&quot;&gt;
            &lt;aside
                className=&quot;
                     flex-1 shrink-0 bg-BrandBlack
                     w-36 sm:w-40 md:w-48 lg:w-52 xl:w-56
                     px-2 sm:px-2.5 md:px-3 py-2 sm:py-2.5 md:py-3
                     flex flex-col
                     gap-0.5 sm:gap-0.5 md:gap-1 lg:gap-1.5
                     select-none
                     overflow-y-auto hide-scroll
                     flex flex-col justify-start

                   &quot;
            &gt;
                &lt;div className=&quot;flex flex-row border-b border-BrandGray2 pb-1.5 sm:pb-2 items-center justify-center gap-1.5 sm:gap-2 font-DmSans font-bold&quot;&gt;
                    &lt;p
                        className=&quot;text-BrandWhite text-lg sm:text-xl md:text-2xl bg-transparent border-none outline-none focus:outline-none text-center font-DmSans font-bold w-full max-w-[100px] sm:max-w-[110px] md:max-w-[120px]&quot;
                    &gt;
                        Advanced Settings
                    &lt;/p&gt;
                &lt;/div&gt;

                &lt;PitchSettingsSection value={pitch} onChange={updatePitch} /&gt;
                &lt;PlayerSettingsSection value={players} onChange={updatePlayers} /&gt;
                &lt;ExportVideoSettingsSection value={exportVideo} onChange={updateExportVideo} /&gt;
                &lt;AnimationSettingsSection value={animation} onChange={updateAnimation} /&gt;
                &lt;LoggerSettingsSection value={logging} onChange={updateLogging} /&gt;
                &lt;SavePrefabButton /&gt;
            &lt;/aside&gt;
            {/* Reset to Default - Fixed at bottom */}
            &lt;div className=&quot;w-36 sm:w-40 md:w-48 lg:w-52 xl:w-56 px-2 sm:px-2.5 md:px-3 py-2 sm:py-2.5 bg-BrandBlack border-t border-BrandGray2&quot;&gt;
                &lt;button
                    onClick={() =&gt; onReset?.()}
                    className=&quot;text-BrandBlack text-xs sm:text-sm md:text-base font-DmSans bg-BrandOrange h-5 sm:h-6 w-full flex flex-row items-center justify-center rounded-md cursor-pointer hover:bg-BrandOrange/90 transition-colors&quot;
                &gt;
                    Reset to Default
                &lt;/button&gt;
            &lt;/div&gt;
            {/* close menu */}
            &lt;button
                onClick={() =&gt; {
                    onClose?.();
                }}
                className=&quot;absolute left-[-45px] top-1/2 transform -translate-y-1/2 w-8 h-8 sm:w-10 sm:h-10 bg-BrandBlack border-[0.5px] border-BrandGray rounded-full z-50 shadow-lg flex items-center justify-center cursor-pointer hover:bg-BrandBlack2 transition-colors duration-200 hover:border-BrandOrange&quot;
                aria-label=&quot;Close advanced settings&quot;
            &gt;
                &lt;FaTimes className=&quot;text-BrandOrange text-sm sm:text-base md:text-lg hover:text-BrandOrange transition-colors&quot; /&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    )
}</file><file path="src/components/DragCanvas.jsx">// DragCanvas.jsx
// No drag/drop libraries. Pure React + pointer events.
// Drop this into src/components/DragCanvas.jsx and use it in App.jsx.

import React, { useEffect, useMemo, useRef, useState } from &quot;react&quot;;

function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}

function getPointFromEvent(e) {
  // Works for mouse, touch, pen (Pointer Events)
  return { x: e.clientX, y: e.clientY };
}

function getRect(el) {
  const r = el.getBoundingClientRect();
  return { left: r.left, top: r.top, width: r.width, height: r.height };
}

/**
 * DragCanvas
 * - A &quot;stage&quot; (div) that behaves like a canvas area.
 * - Contains draggable items (circles by default).
 * - You can add more items or replace the render for items later.
 */
export default function DragCanvas({
  height = &quot;100vh&quot;,
  width = 700,
  initialItems,
  snapToGrid = false,
  gridSize = 20,
}) {
  const stageRef = useRef(null);

  const defaultItems = useMemo(
    () =&gt; [
      { id: &quot;p1&quot;, x: 120, y: 120, r: 50, fill: &quot;red&quot;, stroke: &quot;black&quot; },
    ],
    []
  );

  const [items, setItems] = useState(initialItems ?? defaultItems);

  const [dragState, setDragState] = useState({
    draggingId: null,
    pointerId: null,
    offsetX: 0,
    offsetY: 0,
  });

  // Optional: cursor feedback
  useEffect(() =&gt; {
    if (!dragState.draggingId) return;
    document.body.style.cursor = &quot;grabbing&quot;;
    return () =&gt; {
      document.body.style.cursor = &quot;default&quot;;
    };
  }, [dragState.draggingId]);

  function startDrag(e, id) {
    if (!stageRef.current) return;

    // Capture pointer so dragging continues even if pointer leaves the circle
    e.currentTarget.setPointerCapture?.(e.pointerId);

    const stage = getRect(stageRef.current);
    const pt = getPointFromEvent(e);

    setItems((prev) =&gt; {
      const item = prev.find((it) =&gt; it.id === id);
      if (!item) return prev;

      const xInStage = pt.x - stage.left;
      const yInStage = pt.y - stage.top;

      setDragState({
        draggingId: id,
        pointerId: e.pointerId,
        offsetX: xInStage - item.x,
        offsetY: yInStage - item.y,
      });

      return prev;
    });
  }

  function onPointerMove(e) {
    if (!dragState.draggingId || !stageRef.current) return;
    if (dragState.pointerId !== e.pointerId) return;

    const stage = getRect(stageRef.current);
    const pt = getPointFromEvent(e);

    const rawX = pt.x - stage.left - dragState.offsetX;
    const rawY = pt.y - stage.top - dragState.offsetY;

    setItems((prev) =&gt; {
      const idx = prev.findIndex((it) =&gt; it.id === dragState.draggingId);
      if (idx === -1) return prev;

      const it = prev[idx];

      let nextX = rawX;
      let nextY = rawY;

      if (snapToGrid) {
        nextX = Math.round(nextX / gridSize) * gridSize;
        nextY = Math.round(nextY / gridSize) * gridSize;
      }

      // Keep inside stage bounds (respect radius)
      nextX = clamp(nextX, it.r, stage.width - it.r);
      nextY = clamp(nextY, it.r, stage.height - it.r);

      const next = [...prev];
      next[idx] = { ...it, x: nextX, y: nextY };
      return next;
    });
  }

  function endDrag(e) {
    if (!dragState.draggingId) return;
    if (dragState.pointerId !== e.pointerId) return;

    setDragState({
      draggingId: null,
      pointerId: null,
      offsetX: 0,
      offsetY: 0,
    });
  }

  function addCircle() {
    setItems((prev) =&gt; [
      ...prev,
      {
        id: `p${prev.length + 1}`,
        x: 120,
        y: 120,
        r: 40,
        fill: &quot;dodgerblue&quot;,
        stroke: &quot;black&quot;,
      },
    ]);
  }

  return (
    &lt;div style={{ display: &quot;flex&quot;, gap: 16, padding: 16 }}&gt;
      &lt;div style={{ width: 260 }}&gt;
        &lt;div style={{ fontWeight: 700, marginBottom: 8 }}&gt;Toolbox&lt;/div&gt;

        &lt;button
          onClick={addCircle}
          style={{
            padding: &quot;10px 12px&quot;,
            borderRadius: 10,
            border: &quot;1px solid #ddd&quot;,
            background: &quot;white&quot;,
            cursor: &quot;pointer&quot;,
          }}
        &gt;
          + Add Circle
        &lt;/button&gt;

        &lt;div style={{ marginTop: 12, fontSize: 13, color: &quot;#555&quot; }}&gt;
          Drag circles around the stage. This is pure React (no Konva, no DnD
          libs).
        &lt;/div&gt;

        &lt;div style={{ marginTop: 12, fontSize: 12, color: &quot;#777&quot; }}&gt;
          Tip: set &lt;code&gt;snapToGrid&lt;/code&gt; to true for play-alignment.
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div
        ref={stageRef}
        onPointerMove={onPointerMove}
        onPointerUp={endDrag}
        onPointerCancel={endDrag}
        style={{
          width,
          height,
          borderRadius: 16,
          border: &quot;2px solid #111&quot;,
          background: &quot;#f7f7f7&quot;,
          position: &quot;relative&quot;,
          overflow: &quot;hidden&quot;,
          touchAction: &quot;none&quot;, // important for mobile dragging
          userSelect: &quot;none&quot;,
        }}
      &gt;
        {items.map((it) =&gt; {
          const isDragging = dragState.draggingId === it.id;

          return (
            &lt;div
              key={it.id}
              onPointerDown={(e) =&gt; startDrag(e, it.id)}
              onPointerEnter={() =&gt; {
                if (!dragState.draggingId) document.body.style.cursor = &quot;grab&quot;;
              }}
              onPointerLeave={() =&gt; {
                if (!dragState.draggingId) document.body.style.cursor = &quot;default&quot;;
              }}
              style={{
                position: &quot;absolute&quot;,
                left: it.x - it.r,
                top: it.y - it.r,
                width: it.r * 2,
                height: it.r * 2,
                borderRadius: &quot;50%&quot;,
                background: it.fill,
                border: `4px solid ${it.stroke}`,
                boxSizing: &quot;border-box&quot;,
                cursor: isDragging ? &quot;grabbing&quot; : &quot;grab&quot;,
                display: &quot;flex&quot;,
                alignItems: &quot;center&quot;,
                justifyContent: &quot;center&quot;,
                fontWeight: 700,
                color: &quot;white&quot;,
              }}
            &gt;
              {it.id.toUpperCase()}
            &lt;/div&gt;
          );
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/RightPanel.jsx">import React from &quot;react&quot;;
import PlayNameEditor from &quot;./rightPanel/PlayNameEditor&quot;;
import FieldSettingsSection from &quot;./rightPanel/FieldSettingsSection&quot;;
import PlayersSection from &quot;./rightPanel/PlayersSection&quot;;
import AdvancedSettingsButton from &quot;./rightPanel/AdvancedSettingsButton&quot;;
import AllPlayersSection from &quot;./rightPanel/AllPlayersSection&quot;;
import SelectedPlayersSection from &quot;./rightPanel/SelectedPlayersSection&quot;;
import ExportActions from &quot;./rightPanel/ExportActions&quot;;

export default function RightPanel({
  playName,
  onPlayNameChange,

  zoomPercent,
  onZoomIn,
  onZoomOut,
  onZoomPercentChange,

  onRotateLeft,
  onRotateCenter,
  onRotateRight,
  onFieldUndo,
  onFieldRedo,
  onReset,

  playersById,
  representedPlayerIds,
  selectedPlayerIds,
  selectedPlayers,
  onSelectPlayer,
  onEditPlayer,
  onDeletePlayer,

  allPlayersDisplay,
  onAllPlayersDisplayChange,
  onSelectedPlayersColorChange,

  advancedSettingsOpen,
  onOpenAdvancedSettings,

  onSaveToPlaybook,
  onDownload,
}) {
  return (
    &lt;aside
      className=&quot;
        h-screen shrink-0 bg-BrandBlack
        w-32 sm:w-36 md:w-40 lg:w-44 xl:w-48
        px-2 sm:px-2.5 md:px-3 py-2 sm:py-2.5 md:py-3
        flex flex-col
        gap-0.5 sm:gap-0.5 md:gap-1 lg:gap-1.5
        select-none
        overflow-hidden
        z-50
      &quot;
    &gt;
      {/* Scrollable content area (everything except export actions) */}
      &lt;div className=&quot;flex-1 min-h-0 overflow-y-auto overflow-x-hidden pr-0.5 hide-scroll&quot;&gt;
        &lt;div className=&quot;flex flex-col gap-0.5 sm:gap-0.5 md:gap-1 lg:gap-1.5&quot;&gt;
          &lt;PlayNameEditor value={playName} onChange={onPlayNameChange} maxLength={10} /&gt;

          &lt;FieldSettingsSection
            zoomPercent={zoomPercent}
            onZoomIn={onZoomIn}
            onZoomOut={onZoomOut}
            onZoomPercentChange={onZoomPercentChange}
            onRotateLeft={onRotateLeft}
            onRotateCenter={onRotateCenter}
            onRotateRight={onRotateRight}
            onUndo={onFieldUndo}
            onRedo={onFieldRedo}
            onReset={onReset}
          /&gt;

          &lt;PlayersSection
            playersById={playersById}
            representedPlayerIds={representedPlayerIds}
            selectedPlayerIds={selectedPlayerIds}
            onSelectPlayer={onSelectPlayer}
            onEditPlayer={onEditPlayer}
            onDeletePlayer={onDeletePlayer}
          /&gt;

          {selectedPlayerIds?.length &gt; 0 ? (
            &lt;SelectedPlayersSection
              selectedPlayerIds={selectedPlayerIds}
              selectedPlayers={selectedPlayers}
              allPlayersDisplay={allPlayersDisplay}
              onAllPlayersDisplayChange={onAllPlayersDisplayChange}
              onSelectedPlayersColorChange={onSelectedPlayersColorChange}
            /&gt;
          ) : (
            &lt;AllPlayersSection value={allPlayersDisplay} onChange={onAllPlayersDisplayChange} /&gt;
          )}

          &lt;AdvancedSettingsButton isOpen={advancedSettingsOpen} onOpen={onOpenAdvancedSettings} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Fixed bottom area */}
      &lt;div className=&quot;shrink-0 pt-1.5 sm:pt-2 border&quot;&gt;
        &lt;ExportActions onSaveToPlaybook={onSaveToPlaybook} onDownload={onDownload} /&gt;
      &lt;/div&gt;
    &lt;/aside&gt;
  );
}</file><file path="src/components/Sidebar.jsx">import SidebarRoot from &quot;./sidebar/SidebarRoot&quot;;

export default function Sidebar({
    onToolChange,
    onSelectSubTool,
    onPenSubTool,
    onEraserSubTool,
    onPlayerColorChange,
    onUndo,
    onRedo,
    onReset,
    onDeleteSelected,
    onPrefabSelect,
    onAddPlayer,
    players,
    prefabs,
}) {
    return (
        &lt;SidebarRoot
            onToolChange={onToolChange}
            onSelectSubTool={onSelectSubTool}
            onPenSubTool={onPenSubTool}
            onEraserSubTool={onEraserSubTool}
            onPlayerColorChange={onPlayerColorChange}
            onUndo={onUndo}
            onRedo={onRedo}
            onReset={onReset}
            onDeleteSelected={onDeleteSelected}
            onPrefabSelect={onPrefabSelect}
            onAddPlayer={onAddPlayer}
            players={players}
            prefabs={prefabs}
        /&gt;
    );
}</file><file path="src/components/WideSidebar.jsx">import WideSidebarRoot from &quot;./wideSidebar/WideSidebarRoot&quot;;

export default function WideSidebar({
    onToolChange,
    onSelectSubTool,
    onPenSubTool,
    onEraserSubTool,
    onPlayerColorChange,
    onUndo,
    onRedo,
    onReset,
    onDeleteSelected,
    onPrefabSelect,
    onAddPlayer,
    players,
    prefabs,
}) {
    return (
        &lt;WideSidebarRoot
            onToolChange={onToolChange}
            onSelectSubTool={onSelectSubTool}
            onPenSubTool={onPenSubTool}
            onEraserSubTool={onEraserSubTool}
            onPlayerColorChange={onPlayerColorChange}
            onUndo={onUndo}
            onRedo={onRedo}
            onReset={onReset}
            onDeleteSelected={onDeleteSelected}
            onPrefabSelect={onPrefabSelect}
            onAddPlayer={onAddPlayer}
            players={players}
            prefabs={prefabs}
        /&gt;
    );
}</file><file path="src/utils/exportPlay.js">export const EXPORT_SCHEMA_VERSION = &quot;play-export-v1&quot;;

const sanitizeFilename = (name) =&gt; {
  const trimmed = String(name ?? &quot;&quot;).trim();
  if (!trimmed) return &quot;play&quot;;
  const lower = trimmed.toLowerCase();
  const hyphenated = lower.replace(/\s+/g, &quot;-&quot;);
  const cleaned = hyphenated.replace(/[^a-z0-9-_]+/g, &quot;&quot;);
  const collapsed = cleaned.replace(/-+/g, &quot;-&quot;).replace(/^[-_]+|[-_]+$/g, &quot;&quot;);
  return collapsed || &quot;play&quot;;
};

export const buildPlayExportV1 = ({
  playName,
  playId = null,
  appVersion = null,
  advancedSettings,
  allPlayersDisplay,
  currentPlayerColor,
  camera,
  fieldRotation,
  playersById,
  representedPlayerIds,
  ball,
  keyframes,
  keyframeSnapshots,
  playback,
  coordinateSystem,
} = {}) =&gt; {
  return {
    schemaVersion: EXPORT_SCHEMA_VERSION,
    exportedAt: new Date().toISOString(),
    play: {
      name: playName ?? &quot;&quot;,
      id: playId ?? null,
      settings: {
        advancedSettings: advancedSettings ?? null,
        allPlayersDisplay: allPlayersDisplay ?? null,
        currentPlayerColor: currentPlayerColor ?? null,
      },
      canvas: {
        camera: camera ?? { x: 0, y: 0, zoom: 1 },
        fieldRotation: fieldRotation ?? 0,
        coordinateSystem: coordinateSystem ?? {
          origin: &quot;center&quot;,
          units: &quot;px&quot;,
          notes: &quot;World coordinates are centered; +x right, +y down.&quot;,
        },
      },
      entities: {
        playersById: playersById ?? {},
        representedPlayerIds: representedPlayerIds ?? [],
        ball: ball ?? null,
      },
      timeline: {
        keyframes: keyframes ?? [],
        keyframeSnapshots: keyframeSnapshots ?? {},
        playback: playback ?? null,
      },
      meta: {
        appVersion: appVersion ?? null,
      },
    },
  };
};

export const downloadPlayExport = (playExport, playName) =&gt; {
  if (!playExport) return;
  const filename = `${sanitizeFilename(playName)}.json`;
  const json = JSON.stringify(playExport, null, 2);
  const blob = new Blob([json], { type: &quot;application/json&quot; });
  const url = URL.createObjectURL(blob);
  const link = document.createElement(&quot;a&quot;);
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
};</file><file path="src/App.jsx">import &quot;./index.css&quot;;
import WideSidebar from &quot;./components/WideSidebar&quot;;
import { useState, useEffect, useRef, useCallback } from &quot;react&quot;;
import ControlPill from &quot;./components/controlPill/ControlPill&quot;;
import RightPanel from &quot;./components/RightPanel&quot;;
import AdvancedSettings from &quot;./components/AdvancedSettings&quot;;
import CanvasRoot from &quot;./canvas/CanvasRoot&quot;;
import MessagePopup from &quot;./components/MessagePopup/MessagePopup&quot;;
import PlayerEditPanel from &quot;./components/rightPanel/PlayerEditPanel&quot;;
import { buildPlayExportV1, downloadPlayExport } from &quot;./utils/exportPlay&quot;;

const KEYFRAME_TOLERANCE = 4;
const LOOP_SECONDS = 30;

function App() {
  const [color, setColor] = useState(&quot;#561ecb&quot;);
  const [showAdvancedSettings, setShowAdvancedSettings] = useState(false);
  const [logControlPillState, setLogControlPillState] = useState(false);
  const [canvasTool, setCanvasTool] = useState(&quot;hand&quot;);

  const DEFAULT_ADVANCED_SETTINGS = {
    pitch: {
      showMarkings: true,
      pitchSize: &quot;Full Field&quot;,
      pitchColor: &quot;#4FA85D&quot;, // Stadium Grass
    },
    players: {
      // This is the &quot;base&quot; player size in pixels at 100% in the Right Panel.
      // (Right Panel sizePercent scales from this.)
      baseSizePx: 30,
    },
    exportVideo: {
      videoQuality: &quot;1080p&quot;,
      watermark: true,
      includeMetadata: true,
    },
    animation: {
      playOnLoad: true,
    },
    logging: {
      slate: false,
      controlPill: false,
      canvas: false,
      sidebar: false,
    },
  };

  const [advancedSettings, setAdvancedSettings] = useState(DEFAULT_ADVANCED_SETTINGS);
  const logging = advancedSettings?.logging ?? {};
  const logEvent = (scope, action, payload) =&gt; {
    if (!logging?.[scope]) return;
    const stamp = new Date().toISOString();
    if (payload !== undefined) {
      console.log(`[${stamp}] ${scope}: ${action}`, payload);
      return;
    }
    console.log(`[${stamp}] ${scope}: ${action}`);
  };

  // Message popup state
  const [messagePopup, setMessagePopup] = useState({
    visible: false,
    message: &quot;&quot;,
    subtitle: &quot;&quot;,
    type: &quot;standard&quot;,
  });

  // Method to show message popup
  const showMessage = useCallback(
    (message, subtitle = &quot;&quot;, type = &quot;standard&quot;, duration = 3000) =&gt; {
      setMessagePopup({
        visible: true,
        message,
        subtitle,
        type,
      });
    },
    []
  );

  const hideMessage = useCallback(() =&gt; {
    setMessagePopup((prev) =&gt; ({ ...prev, visible: false }));
  }, []);

  // RightPanel / Canvas shared state
  const [playName, setPlayName] = useState(&quot;Name&quot;);
  const [camera, setCamera] = useState({ x: 0, y: 0, zoom: 1 });
  const [fieldRotation, setFieldRotation] = useState(0);
  const DEFAULT_PLAYER_COLOR = &quot;#ef4444&quot;;
  const INITIAL_PLAYERS_BY_ID = {
    &quot;player-1&quot;: {
      id: &quot;player-1&quot;,
      x: 0,
      y: 0,
      number: 1,
      name: &quot;John&quot;,
      assignment: &quot;Left Wing&quot;,
      color: DEFAULT_PLAYER_COLOR,
    },
  };
  const [playersById, setPlayersById] = useState(() =&gt; INITIAL_PLAYERS_BY_ID);
  const [representedPlayerIds, setRepresentedPlayerIds] = useState(() =&gt; [&quot;player-1&quot;]);
  const [selectedPlayerIds, setSelectedPlayerIds] = useState([]);
  const [selectedItemIds, setSelectedItemIds] = useState([]);
  const [currentPlayerColor, setCurrentPlayerColor] = useState(DEFAULT_PLAYER_COLOR);
  const [playerEditor, setPlayerEditor] = useState({
    open: false,
    id: null,
    draft: { number: &quot;&quot;, name: &quot;&quot;, assignment: &quot;&quot; },
  });
  const [allPlayersDisplay, setAllPlayersDisplay] = useState(() =&gt; ({
    sizePercent: 100,
    color: DEFAULT_PLAYER_COLOR,
    showNumber: true,
    showName: false,
  }));
  // Default ball present on load; slightly offset so it isn&apos;t occluded by a centered player
  const INITIAL_BALL = { id: &quot;ball-1&quot;, x: 40, y: 0 };
  const [ball, setBall] = useState(() =&gt; INITIAL_BALL);
  const [historyPast, setHistoryPast] = useState([]);
  const [historyFuture, setHistoryFuture] = useState([]);
  const isRestoringRef = useRef(false);
  const [fieldHistoryPast, setFieldHistoryPast] = useState([]);
  const [fieldHistoryFuture, setFieldHistoryFuture] = useState([]);
  const isFieldRestoringRef = useRef(false);
  const pendingKeyframeUpdateRef = useRef(false);
  const pendingKeyframeTimeRef = useRef(null);
  const isItemDraggingRef = useRef(false);

  const clamp = (n, min, max) =&gt; Math.min(max, Math.max(min, n));
  const zoomPercent = clamp(Math.round((camera.zoom || 1) * 100), 30, 300);

  const normalizeNumber = (value) =&gt; {
    const trimmed = String(value ?? &quot;&quot;).trim();
    if (trimmed === &quot;&quot;) return &quot;&quot;;
    const asNumber = Number(trimmed);
    return Number.isNaN(asNumber) ? trimmed : asNumber;
  };

  const getNextPlayerId = (byId) =&gt; {
    let maxId = 0;
    Object.keys(byId || {}).forEach((id) =&gt; {
      const match = id.match(/player-(\d+)/);
      if (match) {
        const n = Number(match[1]);
        if (!Number.isNaN(n)) maxId = Math.max(maxId, n);
      }
    });
    return `player-${maxId + 1}`;
  };

  const getRandomNearbyPosition = (base) =&gt; {
    const jitter = 30;
    const dx = (Math.random() * 2 - 1) * jitter;
    const dy = (Math.random() * 2 - 1) * jitter;
    return { x: (base?.x ?? 0) + dx, y: (base?.y ?? 0) + dy };
  };

  const setZoomPercent = (nextPercent) =&gt; {
    const pct = clamp(Number(nextPercent) || 0, 30, 300);
    const nextZoom = pct / 100;
    if (Math.abs((camera.zoom || 1) - nextZoom) &lt; 0.0001) return;
    pushFieldHistory();
    setCamera((prev) =&gt; ({ ...prev, zoom: nextZoom }));
  };
  const zoomIn = () =&gt; setZoomPercent(zoomPercent + 5);
  const zoomOut = () =&gt; setZoomPercent(zoomPercent - 5);

  // Field actions (placeholder callbacks for now)
  const onRotateLeft = () =&gt; {
    if (fieldRotation === -90) return;
    pushFieldHistory();
    setFieldRotation(-90);
  };
  const onRotateCenter = () =&gt; {
    if (fieldRotation === 180) return;
    pushFieldHistory();
    setFieldRotation(180);
  };
  const onRotateRight = () =&gt; {
    if (fieldRotation === 90) return;
    pushFieldHistory();
    setFieldRotation(90);
  };
  const snapshotSlate = () =&gt; ({
    playersById: { ...playersById },
    representedPlayerIds: [...representedPlayerIds],
    ball: { ...ball },
  });

  const applySlate = (snapshot) =&gt; {
    if (!snapshot) return;
    isRestoringRef.current = true;
    setPlayersById(snapshot.playersById || {});
    setRepresentedPlayerIds(snapshot.representedPlayerIds || []);
    setBall(snapshot.ball || INITIAL_BALL);
    setSelectedPlayerIds((prev) =&gt;
      (prev || []).filter((playerId) =&gt; snapshot.playersById?.[playerId])
    );
    setSelectedItemIds((prev) =&gt;
      (prev || []).filter((itemId) =&gt; snapshot.playersById?.[itemId] || itemId === snapshot.ball?.id)
    );
    isRestoringRef.current = false;
  };

  const snapshotField = () =&gt; ({
    camera: { ...camera },
    fieldRotation,
  });

  const applyField = (snapshot) =&gt; {
    if (!snapshot) return;
    isFieldRestoringRef.current = true;
    setCamera(snapshot.camera || { x: 0, y: 0, zoom: 1 });
    setFieldRotation(snapshot.fieldRotation ?? 0);
    isFieldRestoringRef.current = false;
  };

  const pushFieldHistory = () =&gt; {
    if (isFieldRestoringRef.current) return;
    setFieldHistoryPast((prev) =&gt; [...prev, snapshotField()]);
    setFieldHistoryFuture([]);
  };

  const pushHistory = () =&gt; {
    if (isRestoringRef.current) return;
    markKeyframeSnapshotPending();
    setHistoryPast((prev) =&gt; [...prev, snapshotSlate()]);
    setHistoryFuture([]);
  };

  const onUndo = () =&gt; {
    logEvent(&quot;slate&quot;, &quot;undo&quot;);
    setHistoryPast((prev) =&gt; {
      if (prev.length === 0) return prev;
      const nextPast = prev.slice(0, -1);
      const previous = prev[prev.length - 1];
      setHistoryFuture((future) =&gt; [...future, snapshotSlate()]);
      applySlate(previous);
      return nextPast;
    });
  };

  const onFieldUndo = () =&gt; {
    setFieldHistoryPast((prev) =&gt; {
      if (prev.length === 0) return prev;
      const nextPast = prev.slice(0, -1);
      const previous = prev[prev.length - 1];
      setFieldHistoryFuture((future) =&gt; [...future, snapshotField()]);
      applyField(previous);
      return nextPast;
    });
  };

  const onFieldRedo = () =&gt; {
    setFieldHistoryFuture((prev) =&gt; {
      if (prev.length === 0) return prev;
      const nextFuture = prev.slice(0, -1);
      const next = prev[prev.length - 1];
      setFieldHistoryPast((past) =&gt; [...past, snapshotField()]);
      applyField(next);
      return nextFuture;
    });
  };

  const onRedo = () =&gt; {
    logEvent(&quot;slate&quot;, &quot;redo&quot;);
    setHistoryFuture((prev) =&gt; {
      if (prev.length === 0) return prev;
      const nextFuture = prev.slice(0, -1);
      const next = prev[prev.length - 1];
      setHistoryPast((past) =&gt; [...past, snapshotSlate()]);
      applySlate(next);
      return nextFuture;
    });
  };

  const onReset = () =&gt; {
    logEvent(&quot;slate&quot;, &quot;reset&quot;);
    isRestoringRef.current = true;
    setPlayersById(INITIAL_PLAYERS_BY_ID);
    setRepresentedPlayerIds([&quot;player-1&quot;]);
    setBall(INITIAL_BALL);
    setSelectedPlayerIds([]);
    setSelectedItemIds([]);
    setHistoryPast([]);
    setHistoryFuture([]);
    setCamera({ x: 0, y: 0, zoom: 1 });
    setFieldRotation(0);
    setFieldHistoryPast([]);
    setFieldHistoryFuture([]);
    isRestoringRef.current = false;
  };

  const onSaveToPlaybook = () =&gt; { };
  const onDownload = () =&gt; {
    const appVersion = import.meta?.env?.VITE_APP_VERSION ?? null;
    const exportPayload = buildPlayExportV1({
      playName,
      appVersion,
      advancedSettings,
      allPlayersDisplay,
      currentPlayerColor,
      camera,
      fieldRotation,
      playersById,
      representedPlayerIds,
      ball,
      keyframes,
      keyframeSnapshots,
      playback: {
        loopSeconds: LOOP_SECONDS,
        keyframeTolerance: KEYFRAME_TOLERANCE,
        speedMultiplier,
        autoplayEnabled,
      },
      coordinateSystem: {
        origin: &quot;center&quot;,
        units: &quot;px&quot;,
        notes: &quot;World coordinates are centered; +x right, +y down.&quot;,
      },
    });
    downloadPlayExport(exportPayload, playName);
  };

  const handleToolChange = useCallback((tool) =&gt; {
    if (tool === &quot;hand&quot; || tool === &quot;select&quot; || tool === &quot;addPlayer&quot; || tool === &quot;color&quot;) {
      setCanvasTool((prev) =&gt; (prev === tool ? prev : tool));
    }
  }, []);

  const handlePlayerColorChange = (hex) =&gt; {
    setCurrentPlayerColor(hex);
  };

  const handleSelectedPlayersColorChange = (hex, ids) =&gt; {
    const targetIds = Array.isArray(ids) &amp;&amp; ids.length ? ids : selectedPlayerIds;
    if (!targetIds?.length) return;
    pushHistory();
    setPlayersById((prev) =&gt; {
      const next = { ...prev };
      targetIds.forEach((id) =&gt; {
        if (!next[id]) return;
        next[id] = { ...next[id], color: hex };
      });
      return next;
    });
  };

  const resolveNextNumber = (providedNumber) =&gt; {
    const trimmed = String(providedNumber ?? &quot;&quot;).trim();
    if (trimmed !== &quot;&quot;) {
      const normalized = normalizeNumber(trimmed);
      return normalized;
    }
    if (!representedPlayerIds?.length) return 1;
    for (let i = representedPlayerIds.length - 1; i &gt;= 0; i -= 1) {
      const player = playersById?.[representedPlayerIds[i]];
      if (!player) continue;
      const numeric = Number(player.number);
      if (!Number.isNaN(numeric)) return numeric + 1;
    }
    return 1;
  };

  const handleAddPlayer = ({ number, name, assignment, color, position }) =&gt; {
    pushHistory();
    const nextName = String(name ?? &quot;&quot;).trim();
    const nextAssignment = String(assignment ?? &quot;&quot;).trim();
    const colorKey = color || currentPlayerColor || allPlayersDisplay.color || DEFAULT_PLAYER_COLOR;
    const hasInput = String(number ?? &quot;&quot;).trim() !== &quot;&quot; || nextName !== &quot;&quot; || nextAssignment !== &quot;&quot;;
    const nextNumber = resolveNextNumber(number);
    if (!hasInput &amp;&amp; String(nextNumber ?? &quot;&quot;).trim() === &quot;&quot;) {
      return;
    }

    const lastId = representedPlayerIds?.[representedPlayerIds.length - 1];
    const lastPlayer = lastId ? playersById?.[lastId] : null;
    const basePosition = position ?? getRandomNearbyPosition(lastPlayer || { x: 0, y: 0 });
    const newId = getNextPlayerId(playersById);

    const newPlayer = {
      id: newId,
      x: basePosition.x,
      y: basePosition.y,
      number: nextNumber,
      name: nextName,
      assignment: nextAssignment,
      color: colorKey,
    };

    setPlayersById((prev) =&gt; ({
      ...prev,
      [newId]: newPlayer,
    }));
    setRepresentedPlayerIds((prev) =&gt; [...prev, newId]);
    setSelectedPlayerIds([newId]);
    setSelectedItemIds([newId]);
    logEvent(&quot;slate&quot;, &quot;addPlayer&quot;, { id: newId, player: newPlayer });

    // Ensure the new player exists in all keyframe snapshots for consistent counts.
    setKeyframeSnapshots((prev) =&gt; {
      const next = { ...prev };
      Object.keys(next).forEach((kf) =&gt; {
        const snapshot = next[kf];
        const existingPlayers = snapshot?.playersById ?? {};
        const existingRep = snapshot?.representedPlayerIds ?? [];
        if (existingPlayers[newId]) return;
        next[kf] = {
          ...snapshot,
          playersById: {
            ...existingPlayers,
            [newId]: { ...newPlayer },
          },
          representedPlayerIds: existingRep.includes(newId)
            ? existingRep
            : [...existingRep, newId],
        };
      });
      return next;
    });
  };

  const handleCanvasAddPlayer = ({ x, y }) =&gt; {
    const colorKey = currentPlayerColor || allPlayersDisplay.color || DEFAULT_PLAYER_COLOR;
    logEvent(&quot;slate&quot;, &quot;canvasAddPlayer&quot;, { x, y, color: colorKey });
    handleAddPlayer({
      color: colorKey,
      position: { x, y },
    });
  };

  const handleEditPlayer = (id) =&gt; {
    const player = playersById?.[id];
    if (!player) return;
    logEvent(&quot;slate&quot;, &quot;editPlayerOpen&quot;, { id });
    setPlayerEditor({
      open: true,
      id,
      draft: {
        number: player.number ?? &quot;&quot;,
        name: player.name ?? &quot;&quot;,
        assignment: player.assignment ?? &quot;&quot;,
      },
    });
  };

  const handleEditDraftChange = (patch) =&gt; {
    setPlayerEditor((prev) =&gt; ({
      ...prev,
      draft: { ...prev.draft, ...patch },
    }));
  };

  const handleCloseEditPlayer = () =&gt; {
    setPlayerEditor({ open: false, id: null, draft: { number: &quot;&quot;, name: &quot;&quot;, assignment: &quot;&quot; } });
  };

  const handleSaveEditPlayer = () =&gt; {
    const editId = playerEditor.id;
    if (!editId) {
      handleCloseEditPlayer();
      return;
    }
    pushHistory();
    logEvent(&quot;slate&quot;, &quot;editPlayerSave&quot;, { id: editId, draft: playerEditor.draft });
    setPlayersById((prev) =&gt; {
      const existing = prev?.[editId];
      if (!existing) return prev;
      return {
        ...prev,
        [editId]: {
          ...existing,
          number: normalizeNumber(playerEditor.draft.number),
          name: String(playerEditor.draft.name ?? &quot;&quot;).trim(),
          assignment: String(playerEditor.draft.assignment ?? &quot;&quot;).trim(),
        },
      };
    });
    handleCloseEditPlayer();
  };

  const handleDeletePlayer = (id) =&gt; {
    pushHistory();
    logEvent(&quot;slate&quot;, &quot;deletePlayer&quot;, { id });
    setPlayersById((prev) =&gt; {
      if (!prev?.[id]) return prev;
      const next = { ...prev };
      delete next[id];
      return next;
    });
    setRepresentedPlayerIds((prev) =&gt; prev.filter((playerId) =&gt; playerId !== id));
    setSelectedPlayerIds((prev) =&gt; (prev || []).filter((playerId) =&gt; playerId !== id));
    setSelectedItemIds((prev) =&gt; (prev || []).filter((itemId) =&gt; itemId !== id));
    setKeyframeSnapshots((prev) =&gt; {
      const next = { ...prev };
      Object.keys(next).forEach((kf) =&gt; {
        const snapshot = next[kf];
        if (!snapshot?.playersById?.[id] &amp;&amp; !(snapshot?.representedPlayerIds || []).includes(id)) {
          return;
        }
        const nextPlayers = { ...(snapshot.playersById || {}) };
        delete nextPlayers[id];
        next[kf] = {
          ...snapshot,
          playersById: nextPlayers,
          representedPlayerIds: (snapshot.representedPlayerIds || []).filter(
            (playerId) =&gt; playerId !== id
          ),
        };
      });
      return next;
    });
    if (playerEditor.open &amp;&amp; playerEditor.id === id) {
      handleCloseEditPlayer();
    }
  };

  const handleDeleteSelected = () =&gt; {
    if (!selectedPlayerIds?.length) return;
    pushHistory();
    logEvent(&quot;slate&quot;, &quot;deleteSelected&quot;, { ids: selectedPlayerIds });
    setPlayersById((prev) =&gt; {
      const next = { ...prev };
      selectedPlayerIds.forEach((id) =&gt; {
        if (next[id]) delete next[id];
      });
      return next;
    });
    setRepresentedPlayerIds((prev) =&gt; prev.filter((playerId) =&gt; !selectedPlayerIds.includes(playerId)));
    setSelectedPlayerIds([]);
    setSelectedItemIds((prev) =&gt; (prev || []).filter((itemId) =&gt; !selectedPlayerIds.includes(itemId)));
    setKeyframeSnapshots((prev) =&gt; {
      const next = { ...prev };
      Object.keys(next).forEach((kf) =&gt; {
        const snapshot = next[kf];
        if (!snapshot) return;
        let changed = false;
        const nextPlayers = { ...(snapshot.playersById || {}) };
        selectedPlayerIds.forEach((id) =&gt; {
          if (nextPlayers[id]) {
            delete nextPlayers[id];
            changed = true;
          }
        });
        const nextRepresented = (snapshot.representedPlayerIds || []).filter((playerId) =&gt; {
          const shouldKeep = !selectedPlayerIds.includes(playerId);
          if (!shouldKeep) changed = true;
          return shouldKeep;
        });
        if (!changed) return;
        next[kf] = {
          ...snapshot,
          playersById: nextPlayers,
          representedPlayerIds: nextRepresented,
        };
      });
      return next;
    });
    if (playerEditor.open &amp;&amp; selectedPlayerIds.includes(playerEditor.id)) {
      handleCloseEditPlayer();
    }
  };

  const handleSelectPlayer = (id, { toggle = true } = {}) =&gt; {
    handleSelectItem(id, &quot;player&quot;, { toggle });
  };

  const handleSelectItem = (id, type, { toggle = true } = {}) =&gt; {
    if (!id) return;
    setSelectedItemIds((prev) =&gt; {
      const next = prev ? [...prev] : [];
      const index = next.indexOf(id);
      if (toggle) {
        if (index &gt;= 0) {
          next.splice(index, 1);
          return next;
        }
        next.push(id);
        return next;
      }
      if (index &gt;= 0 &amp;&amp; next.length === 1) return next;
      return [id];
    });
    if (type === &quot;player&quot;) {
      setSelectedPlayerIds((prev) =&gt; {
        const next = prev ? [...prev] : [];
        const index = next.indexOf(id);
        if (toggle) {
          if (index &gt;= 0) {
            next.splice(index, 1);
            return next;
          }
          next.push(id);
          return next;
        }
        if (index &gt;= 0 &amp;&amp; next.length === 1) return next;
        return [id];
      });
    }
  };

  const handleItemDragStart = (id) =&gt; {
    pushHistory();
    isItemDraggingRef.current = true;
    logEvent(&quot;slate&quot;, &quot;dragStart&quot;, { id });
  };

  const handleItemDragEnd = (id) =&gt; {
    isItemDraggingRef.current = false;
    logEvent(&quot;slate&quot;, &quot;dragEnd&quot;, { id });
    const targetKeyframe = findEditTargetKeyframe(timePercent, latestKeyframesRef.current);
    if (targetKeyframe !== null &amp;&amp; targetKeyframe !== undefined) {
      setKeyframeSnapshots((prev) =&gt; ({
        ...prev,
        [targetKeyframe]: snapshotSlateState(),
      }));
    }
  };

  const items = [
    ...Object.values(playersById).map((p) =&gt; ({
      id: p.id,
      type: &quot;player&quot;,
      x: p.x,
      y: p.y,
      number: p.number,
      name: p.name,
      assignment: p.assignment,
      color: p.color || allPlayersDisplay.color,
    })),
    { id: ball.id, type: &quot;ball&quot;, x: ball.x, y: ball.y },
  ];
  const selectedPlayers = (selectedPlayerIds || [])
    .map((id) =&gt; playersById?.[id])
    .filter(Boolean);

  const handleItemChange = (id, next, meta) =&gt; {
    markKeyframeSnapshotPending();
    if (meta?.delta) {
      logEvent(&quot;slate&quot;, &quot;itemMove&quot;, { id, delta: meta.delta });
    }
    if (playersById[id]) {
      if (meta?.delta &amp;&amp; selectedItemIds?.includes(id) &amp;&amp; selectedItemIds.length &gt; 1) {
        const { x: dx = 0, y: dy = 0 } = meta.delta || {};
        setPlayersById((prev) =&gt; {
          const updated = { ...prev };
          selectedItemIds.forEach((itemId) =&gt; {
            const existing = updated[itemId];
            if (!existing) return;
            updated[itemId] = {
              ...existing,
              x: (existing.x ?? 0) + dx,
              y: (existing.y ?? 0) + dy,
            };
          });
          return updated;
        });
        if (selectedItemIds.includes(ball.id)) {
          setBall((prev) =&gt; ({ ...prev, x: (prev.x ?? 0) + dx, y: (prev.y ?? 0) + dy }));
        }
        return;
      }
      setPlayersById((prev) =&gt; ({ ...prev, [id]: { ...prev[id], ...next } }));
      return;
    }
    if (id === ball.id) {
      if (meta?.delta &amp;&amp; selectedItemIds?.includes(id) &amp;&amp; selectedItemIds.length &gt; 1) {
        const { x: dx = 0, y: dy = 0 } = meta.delta || {};
        setPlayersById((prev) =&gt; {
          const updated = { ...prev };
          selectedItemIds.forEach((itemId) =&gt; {
            const existing = updated[itemId];
            if (!existing) return;
            updated[itemId] = {
              ...existing,
              x: (existing.x ?? 0) + dx,
              y: (existing.y ?? 0) + dy,
            };
          });
          return updated;
        });
        setBall((prev) =&gt; ({ ...prev, x: (prev.x ?? 0) + dx, y: (prev.y ?? 0) + dy }));
        return;
      }
      setBall((prev) =&gt; ({ ...prev, ...next }));
    }
  };

  // ControlPill state tracking
  const [timePercent, setTimePercent] = useState(0);
  const [keyframes, setKeyframes] = useState([]);
  const [speedMultiplier, setSpeedMultiplier] = useState(50);
  const [isPlaying, setIsPlaying] = useState(false);
  const [selectedKeyframe, setSelectedKeyframe] = useState(null);
  const [autoplayEnabled, setAutoplayEnabled] = useState(true);
  const [keyframeSignal, setKeyframeSignal] = useState(0);
  const [keyframeSnapshots, setKeyframeSnapshots] = useState(() =&gt; ({}));
  const playRafId = useRef(null);
  const playLastTsRef = useRef(null);
  const isPlayingRef = useRef(false);
  const prevKeyframesRef = useRef([]);
  const latestKeyframesRef = useRef([]);
  const latestKeyframeSnapshotsRef = useRef({});
  const pendingKeyframeSnapshotsRef = useRef(new Set());
  const lastAppliedKeyframeRef = useRef(null);

  const snapshotSlateState = () =&gt; ({
    playersById: Object.fromEntries(
      Object.entries(playersById || {}).map(([id, player]) =&gt; [id, { ...player }])
    ),
    representedPlayerIds: [...(representedPlayerIds || [])],
    ball: { ...(ball || INITIAL_BALL) },
  });

  const findNearestKeyframeAtTime = (timeValue, frames) =&gt; {
    let nearest = null;
    let nearestDistance = Infinity;
    (frames || []).forEach((kf) =&gt; {
      const distance = Math.abs(kf - timeValue);
      if (distance &lt; KEYFRAME_TOLERANCE &amp;&amp; distance &lt; nearestDistance) {
        nearest = kf;
        nearestDistance = distance;
      }
    });
    return nearest;
  };

  const findEditTargetKeyframe = (timeValue, frames) =&gt; {
    const sorted = [...(frames || [])].sort((a, b) =&gt; a - b);
    if (sorted.length === 0) return null;
    const nearest = findNearestKeyframeAtTime(timeValue, sorted);
    if (nearest !== null &amp;&amp; nearest !== undefined) return nearest;
    if (sorted.length === 1) return sorted[0];
    if (timeValue &gt;= sorted[sorted.length - 1]) return sorted[sorted.length - 1];
    if (timeValue &lt;= sorted[0]) return sorted[0];
    return null;
  };

  const markKeyframeSnapshotPending = () =&gt; {
    const keyframeAtTime = findEditTargetKeyframe(timePercent, keyframes);
    if (!keyframeAtTime) return;
    pendingKeyframeUpdateRef.current = true;
    pendingKeyframeTimeRef.current = keyframeAtTime;
  };

  const handleTimePercentChange = (next) =&gt; {
    const clamped = clamp(Number(next) || 0, 0, 100);
    setTimePercent((prev) =&gt; (Object.is(prev, clamped) ? prev : clamped));
    if (isPlayingRef.current) {
      setIsPlaying(false);
    }
  };

  useEffect(() =&gt; {
    isPlayingRef.current = isPlaying;
  }, [isPlaying]);

  useEffect(() =&gt; {
    if (!isPlaying) {
      if (playRafId.current) cancelAnimationFrame(playRafId.current);
      playRafId.current = null;
      playLastTsRef.current = null;
      return;
    }

    const tick = (ts) =&gt; {
      if (!isPlayingRef.current) return;
      if (playLastTsRef.current == null) playLastTsRef.current = ts;
      const dt = (ts - playLastTsRef.current) / 1000;
      playLastTsRef.current = ts;

      const speed = (0.25 + (speedMultiplier / 100) * 3.75) * 3;
      const delta = (dt / LOOP_SECONDS) * 100 * speed;
      let shouldStop = false;

      setTimePercent((prev) =&gt; {
        let next = prev + delta;
        if (next &gt;= 100) {
          if (autoplayEnabled) {
            next = next % 100;
          } else {
            next = 100;
            shouldStop = true;
          }
        }
        if (next &lt;= 0) next = 0;
        return next;
      });

      if (shouldStop) {
        isPlayingRef.current = false;
        setIsPlaying(false);
        return;
      }

      playRafId.current = requestAnimationFrame(tick);
    };

    playRafId.current = requestAnimationFrame(tick);

    return () =&gt; {
      if (playRafId.current) cancelAnimationFrame(playRafId.current);
      playRafId.current = null;
      playLastTsRef.current = null;
    };
  }, [isPlaying, speedMultiplier, autoplayEnabled]);

  const requestAddKeyframe = useCallback(() =&gt; {
    setKeyframeSignal((prev) =&gt; prev + 1);
  }, []);

  const handleKeyframeAddAttempt = useCallback(
    (payload) =&gt; {
      logEvent(&quot;controlPill&quot;, &quot;keyframeAddAttempt&quot;, payload);
      if (payload?.added) return;
      if (payload?.reason === &quot;max&quot;) {
        showMessage(
          &quot;Keyframe limit reached&quot;,
          `Max ${payload.maxKeyframes ?? 30} keyframes`,
          &quot;error&quot;
        );
        return;
      }
      if (payload?.reason === &quot;too-close&quot;) {
        showMessage(
          &quot;Keyframe already nearby&quot;,
          &quot;Selected the existing keyframe instead&quot;,
          &quot;standard&quot;,
          2000
        );
      }
    },
    [logEvent, showMessage]
  );

  // Log state every 10 seconds
  useEffect(() =&gt; {
    const logState = () =&gt; {
      if (!logControlPillState) return;
      const state = {
        timePercent: timePercent.toFixed(2),
        keyframes: keyframes,
        speedMultiplier: speedMultiplier,
        isPlaying: isPlaying,
        selectedKeyframe: selectedKeyframe,
        autoplayEnabled: autoplayEnabled,
        timestamp: new Date().toLocaleTimeString(),
      };

      console.log(&quot;=== ControlPill State (every 10s) ===&quot;);
      console.log(&quot;Time Percent:&quot;, state.timePercent + &quot;%&quot;);
      console.log(&quot;Keyframes:&quot;, state.keyframes.length &gt; 0 ? state.keyframes : &quot;[]&quot;);
      console.log(&quot;Speed Multiplier:&quot;, state.speedMultiplier);
      console.log(&quot;Is Playing:&quot;, state.isPlaying);
      console.log(&quot;Selected Keyframe:&quot;, state.selectedKeyframe ?? &quot;null&quot;);
      console.log(&quot;Autoplay Enabled:&quot;, state.autoplayEnabled);
      console.log(&quot;Timestamp:&quot;, state.timestamp);
      console.log(&quot;=====================================&quot;);
    };

    // Log immediately on mount
    logState();

    // Set up interval to log every 10 seconds
    const interval = setInterval(logState, 10000);

    return () =&gt; {
      clearInterval(interval);
    };
  }, [timePercent, keyframes, speedMultiplier, isPlaying, selectedKeyframe, autoplayEnabled]);

  useEffect(() =&gt; {
    if (!logging?.controlPill) return;
    logEvent(&quot;controlPill&quot;, &quot;keyframesChange&quot;, { keyframes });
  }, [keyframes, logging?.controlPill]);

  useEffect(() =&gt; {
    const handleKeyDown = (e) =&gt; {
      if (e.key !== &quot;Escape&quot;) return;
      setSelectedPlayerIds([]);
      setSelectedItemIds([]);
      setSelectedKeyframe(null);
      setCanvasTool(&quot;select&quot;);
    };
    window.addEventListener(&quot;keydown&quot;, handleKeyDown);
    return () =&gt; window.removeEventListener(&quot;keydown&quot;, handleKeyDown);
  }, []);

  useEffect(() =&gt; {
    latestKeyframesRef.current = keyframes;
    const prevKeyframes = prevKeyframesRef.current || [];
    const added = keyframes.filter((kf) =&gt; !prevKeyframes.includes(kf));
    const removed = prevKeyframes.filter((kf) =&gt; !keyframes.includes(kf));

    if (removed.length) {
      setKeyframeSnapshots((prev) =&gt; {
        const next = { ...prev };
        removed.forEach((kf) =&gt; {
          delete next[kf];
        });
        return next;
      });
    }

    if (added.length) {
      added.forEach((kf) =&gt; pendingKeyframeSnapshotsRef.current.add(kf));
    }

    prevKeyframesRef.current = keyframes;
  }, [keyframes]);

  useEffect(() =&gt; {
    latestKeyframeSnapshotsRef.current = keyframeSnapshots;
  }, [keyframeSnapshots]);

  useEffect(() =&gt; {
    if (pendingKeyframeSnapshotsRef.current.size === 0) return;
    const pending = Array.from(pendingKeyframeSnapshotsRef.current);
    pendingKeyframeSnapshotsRef.current.clear();
    setKeyframeSnapshots((prev) =&gt; {
      const next = { ...prev };
      pending.forEach((kf) =&gt; {
        next[kf] = snapshotSlateState();
      });
      return next;
    });
  }, [playersById, representedPlayerIds, ball, keyframes]);

  useEffect(() =&gt; {
    const frames = latestKeyframesRef.current;
    if (!frames || frames.length === 0) return;
    const nearest = findNearestKeyframeAtTime(timePercent, frames);
    const shouldSeedSingle = frames.length === 1;
    const target =
      nearest !== null &amp;&amp; nearest !== undefined
        ? nearest
        : shouldSeedSingle
          ? frames[0]
          : null;
    if (target === null || target === undefined) return;
    if (latestKeyframeSnapshotsRef.current[target]) return;
    setKeyframeSnapshots((prev) =&gt; ({
      ...prev,
      [target]: snapshotSlateState(),
    }));
  }, [timePercent]);

  useEffect(() =&gt; {
    if (!pendingKeyframeUpdateRef.current) return;
    const keyframeAtTime = pendingKeyframeTimeRef.current;
    if (keyframeAtTime === null || keyframeAtTime === undefined) return;
    pendingKeyframeUpdateRef.current = false;
    pendingKeyframeTimeRef.current = null;
    setKeyframeSnapshots((prev) =&gt; ({
      ...prev,
      [keyframeAtTime]: snapshotSlateState(),
    }));
  }, [playersById, representedPlayerIds, ball]);

  const lerp = (from, to, t) =&gt; from + (to - from) * t;

  const buildInterpolatedSlate = (timeValue, frames, snapshots) =&gt; {
    const availableKeyframes = (frames || [])
      .filter((kf) =&gt; snapshots[kf])
      .sort((a, b) =&gt; a - b);

    if (availableKeyframes.length === 0) return null;

    if (timeValue &lt;= availableKeyframes[0]) {
      return snapshots[availableKeyframes[0]];
    }
    if (timeValue &gt;= availableKeyframes[availableKeyframes.length - 1]) {
      return snapshots[availableKeyframes[availableKeyframes.length - 1]];
    }

    let prevKeyframe = availableKeyframes[0];
    let nextKeyframe = availableKeyframes[availableKeyframes.length - 1];
    for (let i = 0; i &lt; availableKeyframes.length - 1; i += 1) {
      const current = availableKeyframes[i];
      const next = availableKeyframes[i + 1];
      if (timeValue &gt;= current &amp;&amp; timeValue &lt;= next) {
        prevKeyframe = current;
        nextKeyframe = next;
        break;
      }
    }

    if (prevKeyframe === nextKeyframe) {
      return snapshots[prevKeyframe];
    }

    const prevSnapshot = snapshots[prevKeyframe];
    const nextSnapshot = snapshots[nextKeyframe];
    if (!prevSnapshot || !nextSnapshot) return null;

    const t = (timeValue - prevKeyframe) / (nextKeyframe - prevKeyframe);
    const prevPlayers = prevSnapshot.playersById || {};
    const nextPlayers = nextSnapshot.playersById || {};
    const allPlayerIds = new Set([
      ...Object.keys(prevPlayers),
      ...Object.keys(nextPlayers),
    ]);

    const interpolatedPlayers = {};
    allPlayerIds.forEach((id) =&gt; {
      const prevPlayer = prevPlayers[id];
      const nextPlayer = nextPlayers[id];
      if (prevPlayer &amp;&amp; nextPlayer) {
        interpolatedPlayers[id] = {
          ...prevPlayer,
          ...nextPlayer,
          x: lerp(prevPlayer.x ?? 0, nextPlayer.x ?? 0, t),
          y: lerp(prevPlayer.y ?? 0, nextPlayer.y ?? 0, t),
        };
        return;
      }
      interpolatedPlayers[id] = { ...(prevPlayer || nextPlayer) };
    });

    const prevBall = prevSnapshot.ball || INITIAL_BALL;
    const nextBall = nextSnapshot.ball || INITIAL_BALL;
    const interpolatedBall = {
      ...prevBall,
      ...nextBall,
      x: lerp(prevBall.x ?? 0, nextBall.x ?? 0, t),
      y: lerp(prevBall.y ?? 0, nextBall.y ?? 0, t),
    };

    const represented =
      t &lt;= 0.5
        ? [...(prevSnapshot.representedPlayerIds || [])]
        : [...(nextSnapshot.representedPlayerIds || [])];

    return {
      playersById: interpolatedPlayers,
      representedPlayerIds: represented,
      ball: interpolatedBall,
    };
  };

  useEffect(() =&gt; {
    if (isItemDraggingRef.current) return;
    const interpolatedSlate = buildInterpolatedSlate(
      timePercent,
      latestKeyframesRef.current,
      latestKeyframeSnapshotsRef.current
    );
    if (!interpolatedSlate) return;
    applySlate(interpolatedSlate);
  }, [timePercent]);

  return (
    &lt;&gt;

      &lt;div className=&quot;w-full h-screen bg-BrandBlack flex flex-row justify-between relative overflow-hidden&quot;&gt;


        {/* Message popup */}
        &lt;MessagePopup
          message={messagePopup.message}
          subtitle={messagePopup.subtitle}
          visible={messagePopup.visible}
          type={messagePopup.type}
          onClose={hideMessage}
        /&gt;

        {/* Test button for MessagePopup */}
        &lt;button
          onClick={() =&gt; {
            const types = [&quot;success&quot;, &quot;error&quot;, &quot;standard&quot;];
            const messages = [
              { message: &quot;Success!&quot;, subtitle: &quot;Operation completed successfully&quot;, type: &quot;success&quot; },
              { message: &quot;Error&quot;, subtitle: &quot;Something went wrong&quot;, type: &quot;error&quot; },
              { message: &quot;Info&quot;, subtitle: &quot;This is a standard message&quot;, type: &quot;standard&quot; },
            ];
            const random = Math.floor(Math.random() * messages.length);
            const selected = messages[random];
            showMessage(selected.message, selected.subtitle, selected.type);
          }}
          className=&quot;absolute hidden top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-50 bg-BrandOrange text-BrandBlack px-4 py-2 rounded-md font-DmSans font-semibold hover:bg-BrandOrange/90 transition-colors&quot;
        &gt;
          Test Message Popup
        &lt;/button&gt;
      
        &lt;WideSidebar
          onToolChange={handleToolChange}
          onUndo={onUndo}
          onRedo={onRedo}
          onReset={onReset}
          onAddPlayer={handleAddPlayer}
          onPlayerColorChange={handlePlayerColorChange}
          onDeleteSelected={handleDeleteSelected}
        /&gt;
        &lt;div className=&quot;flex-1 flex&quot;&gt;
          &lt;CanvasRoot
            tool={canvasTool}
            camera={camera}
            setCamera={setCamera}
            items={items}
            fieldRotation={fieldRotation}
            onPanStart={pushFieldHistory}
            onItemChange={handleItemChange}
            onItemDragStart={handleItemDragStart}
            onItemDragEnd={handleItemDragEnd}
            onCanvasAddPlayer={handleCanvasAddPlayer}
            selectedPlayerIds={selectedPlayerIds}
            selectedItemIds={selectedItemIds}
            onSelectItem={handleSelectItem}
            onMarqueeSelect={(ids) =&gt; {
              const nextIds = (ids || []).filter((id) =&gt; playersById?.[id] || id === ball.id);
              setSelectedItemIds(nextIds);
              setSelectedPlayerIds(nextIds.filter((id) =&gt; playersById?.[id]));
            }}
            allPlayersDisplay={allPlayersDisplay}
            advancedSettings={advancedSettings}
          /&gt;
        &lt;/div&gt;
        &lt;ControlPill
          onTimePercentChange={handleTimePercentChange}
          onKeyframesChange={setKeyframes}
          onSpeedChange={setSpeedMultiplier}
          onPlayStateChange={setIsPlaying}
          onSelectedKeyframeChange={setSelectedKeyframe}
          onAutoplayChange={setAutoplayEnabled}
          externalTimePercent={timePercent}
          externalIsPlaying={isPlaying}
          externalSpeed={speedMultiplier}
          externalSelectedKeyframe={selectedKeyframe}
          externalAutoplayEnabled={autoplayEnabled}
          addKeyframeSignal={keyframeSignal}
          onRequestAddKeyframe={requestAddKeyframe}
          onKeyframeAddAttempt={handleKeyframeAddAttempt}
        /&gt;

        &lt;RightPanel
          playName={playName}
          onPlayNameChange={setPlayName}
          zoomPercent={zoomPercent}
          onZoomIn={zoomIn}
          onZoomOut={zoomOut}
          onZoomPercentChange={setZoomPercent}
          onRotateLeft={onRotateLeft}
          onRotateCenter={onRotateCenter}
          onRotateRight={onRotateRight}
          onFieldUndo={onFieldUndo}
          onFieldRedo={onFieldRedo}
          onReset={onReset}
          playersById={playersById}
          representedPlayerIds={representedPlayerIds}
          selectedPlayerIds={selectedPlayerIds}
          selectedPlayers={selectedPlayers}
          onSelectPlayer={handleSelectPlayer}
          onEditPlayer={handleEditPlayer}
          onDeletePlayer={handleDeletePlayer}
          allPlayersDisplay={allPlayersDisplay}
          onAllPlayersDisplayChange={setAllPlayersDisplay}
          onSelectedPlayersColorChange={handleSelectedPlayersColorChange}
          advancedSettingsOpen={showAdvancedSettings}
          onOpenAdvancedSettings={() =&gt; setShowAdvancedSettings(true)}
          onSaveToPlaybook={onSaveToPlaybook}
          onDownload={onDownload}
        /&gt;
        &lt;PlayerEditPanel
          isOpen={playerEditor.open}
          player={playerEditor.id ? playersById[playerEditor.id] : null}
          draft={playerEditor.draft}
          onChange={handleEditDraftChange}
          onClose={handleCloseEditPlayer}
          onSave={handleSaveEditPlayer}
        /&gt;
        {showAdvancedSettings &amp;&amp; (
          &lt;AdvancedSettings
            value={advancedSettings}
            onChange={setAdvancedSettings}
            onReset={() =&gt; setAdvancedSettings(DEFAULT_ADVANCED_SETTINGS)}
            onClose={() =&gt; setShowAdvancedSettings(false)}
          /&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  );
}
export default App;</file><file path="src/index.css">@import &quot;tailwindcss&quot;;

@theme {
    --color-BrandBlack: #121212;
    --color-BrandBlack2: #2a2e34;
    --color-BrandGray: #9AA0A6;
    --color-BrandGray2: #4b5157;
    --color-BrandWhite: #f5f7fa;
    --color-BrandOrange: #FF7A18;
    --color-BrandOrange2: #75492a;
    --color-BrandGreen: #4FA85D;
}

@font-face {
    font-family: &apos;Manrope&apos;;
    src: url(&apos;/src/assets/fonts/Manrope-Regular.ttf&apos;) format(&apos;truetype&apos;);

}

@font-face {
    font-family: &apos;DmSans&apos;;
    src: url(&apos;/src/assets/fonts/DmSans-Regular.ttf&apos;) format(&apos;truetype&apos;);
}

@theme {
    --font-Manrope: Manrope, sans-serif;
    --font-DmSans: DmSans, sans-serif;
}

/* Custom Scrollbar Styling */
/* Webkit browsers (Chrome, Safari, Edge) */
::-webkit-scrollbar {
    width: 1px;
    height: 1px;
}

::-webkit-scrollbar-track {
    background: rgba(18, 18, 18, 0.1);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #FF7A18 0%, #ff8d3d 100%);
    border-radius: 10px;
    border: 0;
    background-clip: border-box;
    transition: background 0.2s ease;
}

/* Chrome, Safari, Edge */
input[type=&quot;number&quot;]::-webkit-inner-spin-button,
input[type=&quot;number&quot;]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* Firefox */
input[type=&quot;number&quot;] {
  -moz-appearance: textfield;
}


::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #ff8d3d 0%, #FF7A18 100%);
    background-clip: padding-box;
}

::-webkit-scrollbar-thumb:active {
    background: #FF7A18;
    background-clip: padding-box;
}

::-webkit-scrollbar-corner {
    background: rgba(18, 18, 18, 0.1);
}

/* Firefox */
* {
    scrollbar-width: thin;
    scrollbar-color: #FF7A18 rgba(18, 18, 18, 0.1);
}

/* Utility: hide scrollbars but keep scroll behavior */
.hide-scroll {
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge Legacy */
}

.hide-scroll::-webkit-scrollbar {
    width: 0;
    height: 0;
    display: none; /* Chrome/Safari/Edge */
}</file><file path="src/main.jsx">import { StrictMode } from &apos;react&apos;
import { createRoot } from &apos;react-dom/client&apos;
import &apos;./index.css&apos;
import App from &apos;./App.jsx&apos;

createRoot(document.getElementById(&apos;root&apos;)).render(
  &lt;StrictMode&gt;
    &lt;App /&gt;
  &lt;/StrictMode&gt;,
)</file><file path=".gitignore"># Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?</file><file path="CONTROL_PILL_STATE_ANALYSIS.md"># ControlPill State Analysis

## Critical State to Expose (Required for External Control)

### 1. **timePercent** (0-100)
- **Type**: `number` (0-100)
- **Purpose**: Current playback position in the timeline
- **Critical**: YES - This is the primary state that other components need to know
- **Usage**: Other components can react to timeline position changes (e.g., update canvas, animate players)

### 2. **keyframes** (Array of positions)
- **Type**: `number[]` (array of 0-100 values, sorted)
- **Purpose**: All keyframe positions on the timeline
- **Critical**: YES - Essential for understanding animation key points
- **Usage**: Other components can use keyframes to:
  - Jump to specific moments
  - Show visual indicators
  - Export/save animation data
  - Sync player positions at keyframes

### 3. **speedMultiplier** (0-100)
- **Type**: `number` (0-100)
- **Purpose**: Controls playback speed (slider thumb position)
- **Critical**: YES - Controls animation speed
- **Calculated Speed**: `(0.25 + (speedMultiplier / 100) * 3.75) * 3`
  - 0 = 0.75x speed
  - 50 = ~2.25x speed (default)
  - 100 = 4.5x speed
- **Usage**: Other components can adjust their animation speed accordingly

### 4. **isPlaying** (Playback State)
- **Type**: `boolean`
- **Purpose**: Whether animation is currently playing
- **Critical**: YES - Other components need to know if animation is active
- **Usage**: 
  - Pause/resume animations in other components
  - Show/hide UI elements based on playback state
  - Trigger updates only when playing

## Important State to Expose (Useful for Context)

### 5. **selectedKeyframe** (Currently Selected)
- **Type**: `number | null` (timePercent value or null)
- **Purpose**: Which keyframe is currently selected
- **Critical**: NO - But useful for context
- **Usage**: 
  - Highlight selected keyframe in other views
  - Show details about selected keyframe
  - Enable keyframe-specific operations

### 6. **autoplayEnabled** (Loop Behavior)
- **Type**: `boolean`
- **Purpose**: Whether animation loops or stops at 100%
- **Critical**: NO - But useful for controlling behavior
- **Usage**: 
  - Other components can adjust their loop behavior
  - Show different UI when autoplay is disabled

## Optional State (Internal Only - May Not Need Exposure)

### 7. **isDragging** (User Interaction)
- **Type**: `boolean`
- **Purpose**: Whether user is currently dragging the timeline
- **Critical**: NO - Internal UI state
- **Note**: Could be useful if other components need to pause updates during drag

### 8. **isDropdownOpen** (UI State)
- **Type**: `boolean`
- **Purpose**: Whether dropdown menu is open
- **Critical**: NO - Pure UI state, no external impact

### 9. **actionHistory / redoHistory** (Undo/Redo)
- **Type**: `Array&lt;Action&gt;`
- **Purpose**: Internal undo/redo state
- **Critical**: NO - Internal to ControlPill

## Recommended Props Interface

```javascript
// Props to receive from parent (for external control)
interface ControlPillProps {
  // Callbacks for state changes
  onTimePercentChange?: (timePercent: number) =&gt; void;
  onKeyframesChange?: (keyframes: number[]) =&gt; void;
  onSpeedChange?: (speedMultiplier: number) =&gt; void;
  onPlayStateChange?: (isPlaying: boolean) =&gt; void;
  onSelectedKeyframeChange?: (keyframe: number | null) =&gt; void;
  onAutoplayChange?: (enabled: boolean) =&gt; void;
  
  // Optional: External control
  externalTimePercent?: number; // Allow parent to control time
  externalIsPlaying?: boolean;  // Allow parent to control play state
  externalSpeed?: number;       // Allow parent to control speed
}

// State to expose via callbacks
interface ControlPillState {
  timePercent: number;           // 0-100
  keyframes: number[];           // Array of 0-100 values
  speedMultiplier: number;       // 0-100
  isPlaying: boolean;
  selectedKeyframe: number | null;
  autoplayEnabled: boolean;
}
```

## Suggested Component Breakdown Structure

```
components/
  subcomponents/
    controlPill/
      TimePill.jsx          // The draggable timeline pill
      SpeedSlider.jsx       // Speed control slider
      PlaybackControls.jsx  // Play/pause/skip buttons
      KeyframeManager.jsx   // Add/delete keyframe logic
      KeyframeDisplay.jsx   // Keyframe icons on timeline
      DropdownMenu.jsx      // Settings dropdown (trash, undo, redo, autoplay)
      ControlPill.jsx       // Main component (orchestrates subcomponents)
```

## Key Functions to Expose

1. **Jump to time**: `jumpToTime(timePercent: number)` - Programmatically set time
2. **Jump to keyframe**: `jumpToKeyframe(keyframeIndex: number)` - Jump to specific keyframe
3. **Add keyframe at current time**: `addKeyframeAtCurrent()` - External trigger
4. **Get calculated speed**: `getCalculatedSpeed()` - Returns actual speed multiplier
5. **Get duration**: `getDuration()` - Returns actual duration in seconds

## Notes

- The `LOOP_SECONDS = 30` constant defines the base duration
- Speed calculation: `speed = (0.25 + (speedMultiplier / 100) * 3.75) * 3`
- Actual duration: `LOOP_SECONDS / speed`
- Visual position mapping: 3%-97% visual range maps to 0-100% timePercent</file><file path="dependencies">npm uninstall konva</file><file path="DOWNLOAD.md"># Download Export (Play JSON)

This project’s **Download** button exports a single JSON file that fully describes the current play so it can be re-imported later. The export is created client‑side (no server) and includes only **play state**, not transient UI state.

## Filename

The filename is derived from the current play name shown in the Right Panel:

- Lowercased
- Spaces replaced with `-`
- Illegal filename characters removed
- If empty, falls back to `play`

Example: `My Play 1` → `my-play-1.json`

## Schema Overview

All exports use a versioned schema:

```json
{
  &quot;schemaVersion&quot;: &quot;play-export-v1&quot;,
  &quot;exportedAt&quot;: &quot;2026-02-05T12:34:56.789Z&quot;,
  &quot;play&quot;: {
    &quot;name&quot;: &quot;My Play&quot;,
    &quot;id&quot;: null,
    &quot;settings&quot;: { ... },
    &quot;canvas&quot;: { ... },
    &quot;entities&quot;: { ... },
    &quot;timeline&quot;: { ... },
    &quot;meta&quot;: { &quot;appVersion&quot;: null }
  }
}
```

## Where Each Section Comes From

- `schemaVersion`, `exportedAt`
  - Built in `src/utils/exportPlay.js` (`buildPlayExportV1`)

- `play.name`
  - Right Panel play name from `src/App.jsx` state: `playName`

- `play.settings`
  - `advancedSettings` from `src/App.jsx` (pitch color, markings, player size, etc.)
  - `allPlayersDisplay` from `src/App.jsx` (global player size, number/name visibility, color)
  - `currentPlayerColor` from `src/App.jsx`

- `play.canvas`
  - `camera` and `fieldRotation` from `src/App.jsx`
  - `coordinateSystem` is documented in `README.md` and enforced in `src/canvas/ItemsLayer.jsx` and `src/canvas/FieldLayer.jsx`

- `play.entities`
  - `playersById`, `representedPlayerIds`, and `ball` from `src/App.jsx`
  - These are the full properties required to render the items on the canvas

- `play.timeline`
  - `keyframes` and `keyframeSnapshots` from ControlPill state in `src/App.jsx`
  - `playback` includes `loopSeconds`, `keyframeTolerance`, `speedMultiplier`, and `autoplayEnabled`

- `play.meta.appVersion`
  - `import.meta.env.VITE_APP_VERSION` if provided at build time, otherwise `null`

## What Is Intentionally Excluded

UI-only or transient state is not exported, including:

- Current selection (`selectedPlayerIds`, `selectedItemIds`)
- Hover state
- Dragging state
- In-progress edits or tooltips
- Current playhead position (`timePercent`) and `isPlaying` flag

These can be re-derived or set during import.

## Example Structure (Short)

```json
{
  &quot;schemaVersion&quot;: &quot;play-export-v1&quot;,
  &quot;exportedAt&quot;: &quot;2026-02-05T12:34:56.789Z&quot;,
  &quot;play&quot;: {
    &quot;name&quot;: &quot;my-play&quot;,
    &quot;settings&quot;: {
      &quot;advancedSettings&quot;: { &quot;pitch&quot;: { &quot;showMarkings&quot;: true } },
      &quot;allPlayersDisplay&quot;: { &quot;sizePercent&quot;: 100 }
    },
    &quot;canvas&quot;: {
      &quot;camera&quot;: { &quot;x&quot;: 0, &quot;y&quot;: 0, &quot;zoom&quot;: 1 },
      &quot;fieldRotation&quot;: 0
    },
    &quot;entities&quot;: {
      &quot;playersById&quot;: { &quot;player-1&quot;: { &quot;id&quot;: &quot;player-1&quot;, &quot;x&quot;: 0, &quot;y&quot;: 0 } },
      &quot;representedPlayerIds&quot;: [&quot;player-1&quot;],
      &quot;ball&quot;: { &quot;id&quot;: &quot;ball-1&quot;, &quot;x&quot;: 40, &quot;y&quot;: 0 }
    },
    &quot;timeline&quot;: {
      &quot;keyframes&quot;: [0, 50, 100],
      &quot;keyframeSnapshots&quot;: { &quot;0&quot;: { &quot;playersById&quot;: { } } }
    }
  }
}
```

## Implementation Notes

- Export building: `src/utils/exportPlay.js`
- Download wiring: `src/App.jsx` → `onDownload` → `downloadPlayExport(...)`
- Right Panel button: `src/components/rightPanel/ExportActions.jsx`</file><file path="eslint.config.js">import js from &apos;@eslint/js&apos;
import globals from &apos;globals&apos;
import reactHooks from &apos;eslint-plugin-react-hooks&apos;
import reactRefresh from &apos;eslint-plugin-react-refresh&apos;
import { defineConfig, globalIgnores } from &apos;eslint/config&apos;

export default defineConfig([
  globalIgnores([&apos;dist&apos;]),
  {
    files: [&apos;**/*.{js,jsx}&apos;],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: &apos;latest&apos;,
        ecmaFeatures: { jsx: true },
        sourceType: &apos;module&apos;,
      },
    },
    rules: {
      &apos;no-unused-vars&apos;: [&apos;error&apos;, { varsIgnorePattern: &apos;^[A-Z_]&apos; }],
    },
  },
])</file><file path="index.html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;coachable&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;/src/main.jsx&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</file><file path="KEYFRAME_DIAGNOSIS.md"># Keyframe system diagnosis

## Summary

Keyframe add failures and “struggling with many players” are caused by: **(1) hard cap of 10 keyframes**, **(2) 4% minimum distance between keyframes** making adds feel random when near existing keyframes, **(3) automatic keyframe-add on every slate-changing action** (e.g. drag start, undo, edit, delete), and **(4) no `externalTimePercent`** so ControlPill can use a stale playhead when reacting to `addKeyframeSignal`. With many players you do more edits/drags, so you hit the cap and “too close” more often.

---

## 1. Hard limit of 10 keyframes

**Where:** `src/components/controlPill/ControlPill.jsx` (around lines 227–236)

- `addKeyframeAtTime` returns early if `keyframes.length &gt;= 10` and calls `onKeyframeAddAttempt` with `reason: &quot;max&quot;`.
- With many players you often want more keyframes to capture different formations; the fixed cap of 10 is likely too low and is a direct cause of “can’t add keyframe”.

**Fix options:** Make the limit configurable (e.g. prop or setting), or remove/increase it (e.g. 20–30) with UI feedback when at limit.

---

## 2. 4% minimum distance between keyframes

**Where:** `src/components/controlPill/ControlPill.jsx` (around lines 239–266)

- `MIN_DISTANCE = 4` (percent). A new keyframe is rejected if any existing keyframe is within 4% (`Math.abs(kf - timePercentValue) &lt; 4`). User gets `onKeyframeAddAttempt` with `reason: &quot;too-close&quot;`.
- On a 0–100 timeline this makes it easy to hit “too close” when:
  - Playhead is near an existing keyframe (e.g. after seeking).
  - User does small successive edits; each can trigger an add at nearly the same time%.
- With many players, more drags/edits mean more add attempts at similar times, so “too close” shows up more often.

**Fix options:** Reduce `MIN_DISTANCE` (e.g. 2%), or make it configurable; or snap new keyframes to the nearest “slot” instead of rejecting.

---

## 3. Keyframe add is triggered on every slate-changing action

**Where:**  
- `src/App.jsx`: `pushHistory()` (lines 220–224) both pushes undo history and increments `keyframeSignal`: `setKeyframeSignal((prev) =&gt; prev + 1)` and `markKeyframeSnapshotPending()`.
- ControlPill: `addKeyframeSignal` effect (lines 396–402) runs when `addKeyframeSignal` changes and calls `addKeyframeAtTime(timePercent)`.

So **every** call to `pushHistory()` tries to add a keyframe at the current time. `pushHistory()` is used for:

- `handleItemDragStart` (drag start)
- `handleSaveEditPlayer`
- `handleDeletePlayer`
- `handleDeleteSelected`
- (and undo-related flow)

So: one drag start → one keyframe add attempt. Many players → many small drags → many add attempts → you quickly hit the 10-keyframe cap and/or “too close”.

**Fix options:**  
- Do **not** tie keyframe add to `pushHistory`. Only add a keyframe when the user explicitly clicks “Add Keyframe” (or equivalent). Use a separate mechanism for “update snapshot at current keyframe” (e.g. only `markKeyframeSnapshotPending()` on drag end / edit, without incrementing `keyframeSignal`).  
- Or: keep current behavior but make it “update snapshot at current time if there is already a keyframe there, else add new keyframe only if under cap and not too close,” and ensure the UI explains the 10-keyframe and 4% rules.

---

## 4. ControlPill timePercent vs App timePercent (addKeyframeSignal effect)

**Where:**  
- `src/App.jsx`: ControlPill is used **without** `externalTimePercent={timePercent}` (only `onTimePercentChange`, `addKeyframeSignal`, etc.).  
- `src/components/controlPill/ControlPill.jsx`: The effect that runs on `addKeyframeSignal` uses local `timePercent` and calls `addKeyframeAtTime(timePercent)`.

ControlPill owns its own `timePercent` and syncs *out* to App via `onTimePercentChange`. It does not receive App’s `timePercent` as `externalTimePercent`. So when App fires `addKeyframeSignal` (e.g. from `pushHistory`), the effect in ControlPill runs with whatever **ControlPill’s** `timePercent` is. In practice they’re usually the same because the user moves the playhead in ControlPill, but effect order is not guaranteed, so in theory you could add a keyframe at a slightly stale time. Less critical than (1)–(3), but worth fixing for consistency.

**Fix options:** Pass `externalTimePercent={timePercent}` from App to ControlPill so the playhead is driven by App when reacting to `addKeyframeSignal`, or ensure the add-keyframe path uses a ref updated from App’s `timePercent` so the value used for `addKeyframeAtTime` is always the same as the one used for snapshot/editing.

---

## 5. Snapshot work with many players (performance / correctness)

**Where:** `src/App.jsx`

- `snapshotSlateState()` (673–679) deep-copies `playersById`, `representedPlayerIds`, and `ball`. With many players this is a large object per keyframe.
- The effect that flushes `pendingKeyframeSnapshotsRef` (792–804) depends on `[playersById, representedPlayerIds, ball, keyframes]`. So it runs on every change to any of those. For each pending keyframe it does `next[kf] = snapshotSlateState()`. With many players this can be heavy and cause jank during drags/edits.
- When a **new** keyframe is added, the “keyframes changed” effect (764–786) adds it to `pendingKeyframeSnapshotsRef`; the flush effect then runs (because `keyframes` changed) and fills snapshots. So the new keyframe does get a snapshot. No evidence that “many players” breaks correctness of snapshots; the main issue is add being rejected by cap/distance and by how often add is triggered.

**Fix options:** If you see slowness with many players: throttle or batch snapshot updates, or avoid re-running the flush effect on every `playersById` change (e.g. run only when `keyframes` or a dedicated “snapshot version” changes), and/or use a more compact snapshot format for interpolation.

---

## Recommended next steps

1. **Decouple keyframe add from `pushHistory`**  
   Only add a keyframe when the user explicitly asks (e.g. “Add Keyframe” button or slate action that is clearly “add keyframe”). Use `markKeyframeSnapshotPending()` (and existing drag-end snapshot update) to update the snapshot at the current keyframe when the user edits/drags, without sending `addKeyframeSignal`.

2. **Raise or remove the 10-keyframe cap**  
   Make it configurable or increase it (e.g. 20–30), and show a clear message when at limit.

3. **Relax or make configurable the 4% minimum distance**  
   e.g. 2% or a prop, and/or snap to a grid to avoid “too close” rejections.

4. **Optionally pass `externalTimePercent`**  
   So that when App triggers `addKeyframeSignal`, ControlPill (or the add logic) uses the same playhead value App uses for snapshots and editing.

5. **Optional: performance**  
   If the UI is slow with many players, optimize snapshot flushing (dependencies and batching) as above.

---

## Files to change (reference)

| Area | File |
|------|------|
| Keyframe cap &amp; min distance | `src/components/controlPill/ControlPill.jsx` |
| When keyframe add is triggered | `src/App.jsx` (`pushHistory`, `setKeyframeSignal`) |
| ControlPill time sync | `src/App.jsx` (ControlPill props), `ControlPill.jsx` (effect deps / use of timePercent) |
| Snapshot flush effect | `src/App.jsx` (effect with `[playersById, representedPlayerIds, ball, keyframes]`) |</file><file path="NOTE_FOR_CHATGPT_CODEX_PROMPT.md"># Note for ChatGPT: context to add to the Codex prompt

When you generate a prompt for Codex (or any coding agent) about fixing keyframes in this project, **include the following context** so the agent has enough to work from without re-diagnosing everything.

---

## Project and stack

- **Project:** Coachable – React (Vite) app with a timeline, keyframes, and a “slate” of players + ball on a canvas.
- **Relevant areas:** `src/App.jsx` (keyframe state, snapshots, `pushHistory`, `addKeyframeSignal`), `src/components/controlPill/ControlPill.jsx` (keyframe add/delete, 10-keyframe cap, 4% min distance).

---

## What’s wrong (short version)

1. **Only 10 keyframes allowed** – hard-coded in ControlPill; with many players we need more.
2. **4% minimum distance** – new keyframe is rejected if within 4% of any existing one; with many small edits/drags this triggers “too close” often.
3. **Keyframe add is tied to every slate-changing action** – `pushHistory()` in App both pushes undo and increments `addKeyframeSignal`, so every drag start / edit / delete tries to add a keyframe. With many players we do more of these actions and hit the cap / “too close” constantly.
4. **ControlPill doesn’t receive App’s playhead** – App doesn’t pass `externalTimePercent` to ControlPill, so when reacting to `addKeyframeSignal`, ControlPill uses its own `timePercent`; effect order can make this slightly inconsistent (minor).

---

## What we want

- **Add keyframes only when the user explicitly asks** (e.g. “Add Keyframe” button or a dedicated action), not on every `pushHistory`. Updating the snapshot at the current keyframe when the user edits/drags is fine (existing drag-end and `markKeyframeSnapshotPending` logic).
- **Allow more keyframes** – configurable or higher limit (e.g. 20–30) and clear UI feedback when at limit.
- **Relax or make configurable the 4% rule** – e.g. 2% or a setting, so adding keyframes doesn’t fail so often when the playhead is near an existing keyframe.
- **Optional:** Pass `externalTimePercent={timePercent}` from App to ControlPill so the playhead used for add-keyframe is the same as the one used for snapshots.

---

## Key files and symbols

- **App.jsx:** `pushHistory`, `setKeyframeSignal`, `keyframeSnapshots`, `markKeyframeSnapshotPending`, `findEditTargetKeyframe`, `snapshotSlateState`, `ControlPill` usage (no `externalTimePercent`).
- **ControlPill.jsx:** `addKeyframeAtTime` (10-keyframe check, MIN_DISTANCE 4), the `useEffect` that depends on `addKeyframeSignal` and calls `addKeyframeAtTime(timePercent)`.

---

## Full diagnosis (for reference)

A full technical diagnosis is in **KEYFRAME_DIAGNOSIS.md** in this repo. The agent can use it for implementation details, recommended next steps, and file references.

---

**TL;DR for the Codex prompt:**  
“Keyframe add is currently triggered on every slate change (e.g. drag start) and is limited to 10 keyframes with a 4% min distance, so with many players we hit the limit and ‘too close’ constantly. We want: add keyframes only on explicit user action; higher or configurable keyframe limit; relaxed or configurable min distance; optional playhead sync via externalTimePercent. See KEYFRAME_DIAGNOSIS.md and NOTE_FOR_CHATGPT_CODEX_PROMPT.md for details.”</file><file path="package.json">{
  &quot;name&quot;: &quot;coachable&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;lint&quot;: &quot;eslint .&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@emotion/react&quot;: &quot;^11.14.0&quot;,
    &quot;@emotion/styled&quot;: &quot;^11.14.1&quot;,
    &quot;@mui/material&quot;: &quot;^7.3.7&quot;,
    &quot;@tailwindcss/vite&quot;: &quot;^4.1.18&quot;,
    &quot;react&quot;: &quot;^19.2.0&quot;,
    &quot;react-color&quot;: &quot;^2.19.3&quot;,
    &quot;react-dom&quot;: &quot;^19.2.0&quot;,
    &quot;react-icons&quot;: &quot;^5.5.0&quot;,
    &quot;react-konva&quot;: &quot;^19.2.1&quot;,
    &quot;tailwindcss&quot;: &quot;^4.1.18&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@eslint/js&quot;: &quot;^9.39.1&quot;,
    &quot;@types/react&quot;: &quot;^19.2.5&quot;,
    &quot;@types/react-dom&quot;: &quot;^19.2.3&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^5.1.1&quot;,
    &quot;eslint&quot;: &quot;^9.39.1&quot;,
    &quot;eslint-plugin-react-hooks&quot;: &quot;^7.0.1&quot;,
    &quot;eslint-plugin-react-refresh&quot;: &quot;^0.4.24&quot;,
    &quot;globals&quot;: &quot;^16.5.0&quot;,
    &quot;vite&quot;: &quot;^7.2.4&quot;
  }
}</file><file path="README.md"># Coachable

## Setup Instructions

Follow these steps to set up the project on your machine:

### Prerequisites

- **Node.js** (version 18 or higher recommended)
- **npm** (comes with Node.js) or **yarn**

To check if you have Node.js installed, run:
```bash
node --version
npm --version
```

If you don&apos;t have Node.js installed, download it from [nodejs.org](https://nodejs.org/).

### Installation Steps

1. **Clone or download the repository**
   ```bash
   cd coachable
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```
   This will install all required packages listed in `package.json`.

3. **Start the development server**
   ```bash
   npm run dev
   ```
   The application will start and you should see a local URL (typically `http://localhost:5173`) in your terminal.

4. **Open in your browser**
   - Open the URL shown in the terminal (usually `http://localhost:5173`)
   - The page should load and you can start using the application

### Available Scripts

- `npm run dev` - Start the development server
- `npm run build` - Build the project for production
- `npm run preview` - Preview the production build locally
- `npm run lint` - Run ESLint to check for code issues

### Troubleshooting

- If you encounter dependency issues, try deleting `node_modules` and `package-lock.json`, then run `npm install` again
- Make sure you&apos;re using a compatible Node.js version (18+)
- If the port is already in use, Vite will automatically try the next available port

## Canvas Coordinates and Centering

- Background field is centered using CSS: `left: 50%`, `top: 50%`, `transform: translate(-50%, -50%)`.
- World zoom now centers correctly by using `transform-origin: 50% 50%`.
- Item coordinates use a centered origin: `(0, 0)` is the middle of the screen/field. Positive `x` moves right; positive `y` moves down.
- Items render inside a center-origin container so their `left/top` are measured from the center.

Implications:
- New players/balls added at `{ x: 0, y: 0 }` appear at center.
- Panning still uses the camera `{ x, y }` and does not change item world coordinates.
- If you previously relied on top-left–based item coordinates, update your logic to the centered system.

Key files:
- `src/canvas/FieldLayer.jsx` – centers the field image.
- `src/canvas/WorldLayer.jsx` – applies camera transform with center `transform-origin`.
- `src/canvas/ItemsLayer.jsx` – wraps items in a center-origin container.</file><file path="SIDEBAR_BREAKDOWN_PLAN.md"># Sidebar Breakdown Plan

Break down the Sidebar into a `sidebar/` folder of section components, lift tool/button state and click events to the parent (App), and align with the patterns used in **ControlPill** (callbacks up, optional external control) and **RightPanel** (layout + sections, props/callbacks from App).

---

## 1. Target folder structure

```
src/components/
├── Sidebar.jsx                    # Thin wrapper that imports from sidebar/ and passes props
└── sidebar/
    ├── README.md                  # API, callbacks, section list (this plan in doc form)
    ├── SidebarRoot.jsx            # Main component: &lt;aside&gt;, layout, compose sections
    ├── SelectToolSection.jsx      # Select/Hand chevron + popover
    ├── PenToolSection.jsx         # Pen/Arrow chevron + popover
    ├── EraserToolSection.jsx      # Eraser chevron + popover
    ├── AddPlayerSection.jsx       # Add Player chevron + popover (form + player search)
    ├── PlayerColorSection.jsx     # Player color chevron + popover (red/blue)
    ├── PrefabsSection.jsx         # Prefabs chevron + popover
    └── HistoryActionsSection.jsx  # Undo, Redo, Reset buttons
```

Shared UI (buttons, popovers, tooltips) stays in `subcomponents/` (Buttons, Popovers, PrefabsPopover). Section components use those and report state/clicks up via callbacks.

---

## 2. State and callbacks to send up

Sidebar should **own** tool/UI state internally (like ControlPill) and **notify** the parent via optional callbacks. App (or any parent) can use these to drive canvas tool, undo/redo, etc.

### 2.1 Tool and sub-tool state

| State              | Type                      | Callback                     | When it’s sent |
|--------------------|---------------------------|------------------------------|----------------|
| Selected tool      | `&quot;select&quot; \| &quot;hand&quot; \| &quot;pen&quot; \| &quot;eraser&quot; \| &quot;addPlayer&quot; \| &quot;player&quot; \| &quot;prefab&quot;` | `onToolChange(tool)`         | When user picks a tool (main button or sub-option). |
| Select sub-tool    | `&quot;select&quot; \| &quot;hand&quot;`      | `onSelectSubTool?(subTool)`  | When user picks Select or Hand in the select popover. |
| Pen sub-tool       | `&quot;pen&quot; \| &quot;arrow&quot;`        | `onPenSubTool?(subTool)`     | When user picks Pen or Arrow in the pen popover. |
| Eraser sub-tool    | `&quot;full&quot; \| &quot;partial&quot;`     | `onEraserSubTool?(subTool)`  | When user picks Full or Partial in the eraser popover. |
| Player color       | `string` (hex)             | `onPlayerColorChange?(hex)`  | When user picks red/blue (or future colors) in the player popover. |

Existing `onToolChange` stays. When the tool is select/hand, its value is the select sub-tool (`&quot;select&quot;` or `&quot;hand&quot;`). Other tools can be reported as `&quot;pen&quot;`, `&quot;eraser&quot;`, `&quot;addPlayer&quot;`, `&quot;player&quot;`, `&quot;prefab&quot;` so the canvas (or App) knows the current mode.

### 2.2 Button click callbacks

| Button / Action       | Callback               | When it’s sent |
|-----------------------|------------------------|----------------|
| Undo                   | `onUndo?()`            | User clicks Undo. |
| Redo                   | `onRedo?()`            | User clicks Redo. |
| Reset                  | `onReset?()`           | User clicks Reset. |
| Prefab chosen          | `onPrefabSelect?(prefab)` | User selects a prefab in the Prefabs popover. |
| Add player submit      | `onAddPlayer?(data)`   | User submits add-player form (number, name, assignTo). Optional; can be added when form is wired. |

All of these are optional so Sidebar works standalone.

### 2.3 Summary: props the parent can pass

```js
// Optional: receive state updates (like ControlPill)
onToolChange(tool)              // current tool id
onSelectSubTool(subTool)        // &quot;select&quot; | &quot;hand&quot;
onPenSubTool(subTool)           // &quot;pen&quot; | &quot;arrow&quot;
onEraserSubTool(subTool)        // &quot;full&quot; | &quot;partial&quot;
onPlayerColorChange(hex)
onUndo()
onRedo()
onReset()
onPrefabSelect(prefab)
onAddPlayer(data)               // when implemented

// Optional: external control / two-way (like ControlPill’s externalTimePercent)
selectedTool?: string
selectToolType?: &quot;select&quot; | &quot;hand&quot;
penToolType?: &quot;pen&quot; | &quot;arrow&quot;
eraserToolType?: &quot;full&quot; | &quot;partial&quot;
playerColor?: string

// Optional: data from parent (like RightPanel’s playersById)
players?: Array&lt;{ id, name, ... }&gt;   // for Add Player “Assign To” dropdown
prefabs?: Array&lt;PrefabConfig&gt;        // for Prefabs popover
```

---

## 3. Section components and their contracts

Each section renders one “row” in the sidebar (icon + optional popover) and gets the callbacks and state it needs from `SidebarRoot`.

### 3.1 SelectToolSection

- **Renders:** `SidebarChevronButton` (Select or Hand icon), `Tooltip`, `Popover` with Select / Hand options.
- **Receives from parent:**  
  `selectedTool`, `selectToolType`, `openPopover`, `hoveredTooltip`,  
  `onToolSelect`, `onSelectSubTool`, `onPopoverToggle`, `onPopoverClose`, `onHoverTooltip`, `anchorRef`.
- **Behavior:** On main click → set tool to current `selectToolType` and call `onToolSelect(selectToolType)`. On option click → update sub-tool and call `onSelectSubTool(option)`, then close popover. Keyboard shortcuts (S/H) can stay in SidebarRoot and call the same callbacks.

### 3.2 PenToolSection

- **Renders:** Pen/Arrow chevron button, tooltip, popover with Pen / Arrow.
- **Receives:** `selectedTool`, `penToolType`, `openPopover`, `hoveredTooltip`, `onToolSelect(&quot;pen&quot;)`, `onPenSubTool`, `onPopoverToggle`, `onPopoverClose`, `onHoverTooltip`, `anchorRef`.
- **Behavior:** Main click → select pen tool. Option click → set pen sub-tool, call `onPenSubTool(option)`, close popover.

### 3.3 EraserToolSection

- **Renders:** Eraser chevron button, tooltip, popover with Full / Partial.
- **Receives:** `selectedTool`, `eraserToolType`, `openPopover`, `hoveredTooltip`, `onToolSelect(&quot;eraser&quot;)`, `onEraserSubTool`, `onPopoverToggle`, `onPopoverClose`, `onHoverTooltip`, `anchorRef`.
- **Behavior:** Same pattern as Pen.

### 3.4 AddPlayerSection

- **Renders:** Add Player chevron button, tooltip, popover with form (Number, Name, Assign To + player search).
- **Receives:** `selectedTool`, `openPopover`, `playerSearch`, `showPlayerDropdown`, `players` (optional),  
  `onToolSelect(&quot;addPlayer&quot;)`, `onPopoverToggle`, `onPopoverClose`, `onPlayerSearchChange`, `onPlayerAssign`, `onHoverTooltip`, `anchorRef`, `dropdownRef`.
- **Behavior:** Main click → select add-player tool. Form and “Assign To” are local to this section; when we add “Add” submit, call `onAddPlayer({ number, name, assignTo })`.

### 3.5 PlayerColorSection

- **Renders:** Player color dot chevron button, tooltip, popover with Red / Blue (and later more colors).
- **Receives:** `selectedTool`, `playerColor`, `openPopover`, `hoveredTooltip`, `onToolSelect(&quot;player&quot;)`, `onPlayerColorChange`, `onPopoverToggle`, `onPopoverClose`, `onHoverTooltip`, `anchorRef`.
- **Behavior:** Main click → select player tool. Color option click → call `onPlayerColorChange(hex)`, close popover.

### 3.6 PrefabsSection

- **Renders:** Prefabs chevron button, tooltip, popover with prefab list (from `prefabs` prop or default list).
- **Receives:** `openPopover`, `hoveredTooltip`, `prefabs`, `onPopoverToggle`, `onPopoverClose`, `onPrefabSelect`, `onHoverTooltip`, `anchorRef`.
- **Behavior:** Chevron toggles popover. Choosing a prefab calls `onPrefabSelect(prefab)` and can call `onToolChange(&quot;prefab&quot;)` (or equivalent) so parent knows tool switched to prefab mode.

### 3.7 HistoryActionsSection

- **Renders:** Undo, Redo, Reset icon buttons and tooltips.
- **Receives:** `onUndo`, `onRedo`, `onReset`, `onHoverTooltip` (and maybe `hoveredTooltip` for tooltip visibility).
- **Behavior:** Each button calls its callback on click. No tool state; only actions.

---

## 4. SidebarRoot.jsx – main orchestrator

- **State owned inside SidebarRoot (unless overridden by props):**  
  `selectedTool`, `selectToolType`, `penToolType`, `eraserToolType`, `playerColor`, `openPopover`, `hoveredTooltip`, `playerSearch`, `showPlayerDropdown`.
- **Effects:**  
  - When `selectedTool` (or select sub-tool) changes, call `onToolChange` with the appropriate value (e.g. when tool is select/hand, send `selectToolType`; otherwise send `selectedTool`).  
  - Same pattern as current Sidebar: keyboard S/H updates local state and triggers `onToolChange`.
- **Refs:** One ref per section that has a popover (select, pen, eraser, addPlayer, playerColor, prefabs), or a single map keyed by popover id; pass `anchorRef` into each section.
- **Layout:**  
  - One `SelectToolSection` … `HistoryActionsSection` per slot, with `&lt;hr /&gt;` dividers between groups as in the current Sidebar.  
  - Reuse `subcomponents/` for `SidebarChevronButton`, `Button`, `Popover`, `PopoverGrid`, `PopoverForm`, `Tooltip`, `PrefabsPopover`.

---

## 5. Wiring in App.jsx

After breakdown, App (or the layout that renders Sidebar) should:

1. **Import** `Sidebar` from `./components/Sidebar`, and keep `Sidebar` as a thin shell that renders `&lt;SidebarRoot ... /&gt;` with the same props.
2. **State in App (optional):**  
   e.g. `sidebarTool`, `sidebarSelectSubTool`, etc., if you want to read or control Sidebar from outside.
3. **Callbacks:**  
   - `onToolChange` → already used for `setCanvasTool` when tool is `&quot;hand&quot;` or `&quot;select&quot;`.  
   - `onUndo`, `onRedo`, `onReset` → pass the same handlers you use for RightPanel/field (`onUndo`, `onRedo`, `onReset`) so Undo/Redo/Reset in the sidebar and in the panel stay in sync.  
   - `onPrefabSelect`, `onPlayerColorChange`, etc. when you need them for canvas or future features.

Example:

```jsx
&lt;Sidebar
  onToolChange={(tool) =&gt; {
    if (tool === &quot;hand&quot; || tool === &quot;select&quot;) setCanvasTool(tool);
  }}
  onUndo={onUndo}
  onRedo={onRedo}
  onReset={onReset}
  onPrefabSelect={(prefab) =&gt; { /* ... */ }}
  onPlayerColorChange={(hex) =&gt; { /* ... */ }}
/&gt;
```

---

## 6. Implementation order

1. **Create `sidebar/` folder** and add `README.md` (summarize this plan: sections, callbacks, usage).
2. **Add `SidebarRoot.jsx`** and move the existing Sidebar logic into it (state, refs, effects, layout structure). Keep rendering one big block first; get behavior and callbacks correct.
3. **Extract sections one by one** (e.g. first `HistoryActionsSection`, then `SelectToolSection`, then Pen, Eraser, AddPlayer, PlayerColor, Prefabs). After each extraction, pass in the right props and callbacks from SidebarRoot so state and clicks still go up as in §2.
4. **Introduce `onUndo` / `onRedo` / `onReset`** from SidebarRoot to the parent and wire them in App to your existing field handlers.
5. **Rename/organize:** Keep `Sidebar.jsx` in `components/` as the public entry that renders `SidebarRoot` from `sidebar/SidebarRoot.jsx`, so imports in App don’t need to change.
6. **Optional:** Add `onSelectSubTool`, `onPenSubTool`, `onEraserSubTool`, `onPlayerColorChange`, `onPrefabSelect` (and later `onAddPlayer`) in App when you need to react to those in the canvas or elsewhere.

---

## 7. Consistency with ControlPill and RightPanel

- **ControlPill:** Owns state, reports via `onTimePercentChange`, `onKeyframesChange`, etc. Optional `external*` props for two-way binding.  
  → **Sidebar:** Same idea: SidebarRoot owns tool/UI state, reports via `onToolChange`, `onUndo`, etc.; optional `selectedTool` / `selectToolType` / … for controlled mode.
- **RightPanel:** No local domain state; receives `playName`, `zoomPercent`, `onPlayNameChange`, etc. from App.  
  → **Sidebar:** Same idea for *data* coming from parent: `players`, `prefabs` are optional props; tool state can stay in Sidebar and only be “reported” up, or be driven by App if you add `selectedTool` / … props.

This keeps the Sidebar’s state and button clicks clearly defined and sent up via a small set of callbacks, matching how the control pill and right panel are structured.</file><file path="SIDEBAR_STATE_ANALYSIS.md"># Sidebar State Analysis &amp; Refactoring Plan

## Overview
The Sidebar component manages tool selection, player management, and drawing tools. This document outlines what state should be exposed to the parent component and how to refactor it.

---

## Critical State to Expose (Required for External Control)

### 1. **selectedTool** (Current Active Tool)
- **Type**: `string`
- **Values**: `&quot;select&quot; | &quot;hand&quot; | &quot;pen&quot; | &quot;arrow&quot; | &quot;eraser&quot; | &quot;addPlayer&quot; | &quot;player&quot; | &quot;prefab&quot;`
- **Purpose**: The currently active/selected tool in the sidebar
- **Critical**: YES - Other components need to know which tool is active
- **Usage**: 
  - Canvas/canvas components need to know what tool mode to use
  - Different tools enable different interactions
  - Affects cursor and interaction behavior

### 2. **toolConfig** (Tool Configuration Object)
- **Type**: `object`
- **Structure**:
  ```typescript
  {
    selectTool: &quot;select&quot; | &quot;hand&quot;,
    penTool: &quot;pen&quot; | &quot;arrow&quot;,
    eraserTool: &quot;full&quot; | &quot;partial&quot;
  }
  ```
- **Purpose**: Configuration for each tool type (sub-options)
- **Critical**: YES - Determines exact behavior of each tool
- **Usage**: 
  - Canvas needs to know if pen is &quot;pen&quot; or &quot;arrow&quot; mode
  - Canvas needs to know if eraser is &quot;full&quot; or &quot;partial&quot;
  - Canvas needs to know if select is &quot;select&quot; or &quot;hand&quot; (pan) mode

### 3. **playerColor** (Player Color)
- **Type**: `string` (hex color)
- **Purpose**: Current color selected for players
- **Critical**: YES - When adding/editing players, this color is used
- **Usage**: 
  - When placing players on canvas, use this color
  - When editing existing players, apply this color
  - Sync with player color picker

---

## Important State to Expose (Useful for Context)

### 4. **playerData** (Player Form Data)
- **Type**: `object | null`
- **Structure**:
  ```typescript
  {
    number: string,
    name: string,
    assignedTo: string  // Player name from search
  } | null
  ```
- **Purpose**: Data entered in the &quot;Add Player&quot; form
- **Critical**: NO - But useful for tracking what player is being added
- **Usage**: 
  - When &quot;addPlayer&quot; tool is selected and user clicks canvas, create player with this data
  - Track form state for validation
  - Could be used for editing existing players

### 5. **selectedPrefab** (Selected Prefab)
- **Type**: `object | null`
- **Structure**: Prefab object from prefabs array
- **Purpose**: Currently selected prefab configuration
- **Critical**: NO - But needed when placing prefabs
- **Usage**: 
  - When prefab tool is active and user clicks canvas, place prefab with this config
  - Prefab includes: id, label, mode, icon, dropdowns with values

---

## Optional State (Internal Only - May Not Need Exposure)

### 6. **openPopover** (UI State)
- **Type**: `string | null`
- **Purpose**: Which popover is currently open
- **Critical**: NO - Pure UI state, no external impact

### 7. **hoveredTooltip** (UI State)
- **Type**: `string | null`
- **Purpose**: Which tooltip is being hovered
- **Critical**: NO - Pure UI state, no external impact

### 8. **playerSearch** (Internal Search State)
- **Type**: `string`
- **Purpose**: Search query for player dropdown
- **Critical**: NO - Internal to player selection UI

### 9. **showPlayerDropdown** (UI State)
- **Type**: `boolean`
- **Purpose**: Whether player dropdown is visible
- **Critical**: NO - Pure UI state

---

## Actions/Events to Expose

### 1. **onToolChange** (Tool Selection Changed)
- **Callback**: `(tool: string, toolConfig: ToolConfig) =&gt; void`
- **Purpose**: Notify parent when tool selection changes
- **Usage**: Update canvas mode, cursor, interaction handlers

### 2. **onPlayerColorChange** (Player Color Changed)
- **Callback**: `(color: string) =&gt; void`
- **Purpose**: Notify parent when player color changes
- **Usage**: Update player color in canvas, sync with existing players

### 3. **onAddPlayer** (Add Player Action)
- **Callback**: `(playerData: PlayerData, color: string) =&gt; void`
- **Purpose**: Triggered when user wants to add a player (after form submission or canvas click)
- **Usage**: Create new player on canvas with provided data

### 4. **onPrefabSelect** (Prefab Selected)
- **Callback**: `(prefab: Prefab) =&gt; void`
- **Purpose**: Notify parent when a prefab is selected
- **Usage**: Prepare canvas for prefab placement

### 5. **onUndo** (Undo Action)
- **Callback**: `() =&gt; void`
- **Purpose**: Undo last action
- **Usage**: Integrate with canvas undo system

### 6. **onRedo** (Redo Action)
- **Callback**: `() =&gt; void`
- **Purpose**: Redo last undone action
- **Usage**: Integrate with canvas redo system

### 7. **onReset** (Reset Action)
- **Callback**: `() =&gt; void`
- **Purpose**: Reset canvas/workspace
- **Usage**: Clear canvas, reset to initial state

---

## Recommended Props Interface

```typescript
interface SidebarProps {
  // Callbacks for state changes
  onToolChange?: (tool: string, toolConfig: ToolConfig) =&gt; void;
  onPlayerColorChange?: (color: string) =&gt; void;
  onAddPlayer?: (playerData: PlayerData, color: string) =&gt; void;
  onPrefabSelect?: (prefab: Prefab) =&gt; void;
  onUndo?: () =&gt; void;
  onRedo?: () =&gt; void;
  onReset?: () =&gt; void;
  
  // Optional: External control (two-way binding)
  externalSelectedTool?: string;
  externalToolConfig?: ToolConfig;
  externalPlayerColor?: string;
  
  // Optional: Data from parent
  players?: string[];  // Allow parent to provide player list
  prefabs?: Prefab[];  // Allow parent to provide prefabs
}

interface ToolConfig {
  selectTool: &quot;select&quot; | &quot;hand&quot;;
  penTool: &quot;pen&quot; | &quot;arrow&quot;;
  eraserTool: &quot;full&quot; | &quot;partial&quot;;
}

interface PlayerData {
  number: string;
  name: string;
  assignedTo: string;
}

interface Prefab {
  id: string;
  label: string;
  mode: &quot;offense&quot; | &quot;defense&quot;;
  icon: React.ReactNode;
  dropdowns: Array&lt;{
    label: string;
    options: string[];
    value: string;
    onChange: (value: string) =&gt; void;
  }&gt;;
}
```

---

## Suggested Component Breakdown Structure

```
components/
  subcomponents/
    sidebar/
      ToolSelector.jsx        # Select tool (select/hand)
      PenTool.jsx            # Pen tool (pen/arrow)
      EraserTool.jsx         # Eraser tool (full/partial)
      AddPlayerTool.jsx      # Add player tool with form
      PlayerColorTool.jsx    # Player color picker
      PrefabsTool.jsx        # Prefabs selector
      ActionButtons.jsx      # Undo, Redo, Reset buttons
      Sidebar.jsx            # Main component (orchestrates subcomponents)
```

---

## State Management Strategy

### Option 1: Callback-Based (Recommended)
- Sidebar manages its own state internally
- Exposes state changes via callbacks
- Parent can listen to changes but doesn&apos;t control state
- **Pros**: Simple, Sidebar remains self-contained
- **Cons**: Parent can&apos;t programmatically change tools

### Option 2: Controlled Component
- Parent manages all state
- Sidebar receives state as props
- Sidebar calls callbacks to request state changes
- **Pros**: Full control from parent
- **Cons**: More complex, parent must manage all state

### Option 3: Hybrid (Recommended for Flexibility)
- Sidebar manages internal state by default
- Optional props allow parent to control state externally
- Best of both worlds
- **Pros**: Flexible, can work standalone or controlled
- **Cons**: Slightly more complex implementation

---

## Key Functions to Expose

1. **getCurrentTool()** - Returns current tool and config
2. **setTool(tool, config?)** - Programmatically set tool
3. **getPlayerColor()** - Returns current player color
4. **setPlayerColor(color)** - Set player color
5. **getPlayerFormData()** - Returns current player form data
6. **clearPlayerForm()** - Reset player form

---

## Integration Points

### Canvas Integration
- Canvas needs to know: `selectedTool`, `toolConfig`
- When tool is &quot;addPlayer&quot;, canvas should create player on click
- When tool is &quot;prefab&quot;, canvas should place prefab on click
- When tool is &quot;pen&quot;, canvas should draw with pen/arrow mode
- When tool is &quot;eraser&quot;, canvas should erase with full/partial mode

### Player Management Integration
- Player color changes should update existing players if needed
- Add player action should create player with form data + color
- Player list could come from external source (API, state management)

### Prefab Integration
- Prefab selection should prepare canvas for placement
- Prefab dropdown values should be accessible when placing
- Prefab mode (offense/defense) affects placement behavior

---

## Notes

- **Tool States**: The selectedTool can be different from the tool type (e.g., selectedTool=&quot;pen&quot; but penToolType=&quot;arrow&quot;)
- **Player Form**: The &quot;Add Player&quot; form has three fields: Number, Name, Assign To
- **Prefabs**: Each prefab has dropdowns that can be configured (e.g., number of players, area, formation)
- **Undo/Redo**: Currently empty handlers - should integrate with canvas undo/redo system
- **Reset**: Currently empty handler - should clear canvas/workspace

---

## Migration Steps

1. **Phase 1**: Add callbacks to existing Sidebar (non-breaking)
2. **Phase 2**: Break down into subcomponents
3. **Phase 3**: Add external control props (optional)
4. **Phase 4**: Integrate with canvas/other components

---

## Example Usage

```jsx
function App() {
  const [currentTool, setCurrentTool] = useState(&quot;select&quot;);
  const [toolConfig, setToolConfig] = useState({
    selectTool: &quot;select&quot;,
    penTool: &quot;pen&quot;,
    eraserTool: &quot;full&quot;
  });
  const [playerColor, setPlayerColor] = useState(&quot;#561ecb&quot;);

  const handleToolChange = (tool, config) =&gt; {
    setCurrentTool(tool);
    setToolConfig(config);
    console.log(&quot;Tool changed:&quot;, tool, config);
  };

  const handleAddPlayer = (playerData, color) =&gt; {
    console.log(&quot;Add player:&quot;, playerData, &quot;with color:&quot;, color);
    // Create player on canvas
  };

  return (
    &lt;Sidebar
      onToolChange={handleToolChange}
      onPlayerColorChange={setPlayerColor}
      onAddPlayer={handleAddPlayer}
      externalSelectedTool={currentTool}
      externalToolConfig={toolConfig}
      externalPlayerColor={playerColor}
    /&gt;
  );
}
```</file><file path="todo.md">Download play file as json</file><file path="vite.config.js">import { defineConfig } from &apos;vite&apos;
import react from &apos;@vitejs/plugin-react&apos;
import tailwindcss from &apos;@tailwindcss/vite&apos;

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
})</file></files></repomix>